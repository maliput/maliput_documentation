<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput: Maliput Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('maliput_design.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Maliput Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#modeling_road_networks_for_simulation">Modeling Road Networks for Simulation</a><ul><li class="level2"><a href="#objectives">Objectives</a></li>
</ul>
</li>
<li class="level1"><a href="#road_network_goemetry">Road Network Geometry</a><ul><li class="level2"><a href="#geometry_model">Geometry Model</a><ul><li class="level3"><a href="#overview">Overview</a></li>
<li class="level3"><a href="#scale_length_and_tolerances">Scale Length and Tolerances</a></li>
<li class="level3"><a href="#inertial_frame_versus_lane_frame">`Inertial`-frame versus `Lane`-frame</a></li>
<li class="level3"><a href="#lanes_as_lanes">Lanes as `Lanes`</a></li>
<li class="level3"><a href="#lanes_joined_via_branchpoints">Lanes Joined End-to-End via `BranchPoints`</a></li>
<li class="level3"><a href="#adjacent_lanes_grouped_into_segments">Adjacent Lanes Grouped into `Segments`</a></li>
<li class="level3"><a href="#intersecting_segments_grouped_into_junctions">Intersecting `Segments` Grouped into `Junction`</a></li>
</ul>
</li>
<li class="level2"><a href="#abstract_geometry_api_roadgeometry">Abstract Geometry API: `RoadGeometry`</a><ul><li class="level3"><a href="#basic_types">Basic Types</a></li>
<li class="level3"><a href="#roadgeometry">`RoadGeometry`</a></li>
<li class="level3"><a href="#junction">`Junction`</a></li>
<li class="level3"><a href="#segment">`Segment`</a></li>
<li class="level3"><a href="#lane">`Lane`</a></li>
<li class="level3"><a href="#branchpoints">`BranchPoints`</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#rules_and_features_databases">Rules and Features Databases</a><ul><li class="level2"><a href="#rules_of_the_road">Rules of the Road: `RoadRulebook`</a><ul><li class="level3"><a href="#common_region_entities">Common Region Entities</a></li>
<li class="level3"><a href="#speed_limit_rules">`SpeedLimitRule`: Speed Limits</a></li>
<li class="level3"><a href="#right_of_way_rule">`RightOfWayRule`: Stopping and Yielding</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Matt Marjanović </dd>
<dd>
Chien-Liang Fok </dd>
<dd>
Agustin Alba Chicar </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 25, 2019</dd></dl>
<h1><a class="anchor" id="modeling_road_networks_for_simulation"></a>
Modeling Road Networks for Simulation</h1>
<p>This document describes <code>maliput</code>, a model of road networks for use in agent and traffic simulations. At the core of <code>maliput</code> is a mathematical model of the geometry and topology of a road network. That model is practically expressed by an abstract C++ API which is intended to be independent of any specific on-disk format for persistent road data. Concrete implementations of the abstract API allow various sources of road network data to be expressed via the common <code>maliput</code> model.</p>
<h2><a class="anchor" id="objectives"></a>
Objectives</h2>
<p>Driving happens on roads (most of the time); the <em>road network</em> is a fundamental structure in the task of driving. Any non-trivial simulation of driving will involve some model of roads &mdash; the surface on which the vehicles are moving. Our top-level goals for the <code>maliput</code> model are:</p>
<ul>
<li>make it easy to develop simple but rich agents to drive the <em>ado</em>-cars, the secondary vehicles which interact with and exercise the behaviors of the <em>ego</em>-cars; (1)</li>
<li>provide a ground-truth for measuring the performance and behavior of all agents in a simulation.</li>
</ul>
<p>(1): The <em>ado</em> are the supporting actors in <em>Kyogen</em>, a form of Japanese comic theater traditionally performed in the interludes between Noh plays, featuring farcical depictions of daily life.</p>
<p>For both of these goals, we need to know where vehicles and other objects are (and where they are going) with respect to one another <em>in the context of the road</em>. Thus, the <code>maliput</code> API provides methods to answer questions such as "How close am I to the edge of the lane?" and "What objects are within 100 meters ahead of me in my current lane?"</p>
<p><code>maliput</code> is intended to be agnostic of the data source for a road network. Concrete implementations for different data sources will expose the same abstract interface. Some networks may be completely synthetic (constructed by hand, or even procedurally), others will be created from measurements of real-life roads.</p>
<p>We expect to have implementations to support:</p><ul>
<li>assembling simple geometric primitives for procedural roads (e.g., completely synthetic roads for unit-test cases);</li>
<li>interpolating smooth roads from geographic position and orientation samples measured from real roads;</li>
<li>loading of road networks stored in the <a href="http://opendrive.org">OpenDRIVE</a> format.</li>
</ul>
<p>The C++ API is also intended to allow for tiling, i.e., instantiating fragments of very large, complex road networks on-demand and disposing of fragments that are no longer immediately necessary.</p>
<h1><a class="anchor" id="road_network_goemetry"></a>
Road Network Geometry</h1>
<h2><a class="anchor" id="geometry_model"></a>
Geometry Model</h2>
<h3><a class="anchor" id="overview"></a>
Overview</h3>
<p>At the core of <code>maliput</code> is a mathematical model for the geometry of the space around a road network; it is a model of both the road surface and the volume proximal to that surface. In the abstract, one can think of "a road" as a 2D manifold (the road surface) embedded in 3D space (the physical universe). The manifold structure is important because much of driving involves figuring out where things are in relation to the road. The embedding is important, too, because physical sensing and actuation (and realistic visualization) happens in physical space. In <code>maliput</code>, we consider the <em>road volume</em> and not just the <em>road surface</em> because we want to be able to describe objects and events which are not glued to the surface &mdash; e.g., stop lights, street signs, watermelons falling off of trucks.</p>
<p>In super-mathy terms:</p><ul>
<li>The world containing the road network is approximated by an inertial, locally (if not globally) flat, 3-dimensional Cartesian coordinate system referred to as the *<code>Inertial</code>-frame*.</li>
<li>The road surface is a bounded compact orientable 2-dimensional manifold embedded in the \( \mathbb{R}^3 \) <code>Inertial</code>-frame via a \( G^1 \) continuous map from \( \mathbb{R}^2 \to \mathbb{R}^3 \).</li>
<li>The road surface is extended via its normals into a bounded compact orientable 3-dimensional road volume, also embedded in the \( \mathbb{R}^3 \) <code>Inertial</code>-frame via a \( G^1 \) continuous map from \( \mathbb{R}^3 \to \mathbb{R}^3 \).</li>
<li>We impose the \( G^1 \) continuity constraint on all roads to ensure that there is a consistent, well-defined orientation everywhere on the road's manifold. (Abrupt changes in curvature are allowed, but cusps/kinks are not. Realistic violations of this rule like potholes are modeled in a different layer.) (Furthermore, we construct the maps over a finite partition of the road volume, and over each partition, we require that the maps are \( C^1 \) continuous.</li>
<li>No continuity requirement is imposed on the portion of the world that is not part of the road's manifold, including at the boundary between the road and its surroundings. For example, the edge of a road may have a curb, which can have a sudden elevation change.</li>
</ul>
<p>In the lexicon of <code>maliput</code> and its C++ API, the road volume manifold is called a <code>RoadGeometry</code>. A <code>RoadGeometry</code> is partitioned into <code>Segments</code>, which correspond to stretches of asphalt (and the space above and/or below them). Each <code>Segment</code> is a group of one or more adjacent <code>Lanes</code>. A <code>Lane</code> corresponds to a lane of travel on a road, and defines a specific parameterization of the parent <code>Segment</code>'s volume from a local <em>lane frame</em> into the <code>Inertial</code>-frame. <code>Lanes</code> are connected at <code>BranchPoints</code>, and the graph of <code>Lanes</code> and <code>BranchPoints</code> describes the topology of a <code>RoadGeometry</code>. <code>Segments</code> which map to intersecting volumes of the <code>Inertial</code>-frame (e.g., intersections) are grouped together into <code>Junctions</code>.</p>
<p>In a sense, there are two complementary object graphs in <code>maliput</code>. The container hierarchy (<code>Junctions</code> contain <code>Segments</code>, which contain <code>Lanes</code>) groups together different views of the same regions of road surface. The routing graph (<code>Lanes</code> are joined end-to-end via <code>BranchPoints</code>) describes how one can get from one region of the road network to another.</p>
<p>A <code>RoadGeometry</code> may also model paths that are adjacent to roads like sidewalks. If there is no \( G^1 \) continuity between the road and its adjacent paths, the two must be separated by <code>Segment</code> boundaries. This is not in violation of Maliput's continuity requirements because Maliput has no notion of laterally-adjacent <code>Segments</code>.</p>
<h3><a class="anchor" id="scale_length_and_tolerances"></a>
Scale Length and Tolerances</h3>
<blockquote class="doxtable">
<p>TODO: Explain the concepts of linear tolerance, angular tolerance, and characteristic scale length. </p>
</blockquote>
<h3><a class="anchor" id="inertial_frame_versus_lane_frame"></a>
`Inertial`-frame versus `Lane`-frame</h3>
<p>Two types of coordinate frames are used in this model: the (single) <code>Inertial</code>-frame and the (multiple) <code>Lane</code>-frames. In both, distances are typically measured in units of meters.</p>
<p>The <code>Inertial</code>-frame is any right-handed 3D inertial Cartesian coordinate system, with orthonormal basis \((\hat{x},\hat{y},\hat{z})\) and positions expressed as triples \((x,y,z)\). This could be a globally-flat coordinate system, e.g., ECEF ("Earth-centered,
Earth-fixed"). Or, it could be a locally-flat projection of the Earth's surface, e.g., a UTM ("Universal Transverse Mercator") projection coupled with elevation. No specific projection is mandated by <code>maliput</code>. To disambiguate for one or another <code>Inertial</code>-frame choice, the API uses the preferred <code>InertialPosition</code> type which can be interpreted for one or another frame choice.</p>
<blockquote class="doxtable">
<p><em>Currently:</em> \(\hat{z}\) is assumed to be <em>up</em>, with \(z\) representing an altitude or elevation. \(\hat{x}\) and \(\hat{y}\) span the horizontal plane. Typically, the "ENU" convention is used: \(\hat{x}\) points <em>East</em> and \(\hat{y}\) points <em>North</em>. </p>
</blockquote>
<p>Another frame will be defined, the <code>Backend</code>-frame which is different from the <code>Inertial</code>-frame by an isometric transform. This frame is also a right-handed 3D inertial Cartesian coordinate system with an orthonormal basis. It exists and potentially differs from the <code>Inertial</code>-frame because of differing contexts. Typically, the <code>Inertial</code>-frame chosen matches that of the client, e.g., a simulator that uses Maliput. Meanwhile, the <code>Backend</code>-frame typically matches the underlying data used by a particular backend, e.g., an OpenDRIVE file. The <code>Backend</code>-frame will use <code>Vector3</code> for coordinates to properly differentiate from the <code>Inertial</code>-frame type, i.e. <code>InertialPosition</code>.</p>
<p>A <code>Lane</code>-frame is a right-handed orthonormal curvilinear coordinate system, with positions expressed as coordinates \((s,r,h)\). Each <code>Lane</code> in a <code>RoadGeometry</code> defines its own embedding into the <code>Inertial</code> space, and thus each <code>Lane</code> has its own <code>Lane</code>-frame.</p>
<p>When embedded into the <code>Inertial</code> space, \(s\) represents longitudinal distance (path-length) along a central reference curve (the <em>centerline</em>) which defines a given <code>Lane</code>. \(r\) is lateral distance along the road surface, the path length along a geodesic perpendicular to the centerline. \(h\) is height above the road surface, the distance along a normal. Unless the lane is completely straight and flat, a <code>Lane</code>-frame acts like a non-inertial system: the \((s,r,h)\) are not isotropic ( \(s\) is only guaranteed to correspond to true physical distance when \((r,h) = (0,0)\) (i.e., along the centerline), and similarly \(r\) only yields a true physical distance when \(h = 0\) (i.e., along the road surface).) and the curves and twists in the embedding introduce fictitious forces in equations of motion expressed in these coordinates.</p>
<blockquote class="doxtable">
<p>TODO: Replace this gibberish with a proper description of the effects of the metric induced by the push forward of \(W_L\). We also introduce the notion of /isotropic coordinates/ \((\sigma,\rho,\eta)\) corresponding to the non-isotropic \((s,r,h)\). At every point \((s,r,h)\) in a <code>Lane</code> with its local \((\hat{s},\hat{r},\hat{h})\) coordinate frame, we define a corresponding \((\hat{\sigma},\hat{\rho},\hat{\eta})\) frame with the same orientation but different scale factors which make it isotropic. We don't use \((\sigma,\rho,\eta)\) to parameterize the space of the <code>Lane</code>, but rather to talk about physically-relevant velocities and accelerations. In other words, at a given point in a <code>Lane</code>, the magnitude of a velocity \((\dot{\sigma},\dot{\rho},\dot{\eta})\) is unchanged when mapped to \((\dot{x},\dot{y},\dot{z})\), and the direction undergoes the same rotation for all velocity vectors anchored to that point. </p>
</blockquote>
<p>Finally, we will colloquially use the term "`Road`-frame" to refer to a 4-tuple of parameters \((L,s,r,h)\) in which:</p><ul>
<li>\(L\) is an identifier which uniquely names a <code>Lane</code>;</li>
<li>\((s,r,h)\) are <code>Lane</code>-frame coordinates understood in the context of <code>Lane</code> \(L\).</li>
</ul>
<p>One can construct a map \(W: \lbrace(L,s,r,h)\rbrace \to \mathbb{R}^3\) from the road manifold into the <code>Inertial</code> space, as a union of the per <code>Lane</code> maps. This \(W\) is technically an <em>immersion</em> and not an <em>embedding</em> because it is not necessarily 1-to-1; as described later on, multiple <code>Lanes</code> in the same <code>Segment</code> will double-cover the same region of the \(\mathbb{R}^3\) <code>Inertial</code>-frame. Also, due to our representation of routing, double-coverage will occur where streets cross to form intersections, or where highways split or merge. This needs to be considered when determining the possible interactions of agents or objects that are located in nominally distinct regions of the <code>Lane</code> network.</p>
<blockquote class="doxtable">
<p>Note: Due to certain geometric constraints in <code>Lane</code>-frame parameterization, some regions of the <code>RoadGeometry</code> manifold may not be covered by the <code>Lane</code>-frame of any <code>Lane</code>. We anticipate needing an additional set of surface/volume parameterizations in the future to complete the picture. </p>
</blockquote>
<h3><a class="anchor" id="lanes_as_lanes"></a>
Lanes as `Lanes`</h3>
<p>A <code>Lane</code> represents a lane of travel in a road network, expressing a path along a stretch of asphalt as well as a parameterization of that asphalt from one lateral edge to the other (including adjacent lanes of travel, shoulders, etc).</p>
<p>As discussed above, a <code>Lane</code>, identified by \(L\), defines a map \(W_L\) from curvilinear coordinates to the <code>Inertial</code>-frame:</p>
<p class="formulaDsp">
\[ W_L: (s,r,h) \mapsto (x,y,z), \text{ for } s \in [0, s_\text{max}] \]
</p>
<p>The curve traced out by \(W_L\) along longitudinal coordinate \(s\) (while \(r\) and \(h\) are fixed to zero) is called the <em>centerline</em> of the <code>Lane</code>:</p>
<p class="formulaDsp">
\[ C_L: s \mapsto (x,y,z), = W_L(s,0,0) \text{ for } s \in [0, s_\text{max}] \]
</p>
<p>The centerline is nominally the ideal trajectory of a vehicle traveling in the lane (and it is not necessarily in the geometric center of the lane, despite the name). \(W_L\) is required to be \(C^1\) continuous, and thus \(C_L\) is also required to be \(C^1\) continuous.</p>
<p>The space of the <code>Lane</code> is bounded in \(s\) by \(s \in [0, s_\text{max}]\). \(s_\text{max}\) is called the <em>length</em> of the <code>Lane</code> and is in fact the path-length of the centerline \(C_L\) (in both the <code>Lane</code>-frame and the <code>Inertial</code>-frame). The \(s=0\) end of a <code>Lane</code> is labeled the <em>start end</em>, and the \(s=s_\text{max}\) end is the <em>finish end</em>. However, a <code>Lane</code> is just a stretch of pavement with no preferred travel direction, and there is no direction of travel implied by these labels. (2)</p>
<p>(2): Travel restrictions on a <code>Lane</code> are indicated by road rule annotations, described later in section </p><dl class="section see"><dt>See also</dt><dd>RoadRulebook.</dd></dl>
<p>A <code>Lane</code> is bounded laterally by <em>segment bounds</em>, \(r \in B_\text{segment}(s)\), where</p>
<p class="formulaDsp">
\[ B_\text{segment}: s \mapsto [r_\text{min}, r_\text{max}] \text{ s.t. } r_\text{min}&lt;=0 \text{ and } r_\text{max}&gt;=0 \]
</p>
<p>defines inclusive min/max bounds which depend only on \(s\). These are the /segment bounds/ for the <code>Lane</code>, the valid domain of \(r\), which is intended to represent the full lateral extent of the <code>Segment</code> including all adjacent <code>Lanes</code>.</p>
<blockquote class="doxtable">
<p>TODO: This begs for a picture. </p>
</blockquote>
<p>A <code>Lane</code> is also characterized by <em>nominal bounds</em>, \(r \in B_\text{nominal}(s)\), where</p>
<p class="formulaDsp">
\[ B_\text{nominal}: s \mapsto [r_\text{min}, r_\text{max}] \text{ s.t. } B_\text{nominal} \subseteq B_\text{segment} \]
</p>
<p>which indicate what is considered to be "in" that specific travel lane (e.g., between the stripes).</p>
<p>A <code>Lane</code> is bounded in height by \(h \in H_\text{lane}(s,r)\), where</p>
<p class="formulaDsp">
\[ H_\text{lane}: (s,r) \mapsto [h_\text{min}, h_\text{max}] \text{ s.t. } h_\text{min}&lt;=0 \text{ and } h_\text{max}&gt;=0 \]
</p>
<p>defines inclusive min/max bounds which depend on \(s\) and \(r\). These define the valid domain of \(h\), which represents the full extent of the volume (above and possibly below the road surface) modeled by the <code>Lane</code>. Typically, \(h_\text{min}\) is zero, but having \(h_\text{min}&lt;0\) allows a <code>Lane</code> to describe the location of subterranean features (e.g., measurements made by ground-penetrating radar).</p>
<blockquote class="doxtable">
<p>Note: Because of the orthogonality of the \((s,r,h)\) coordinates, a curve with constant non-zero \((r,h)\) (imagine \(r\) and \(h\) "grid
lines") is basically a parallel curve to the centerline \(C_L\). Thus, the shape of \(C_L\) and/or the road surface may produce limits to \((r,h)\) before such a curve develops a cusp. The current definitions of \(B_\text{segment}\) and \(H_\text{lane}\) conflate the bounds of the /segment/ volume (e.g., pavement and free space under bridges) with the bounds of the /modeled/ volume (e.g., the bounds on \(r\) and \(h\) which maintain \(G^1\) continuity, avoiding cusps). Hence, the road surface may continue into regions that cannot be properly represented by the parameterization of a given <code>Lane</code>. </p>
</blockquote>
<h3><a class="anchor" id="lanes_joined_via_branchpoints"></a>
Lanes Joined End-to-End via `BranchPoints`</h3>
<p><code>BranchPoints</code> are the points where <code>Lanes</code> are connected end-to-end. They are so named because they are the branch-points in the decision tree of an agent driving in the network, which must decide which new <code>Lane</code> to follow at the end of its current <code>Lane</code>. Each end (<em>start</em> or <em>finish</em>) of a <code>Lane</code> has an associated <code>BranchPoint</code> (3). Each <code>BranchPoint</code> has at least one <code>Lane</code> associated with it, typically two, and often more than that (when <code>Lanes</code> merge/diverge). (4)</p>
<p>We only allow <code>BranchPoints</code> to occur at the ends of <code>Lanes</code>, specifically at the ends of their centerlines ( \(C_L(s)\)). We also require that the centerlines of the <code>Lanes</code> joined at a <code>BranchPoint</code> are \(G^1\) continuous. Together with the earlier-stated requirement of overall \(G^1\) continuity of the road surface and the conditions on \(r\) and \(h\) being path-lengths, this implies that:</p><ol type="1">
<li>The location of a <code>BranchPoint</code> is a well-defined point in the <code>Inertial</code>-frame.</li>
<li>The tangent vectors of the \(C_L\) curves are either parallel or antiparallel with each other at the <code>BranchPoint</code>. In fact, except for the signs of \(\hat{s}\) and \(\hat{r}\), the frames of all the <code>Lanes</code> will have the same orientation and scale.</li>
<li>Given two <code>Lanes</code> \(J\) and \(K\) joined at a <code>BranchPoint</code> located at the <em>finish</em> end of \(J\), then a position \((s_\text{max,J}, r, h)_J\) in \(J\) will map to either \((0, r, h)\) or \((s_\text{max,K}, -r, h)_K\) in \(K\) (depending on which end of \(K\) is at the <code>BranchPoint</code>).</li>
</ol>
<p>Given point (2) above, one can imagine multiple <code>Lanes</code> converging on one side of a <code>BranchPoint</code>, flowing smoothly through it, and diverging into other <code>Lanes</code> on the other side. If one considers the "outward-traveling tangent vector" of each <code>Lane</code>, then the <code>Lanes</code> can be grouped by common orientation of outward-traveling tangent vector into at most two groups. Thus, a <code>BranchPoint</code> fundamentally has two sides to it. The sides are arbitrary, so we label them with the arbitrary names "A" and "B". With respect to a specific <code>Lane</code> \(J\), regardless of which side \(J\) is on (be it A or B):</p><ul>
<li>the <code>Lanes</code> on the "same side" as \(J\) are the <em>confluent lanes</em> of \(J\);</li>
<li>the <code>Lanes</code> on the "other side" are the <em>ongoing lanes</em> of \(J\).</li>
</ul>
<blockquote class="doxtable">
<p>TODO: figure with sample branch-point topologies:</p><ul>
<li>1:1 &mdash; simple continuation of one lane onto another;</li>
<li>1:2 &mdash; a split of one lane to two;</li>
<li>1:3 &mdash; a split of one to three, e.g., paths through an intersection with left and right turns available;</li>
<li>2:2 &mdash; a merge/split, e.g., entering and/or exiting a roundabout;</li>
<li>1:0 &mdash; you've reached the end of the road, my friend. </li>
</ul>
</blockquote>
<p>A <code>BranchPoint</code> bears one additional element of information. For each <code>Lane</code>, one of its ongoing <code>Lanes</code> may optionally be named as its <em>default-branch</em>. This serves as a semantic hint about the structure of the road. The default-branch represents the notion of "which
branch should I choose in order to continue straight ahead" (5). For example, when entering a 4-way intersection, a <code>Lane</code> may terminate with three ongoing branches: turning left, going straight, and turning right; the "go straight" branch would be designated the default-branch. Likewise, at a split in a highway, one fork might be considered the same highway, whereas the other is considered an exit. (Also, note that default-branch relationships between <code>Lanes</code> need not be symmetric.)</p>
<p>(3): This means a <code>Lane</code> has precisely two <code>BranchPoints</code>, except for the peculiar case of a <code>Lane</code> which loops around and connects to itself, at a single <code>BranchPoint</code>.</p>
<p>(4): <code>BranchPoint</code> with only a single <code>Lane</code> attached to it is basically a dead-end.</p>
<p>(5): At the <em>finish</em> end of a <code>Lane</code>, this is just the tangent of \(C_L\); at the <em>start</em> end of a <code>Lane</code>, it's the negative of the tangent, pointing in the \(-s\) direction instead of the \(+s\) direction.</p>
<h3><a class="anchor" id="adjacent_lanes_grouped_into_segments"></a>
Adjacent Lanes Grouped into `Segments`</h3>
<p>In real roads, the pavement is often divided into multiple adjacent lanes of travel; in <code>maliput</code>, adjacent <code>Lanes</code> are grouped together into <code>Segments</code>. The basic idea is that a <code>Segment</code> corresponds to a longitudinal stretch of pavement, and each <code>Lane</code> in that <code>Segment</code> presents a different \((s,r,h)\) parameterization of that same pavement.</p>
<p>We would like for the segment-bounds of each <code>Lane</code> to map to the same extent of physical space in the <code>Inertial</code>-frame, but that isn't always possible due to the geometric constraints of parallel curves. However, we do require that the union of the segment-bounds of all <code>Lanes</code> in a <code>Segment</code> is simply-connected. This means that:</p><ul>
<li>a <code>Segment</code> doesn't have any "holes" in its segment space (e.g., no impassable monument in the middle of the road);</li>
<li>it is always possible to drive from a position in one <code>Lane</code>-frame to a position in another <code>Lane</code>-frame, though it may require expressing intermediate steps in other <code>Lanes</code> to do it.</li>
</ul>
<p>Within a <code>Segment</code>, we only allow the intersection of two <code>Lane</code> centerlines (such as a lane merge/split) to occur at the endpoints of the <code>Lanes</code>, which further implies that it may occur only at a <code>BranchPoint</code>. This allows us to impose another constraint on <code>Lanes</code> in a <code>Segment</code>: they must be oriented and shaped such that there is a consistent "right-to-left" ordering in terms of increasing \(r\). In other words, within a <code>Segment</code>:</p><ol type="1">
<li>A <code>Lane</code> \(K\) is considered "left of" <code>Lane</code> \(J\) if and only if there exists a point on the centerline \(C_{K}\) of \(K\) that has a position with \(r &gt; 0\) in the <code>Lane</code>-frame of \(J\). \(K\) is "right
    of" \(J\) if and only if a point exists on \(C_{K}\) with position \(r &lt; 0\) in the frame of \(J\).</li>
<li>If and only if <code>Lane</code> \(K\) is to the left of <code>Lane</code> \(J\), then \(J\) must be to the right of \(K\).</li>
<li>For every pair of distinct <code>Lanes</code> \(J\) and \(K\), \(K\) must be either to the left or to the right of \(J\), and may not be both. A consequence of this ((2) in particular) is that the /start/ and /finish/ ends of all the <code>Lanes</code> in a <code>Segment</code> are grouped together respectively so that the <code>Lanes</code> are generally "pointing in the same direction". Given the consistent ordering, we index the <code>Lanes</code> in a <code>Segment</code> with unique integers, beginning with zero for the rightmost <code>Lane</code> and increasing leftward.</li>
</ol>
<h3><a class="anchor" id="intersecting_segments_grouped_into_junctions"></a>
Intersecting `Segments` Grouped into `Junction`</h3>
<p>It is possible for multiple <code>Segments</code> to cover the same pavement. In fact, that is how intersections are represented, by criss-crossing <code>Segments</code> which define the different paths through an intersection. Overlapping <code>Segments</code> also occur where the road merges or diverges, such as on-ramps, exit ramps, traffic circles, and a road that splits to go around an impassable monument.</p>
<p><code>Segments</code> which map to intersecting volumes in the <code>Inertial</code>-frame (in terms of the union of the segment-bounds of their <code>Lanes</code>) are grouped together into a <code>Junction</code>. The primary (sole?) purpose of a <code>Junction</code> is to indicate that objects in its component <code>Segments</code> may spatially interact with each other (e.g., collide!). Conversely, if two <code>Segments</code> belong to two distinct <code>Junction</code>, then objects within their respective segment-bounds should /not/ be touching. (Note that in considering intersection, we ignore the overlaps that may occur where <code>Segments</code> join end-to-end via their <code>Lanes</code>.)</p>
<p>Every <code>Segment</code> must belong to one and only one <code>Junction</code>, and every <code>Junction</code> must contain at least one <code>Segment</code>.</p>
<p>When designing/implementing a <code>RoadGeometry</code>, it is good practice to structure the <code>Segments</code> to minimize the spatial extent of <code>Junction</code>. For example, a single long <code>Segment</code> which crosses through two intersections would cause both intersections to belong to the same <code>Junction</code>. It would be better to split that single <code>Segment</code> into three: one crossing each intersection and one in-between that joins those two end-to-end, resulting in three independent <code>Junction</code> that are better localized.</p>
<h2><a class="anchor" id="abstract_geometry_api_roadgeometry"></a>
Abstract Geometry API: `RoadGeometry`</h2>
<blockquote class="doxtable">
<p>TODO: Explain semantics of object ID's. (cross-referencing, tiling, debugging, visualization) </p>
</blockquote>
<blockquote class="doxtable">
<p>TODO: Reference to <code><a class="el" href="namespacemaliput_1_1api.html">maliput::api</a></code> doxygen. </p>
</blockquote>
<h3><a class="anchor" id="basic_types"></a>
Basic Types</h3>
<ul>
<li><code>InertialPosition</code></li>
<li><code>LanePosition</code></li>
<li><code>RoadPosition</code></li>
<li>...</li>
</ul>
<h3><a class="anchor" id="roadgeometry"></a>
`RoadGeometry`</h3>
<ul>
<li>accessors for component <code>Junctions</code></li>
<li>accessors for component <code>BranchPoints</code></li>
<li>accessors for characteristic lengths and tolerances<ul>
<li><code>linear_tolerance</code></li>
<li><code>angular_tolerance</code></li>
<li><code>scale_length</code></li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="junction"></a>
`Junction`</h3>
<ul>
<li>accessors for parent <code>RoadGeometry</code>, component <code>Junctions</code></li>
</ul>
<h3><a class="anchor" id="segment"></a>
`Segment`</h3>
<ul>
<li>accessors for parent <code>Junction</code>, component <code>Lanes</code></li>
</ul>
<h3><a class="anchor" id="lane"></a>
`Lane`</h3>
<ul>
<li>nominal \(r\) bounds, \(B_\text{nominal}: (s) \mapsto [r_\text{min}, r_\text{max}]\)</li>
<li>segment \(r\) bounds, \(B_\text{segment}: (s) \mapsto [r_\text{min}, r_\text{max}]\)</li>
<li>segment \(h\) bounds, \(H_\text{lane}: (s,r) \mapsto [h_\text{min}, h_\text{max}]\)</li>
<li>embedding \(W_L: (s,r,h) \mapsto (x,y,z)\)</li>
<li>inverse \(W_L^{-1}: (x,y,z) \mapsto (s,r,h)\)</li>
<li><code>Lane</code>-frame orientation \(Q: (s,r,h) \mapsto \text{orientation of }(\hat{s},\hat{r},\hat{h})\)</li>
<li>isotropic scale factors \(S: (s,r,h) \mapsto (\frac{ds}{d\sigma},\frac{dr}{d\rho},\frac{dh}{d\eta})\)</li>
<li>derivatives of \(W_L\) (to compute fictitious forces)</li>
<li>accessors for parent <code>Segment</code>, associated <code>BranchPoints</code>, and left/right <code>Lanes</code>, to traverse the object graph.</li>
</ul>
<h3><a class="anchor" id="branchpoints"></a>
`BranchPoints`</h3>
<ul>
<li>accessors for <code>Lanes</code> on each side ("A" versus "B")</li>
<li>accessor for the set of confluent <code>Lanes</code> for a given <code>Lane</code></li>
<li>accessor for the set of ongoing <code>Lanes</code> for a given <code>Lane</code></li>
<li>accessor for the default branch (ongoing <code>Lane</code>) for a given <code>Lane</code></li>
<li>accessor for parent <code>RoadGeometry</code></li>
</ul>
<h1><a class="anchor" id="rules_and_features_databases"></a>
Rules and Features Databases</h1>
<h2><a class="anchor" id="rules_of_the_road"></a>
Rules of the Road: `RoadRulebook`</h2>
<p>A <code>RoadRulebook</code> (see <a class="el" href="maliput_design.html#road-rulebook-outline_img">figure</a> ) expresses the semantic "rules of the road" for a road network, as rule elements associated to components of a <code>RoadGeometry</code>. In a real, physical road network, road rules are typically signaled to users via signs or striping, though some rules are expected to be prior knowledge (e.g., "We drive on the
right-hand side here."). <code>RoadRulebook</code> abstracts away from both the physical artifacts and the symbolic state of such signals, and directly represents the intended use of a road network at a semantic level.</p>
<p>We define three levels of knowledge of rules of the road:</p><ul>
<li><em>Physical</em> <em>Sensory</em> comprises the physical artifacts (or simulated model thereof) which signal rules to the sensors of humans or vehicles. E.g., a traffic light of certain design hanging above a road, emitting light; a white / black metal sign with numbers and words, posted next to the road; a sequence of short yellow stripes painted on the ground.</li>
<li><em>Symbolic</em> is the discrete state of the signals, abstracted away from the specifics of the physical manifestation. E.g., a traffic light with four bulbs, of which the red one and the green left-facing arrow are illuminated; a speed limit sign bearing a limit of 45 miles per hour; a dashed-yellow lane separation line.</li>
<li><em>Semantic</em> is the intended rules of the road, whether from implicit knowledge, or conveyed via symbols and signals. E.g., cars traveling forward through the intersection must stop, but left-turning cars may proceed; the speed limit for a specific stretch of road is 45 mph; lane-change to the left in order to pass is permitted.</li>
</ul>
<p>The <code>RoadRulebook</code> interface only concerns the semantic level, which is the level required to provide oracular /ado/ cars with interesting interactive behaviors. (Future API's may be developed to express the sensory and symbolic levels of expression, and to coordinate between all three as required.)</p>
<p><a class="anchor" id="road-rulebook-outline_img"></a></p><div class="image">
<object type="image/svg+xml" data="road-rulebook-outline.svg">road-rulebook-outline.svg</object>
<div class="caption">
`RoadRulebook` outline.</div></div>
<p> We distinguish two kinds of state:</p><ul>
<li><em>Static state</em> comprises the aspects of a simulation which are established before the simulation begins and which cannot evolve during the runtime of the simulation. This can be considered to be the configuration of a simulation.</li>
<li><em>Dynamic state</em> comprises the aspects of a simulation which can evolve during the runtime as the simulation's time progresses.</li>
</ul>
<p>The <code>RoadRulebook</code> design decouples static state from dynamic state. Dynamic state needs to be managed during the runtime of a simulation, and different simulation frameworks have different requirements for how they store and manage dynamic state. In particular, the <code>drake</code> system framework requires that all dynamic state can be externalized and collated into a single generic state vector (called the “Context”), and the <code>RoadRulebook</code> design facilitates such a scheme. Decoupling the dynamic and static state also aids development; once the (small) interface between the two is established, development of API’s for each kind of state can proceed in parallel.</p>
<p><code>RoadRulebook</code> is an abstract interface which provides query methods to return rule instances which match some filter parameters, e.g., rules which involve a specified <code>Lane</code>. Each flavor of rule is represented by a different <code>*Rule</code> class. Rules are associated to a road network by referring to components of a <code>RoadGeometry</code> via component ID’s. Each rule is itself identified by a unique type-specific ID. This ID is the handle for manipulating the rule during rulebook configuration, and for associating the rule with physical / symbolic models and/or dynamic state in a simulation. A rule generally consists of static state, e.g., the speed limit as posted for a lane. Some rules may involve dynamic state as well. Any dynamic state will be provided by a separate entity, with an abstract interface for each flavor of dynamic state. For example, a <code>RightOfWayRule</code> may refer to dynamic state (e.g., if it represents a traffic light) via its <code>RightOfWayRule::Id</code>. An implementation of the <code>RightOfWayStateProvider</code> abstract interface will, via its <code>GetState()</code> method, return the current state for a given <code>RightOfWayRule::Id</code>. How those states are managed and evolved over time is up to the implementation.</p>
<p>Road rules can generally be interpreted as restrictions on behavior, and absent any rules, behavior is unrestricted (by rules of the road). For example, if a <code>RoadRulebook</code> does not provide a <code>SpeedLimitRule</code> for some section of the road network, then there is no speed limit established for that section of road. Whether or not an agent follows the rules is up to the agent; <code>RoadRulebook</code> merely provides the rules.</p>
<p>Six rule types are currently defined or proposed:</p>
<ul>
<li><code>SpeedLimitRule</code> - speed limits</li>
<li><code>RightOfWayRule</code> - control of right-of-way / priority on specific routes <blockquote class="doxtable">
<p></p>
</blockquote>
</li>
</ul>
<p>TODO: <code>DirectionUsageRule</code> - direction-of-travel specification</p><ul>
<li>TODO: <code>LaneChangeRule</code> - adjacent-lane transition restrictions</li>
<li>TODO: <code>OngoingRouteRule</code> - turning restrictions</li>
<li>TODO: <code>PreferentialUseRule</code> - lane-based vehicle-type restrictions (e.g., HOV lanes) </li>
</ul>
<h3><a class="anchor" id="common_region_entities"></a>
Common Region Entities</h3>
<p>A few common entities, which identify regions of the road network, occur in the various rule types:</p>
<ul>
<li><code>LaneId</code>: unique ID of a <code>Lane</code> in a <code>RoadGeometry</code>;</li>
<li><code>SRange</code>: inclusive longitudinal range \([s_0, s_1]\) between two s-coordinates;</li>
<li><code>LaneSRange</code>: a <code>LaneId</code> paired with an <code>SRange</code>, describing a longitudinal range of a specific <code>Lane</code>;</li>
<li><code>LaneSRoute</code>: a sequence of <code>LaneSRange</code>'s which describe a contiguous longitudinal path that may span multiple end-to-end connected <code>Lane</code>'s;</li>
<li><code>LaneIdEnd</code>: a pair of <code>LaneId</code> and an "end" specifier, which describes either the start or finish of a specific <code>Lane</code>.</li>
</ul>
<h3><a class="anchor" id="speed_limit_rules"></a>
`SpeedLimitRule`: Speed Limits</h3>
<p>A <code>SpeedLimitRule</code> describes speed limits on a longitudinal range of a Lane. It comprises:</p>
<ul>
<li>id</li>
<li>zone (<code>LaneSRange</code>)</li>
<li>maximum and minimum speed limits (in which a minimum of zero is effectively no minimum)</li>
<li>severity:<ul>
<li><em>strict</em> (e.g., in the US, black-on-white posted limit)</li>
<li><em>advisory</em> (e.g., in the US, black-on-yellow advisory limit on curves) <blockquote class="doxtable">
<p></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>TODO: applicable vehicle type (for limits applying to specific types):</p><ul>
<li>any</li>
<li>trucks</li>
<li>...</li>
</ul>
<p>TODO: time-of-day/calendar condition </p>
<h3><a class="anchor" id="right_of_way_rule"></a>
`RightOfWayRule`: Stopping and Yielding</h3>
<p><code>RightOfWayRule</code> describes which vehicles have right-of-way (also known as "priority"). Note that "right of way" does not mean "right
to smash through obstacles". A green light means that other cars should not enter an intersection, but the light turning green will not magically clear an intersection. Even after acquiring the right-of-way, a vehicle should still respect the physical reality of its environment and operate in a safe manner. When operating on intersecting regions of the road network. In the real world, such rules are typically signaled by stop signs, yield signs, and traffic lights, or are understood as implicit knowledge of the local laws (e.g., "vehicle on the right has priority at uncontrolled
intersections").</p>
<p>A <code>RightOfWayRule</code> instance is a collection of <code>RightOfWayRule::State</code> elements which all describe the right-of-way rules pertaining to a specific <code>zone</code> in the road network. The elements of a <code>RightOfWayRule</code> are:</p>
<table class="doxtable">
<tr>
<td><code>id</code> </td><td>unique <code>RightOfWayRule::Id</code> </td></tr>
<tr>
<td><code>zone</code> </td><td><code>LaneSRoute</code> </td></tr>
<tr>
<td><code>zone_type</code> </td><td><code>ZoneType enum {StopExcluded, StopAllowed}</code> </td></tr>
<tr>
<td><code>states</code> </td><td>set of <code>State</code> mapped by <code>State::Id</code> </td></tr>
</table>
<p>The <code>zone</code> is a directed longitudinal path in the road network, represented as a <code>LaneSRoute</code>; the rule applies to any vehicle traversing forward through the <code>zone</code>. The <code>zone_type</code> specifies whether or not vehicles are allowed to come to a stop within the <code>zone</code>. If the type is <code>StopExcluded</code>, then vehicles should not enter the <code>zone</code> if they do not expect to be able to completely transit the <code>zone</code> while they have the right-of-way, and vehicles should continue to transit and exit the <code>zone</code> if they lose the right-of-way while in the <code>zone</code>. <code>StopExcluded</code> implies a "stop line" at the beginning of the <code>zone</code>. <code>StopAllowed</code> has none of these expectations or restrictions.</p>
<p>Each <code>State</code> comprises:</p>
<table class="doxtable">
<tr>
<td><code>id</code> </td><td><code>State::Id</code> (unique within the context of the rule instance) </td></tr>
<tr>
<td><code>type</code> </td><td><code>State::Type enum: {Go, Stop, StopThenGo}</code> </td></tr>
<tr>
<td><code>yield_to</code> </td><td>list of <code>RightOfWayRule::Id</code> </td></tr>
</table>
<p>The state's <code>type</code> indicates whether a vehicle can <em>Go</em> (has right-of-way), must <em>Stop</em> (does not have right-of-way), or must <em>StopThenGo</em> (has right-of-way after coming to a complete stop). The <em>Go</em> and <em>StopThenGo</em> types are modulated by <code>yield_to</code>, which is a (possibly empty) list of references to other rule instances whose right-of-way supersedes this rule. A vehicle subject to a non-empty <code>yield_to</code> list does not necessarily have to stop, but its behavior should not hamper or interfere with the motion of vehicles which are controlled by rules in the <code>yield_to</code> list.</p>
<p>Only one <code>State</code> of a rule may be in effect at any given time. A rule instance which defines only a single <code>State</code> is called a <em>static rule</em>; its meaning is entirely static and fixed for all time. Conversely, a right-of-way rule instance with multiple <code>State</code> elements is a <em>dynamic rule</em>. Although the collection of possible <code>State</code>'s of a dynamic rule are fixed and described by the rule instance, knowing which <code>State</code> is in effect at any given time requires querying a <code>RightOfWayStateProvider</code>.</p>
<p><code>RightOfWayStateProvider</code> is an abstract interface that provides a query method that accepts a <code>RightOfWayRule::Id</code> and returns a result containing:</p>
<table class="doxtable">
<tr>
<td><code>current_id</code> </td><td><code>State::Id</code> </td></tr>
<tr>
<td><code>next_id</code> </td><td>std::optional <code>State::Id</code> </td></tr>
<tr>
<td><code>next.duration_until</code> </td><td>std::optional <code>double</code> </td></tr>
</table>
<p><code>current_id</code> is the current <code>State</code> of the rule. <code>next_id</code> is the <em>next</em> <code>State</code> of the rule, if a transition is anticipated and the next state is known. <code>next.duration_until</code> is the duration, if known, until the transition to the known next state.</p>
<p>Following are discussions on <code>RightOfWayRule</code> configurations for a few example scenarios.</p>
<p><em>Example: Uncontrolled Midblock Pedestrian Crosswalk</em></p>
<p><a class="anchor" id="RoWR-lone-crosswalk"></a></p><div class="image">
<object type="image/svg+xml" data="right-of-way-example-lone-crosswalk.svg">right-of-way-example-lone-crosswalk.svg</object>
<div class="caption">
Uncontrolled midblock pedestrian crosswalk.</div></div>
<p> <a class="el" href="maliput_design.html#RoWR-lone-crosswalk">Figure</a> illustrates a very simple scenario:</p>
<ul>
<li>One-way traffic flows northbound, crossed by an uncontrolled pedestrian crosswalk at midblock.</li>
<li>The pedestrian traffic route is not modeled in the road network, so only one zone (for the vehicular traffic intersecting the crosswalk) is involved.</li>
</ul>
<p>With only one zone and no changing signals, a single, static <code>RightOfWayRule</code> is required:</p>
<table class="doxtable">
<tr>
<th>Rule + Zone </th><th><code>zone_type</code> </th><th>State <code>id</code> </th><th><code>type</code> </th><th><code>yield_to</code> </th></tr>
<tr>
<td>"North" </td><td>*StopExcluded* </td><td>"static" </td><td>*Go* </td><td>&mdash; </td></tr>
</table>
<p>The <code>State::Id</code> chosen here ("static") is arbitrary.</p>
<p>The zone is a <code>LaneSRoute</code> spanning from the southern edge of the crosswalk to the northern edge, with zone-type <em>StopExcluded</em>, which means that stopping within the zone is not allowed. The single state has type <em>Go</em>, which means that vehicles have the right-of-way to proceed. (Note that "when it is safe to do so" is always implied with any rule.) Furthermore, that single state has an empty <code>yield_to</code> list, which means no intersecting paths have priority over this one. (In fact, there are no intersecting paths.)</p>
<p>This is a pretty trivial rule, since it has a single state which is always "Go". However, it serves to capture the requirement that when a vehicle <em>does</em> stop, it should avoid stopping in the crosswalk.</p>
<p>Note that a more complete scenario, which actually modeled pedestrian traffic, would likely represent the crosswalk as a lane of its own (intersecting the vehicular lane) and the "North" rule would specify yielding to that crosswalk lane via the <code>yield_to</code> element.</p>
<p><em>Example: One-way Side Street onto Two-Lane Artery</em></p>
<p><a class="anchor" id="RoWR-one-way-to-two-way"></a></p><div class="image">
<object type="image/svg+xml" data="right-of-way-example-one-way-side-street.svg">right-of-way-example-one-way-side-street.svg</object>
<div class="caption">
Intersection with one-way side street onto two-lane</div></div>
<p> artery."</p>
<p><a class="el" href="maliput_design.html#RoWR-one-way-to-two-way">Figure</a> is a scenario with an intersection:</p>
<ul>
<li>East-west traffic is two way and uncontrolled.</li>
<li>Northbound traffic is controlled by a stop sign.</li>
<li>There are four zones (paths) traversing the intersection (illustrated by the four arrows).</li>
</ul>
<p>With four zones and no changing signals, four static rules are required. The rules have been labeled by a combination of the initial heading and the turn direction of their paths. (E.g., "NB/Left" refers to "the northbound path that turns left".) All the zones are of the <em>StopExcluded</em> type, so that detail has been omitted from the rule table:</p>
<table class="doxtable">
<tr>
<th>Rule + Zone </th><th>State <code>id</code> </th><th><code>type</code> </th><th><code>yield_to</code> </th></tr>
<tr>
<td>"EB/Straight" </td><td>"static" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<td>"WB/Straight" </td><td>"static" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<td>"NB/Right" </td><td>"static" </td><td>*StopThenGo* </td><td>"EB/Straight" </td></tr>
<tr>
<td>"NB/Left" </td><td>"static" </td><td>*StopThenGo* </td><td>"EB/Straight", "WB/Straight" </td></tr>
</table>
<p>The <code>State::Id</code>'s chosen here ("static") are arbitrary.</p>
<p>As in the earlier Pedestrian Crosswalk example, the static <em>Go</em> rules of the eastbound and westbound paths show that they always have the right-of-way, but vehicles are still required to avoid stopping in the intersection. Traffic turning right onto the artery (following the "NB/Right" path) must stop at the stop sign, and then yield to any eastbound traffic. Traffic turning left onto the artery must stop and then yield to both eastbound and westbound traffic.</p>
<p><em>Example: Protected/Permitted Left Turn</em></p>
<p><a class="anchor" id="RoWR-protected-left"></a></p><div class="image">
<object type="image/svg+xml" data="right-of-way-example-protected-left.svg">right-of-way-example-protected-left.svg</object>
<div class="caption">
Intersection with protected/permitted left turn.</div></div>
<p> <a class="el" href="maliput_design.html#RoWR-protected-left">Figure</a> provides a more complex scenario with a dynamic signal-controlled intersection:</p><ul>
<li>The north-south street is one-way, northbound only.</li>
<li>East-west traffic is two-way, with a dedicated left-turn lane for eastbound traffic turning north.</li>
<li>"Right Turn on Red" is allowed (which affects both northbound and westbound vehicles).</li>
<li>In the signaling cycle, eastbound traffic has both a protected-left (green arrow) phase and a permitted-left (flashing yellow arrow) phase.</li>
<li>There are a total of seven zones (paths) traversing the intersection (illustrated by the seven arrows).</li>
</ul>
<p>With seven zones, seven rule instances are required. The rules have been labeled by a combination of the initial heading and the turn direction of their paths. (E.g., "NB/Left" refers to "the northbound
path that turns left".) All the zones are of the /StopExcluded/ type, so that detail has been omitted from the rule table:</p>
<table class="doxtable">
<tr>
<th>Rule + Zone </th><th>State <code>id</code> </th><th><code>type</code> </th><th><code>yield_to</code> </th></tr>
<tr>
<td rowspan="2">"NB/Right" </td><td>"Red" </td><td>*StopThenGo* </td><td>"EB/Straight" </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td rowspan="2">"NB/Straight" </td><td>"Red" </td><td>*Stop* </td><td>&mdash; </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td rowspan="2">"NB/Left" </td><td>"Red" </td><td>*Stop* </td><td>&mdash; </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td rowspan="2">"EB/Straight" </td><td>"Red" </td><td>*Stop* </td><td>&mdash; </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td rowspan="3">"EB/Left" </td><td>"Red" </td><td>*Stop* </td><td>&mdash; </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<td>"FlashingYellow"</td><td>*Go* </td><td>"WB/Straight", "WB/Right" </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td rowspan="2">"WB/Right" </td><td>"Red" </td><td>*StopThenGo* </td><td>"NB/Straight", "EB/Left" </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td rowspan="2">"WB/Straight" </td><td>"Red" </td><td>*Stop* </td><td>&mdash; </td></tr>
<tr>
<td>"Green" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<th></th><th></th><th></th><th></th></tr>
</table>
<p>The <code>State::Id</code>'s have been chosen to loosely match the states of the corresponding traffic signals. (Note that typically a "yellow light" confers the same right-of-way as a "green light"; the only difference is that the yellow indicates that a transition to red is imminent.)</p>
<p>Each rule has at least two states. The straight-ahead rules ( <code>*</code>/Straight ) and the northbound left-turning rule ( NB/Left ) are quite straightforward: either "Stop" with no right-of-way or "Go" with full right-of-way. The other turning rules are a bit more interesting.</p>
<p>Since "Right Turn on Red" is allowed, both the "NB/Right" and "WB/Right" rules have <em>StopThenGo</em> states (instead of <em>Stop</em> states) that must yield to other traffic. "NB/Right" must yield to eastbound traffic, and "WB/Right" must yield to northbound traffic.</p>
<p>The "EB/Left" rule has two <em>Go</em> states. One is the protected turn state, in which the left turn is given full priority over oncoming westbound traffic. The other is the permitted turn state, in which the left turn must yield to westbound traffic. In the US, a possible traffic light configuration for such an intersection would signal the protected turn by a solid green arrow, and the permitted turn by a flashing yellow arrow.</p>
<p><em>Example: Freeway Merge</em></p>
<p><a class="anchor" id="RoWR-freeway-merge"></a></p><div class="image">
<object type="image/svg+xml" data="right-of-way-example-freeway-merge.svg">right-of-way-example-freeway-merge.svg</object>
<div class="caption">
Entrance ramp merging onto a 2-lane (one-way) freeway.</div></div>
<p> <a class="el" href="maliput_design.html#RoWR-freeway-merge">Figure</a> is a scenario with a freeway merge:</p><ul>
<li>Freeway has two lanes of eastbound traffic.</li>
<li>Entrance ramp merges onto the freeway from the right (south).</li>
<li>Merging traffic must yield to traffic already on the freeway.</li>
<li>Two zones traverse the area where the merge occurs (illustrated by the two arrows).</li>
</ul>
<p>This is a static scenario with two static rules:</p>
<table class="doxtable">
<tr>
<th>Rule + Zone </th><th><code>zone_type</code> </th><th>State <code>id</code> </th><th><code>type</code> </th><th><code>yield_to</code> </th></tr>
<tr>
<td>"Freeway" </td><td><code>StopAllowed</code> </td><td>"static" </td><td>*Go* </td><td>&mdash; </td></tr>
<tr>
<td>"Entrance" </td><td><code>StopAllowed</code> </td><td>"static" </td><td>*Go* </td><td>"Freeway" </td></tr>
</table>
<p>The <code>State::Id</code>'s chosen here ("static") are arbitrary.</p>
<p>The only constraint encoded by these two rules is that the "Entrance" traffic should yield to the "Freeway" traffic. Note that unlike previous examples, both zones in this scenario have a zone-type of <code>StopAllowed</code>. That means there are no "stop lines" (real or implicit) and no exclusion zones that are expected to be left unblocked by stopped traffic. Both rules' static states are of type <em>Go</em>, as well; neither path is expected to stop. Ideally, the entrance traffic never stops, but instead speeds up to seamlessly merge into the freeway flow.</p>
<blockquote class="doxtable">
<p>TODO <code>DirectionUsageRule</code>: </p>
</blockquote>
<p><code>DirectionUsageRule</code>: Direction Usage</p>
<p><em>Captures allowed direction-of-travel.</em></p>
<ul>
<li>id</li>
<li>zone (<code>LaneSRange</code>)</li>
<li>allowed use:<ul>
<li><em>bidirectional</em> (e.g., non-striped single-lane residential street)</li>
<li><em>unidirectional, s increasing</em></li>
<li><em>unidirectional, s decreasing</em></li>
<li><em>bidirectional, turning-only</em></li>
<li><em>no-traffic</em> (e.g., median strip)</li>
<li><em>parking-lane</em></li>
</ul>
</li>
<li>time-of-day/calendar condition?</li>
</ul>
<blockquote class="doxtable">
<p>TODO <code>LaneChangeRule</code>: Lane-change/Passing Restrictions </p>
</blockquote>
<p><code>LaneChangeRule</code>: Lane-change/Passing Restrictions</p>
<p><em>Captures restrictions on lateral/adjacent lane transitions.</em></p><ul>
<li>id</li>
<li>zone (<code>LaneSRange</code>)</li>
<li>applicable direction<ul>
<li>to-left</li>
<li>to-right</li>
</ul>
</li>
<li>constraint<ul>
<li>allowed</li>
<li>forbidden</li>
<li><em>discouraged?</em> (e.g., to capture solid white lines separating turn lanes from through traffic)</li>
</ul>
</li>
<li><em>Should this capture "passing vs lane-change" purpose, too, (e.g., the white-vs-yellow distinction) or should that just be implied by <code>DirectionUsageRule</code>?</em></li>
<li>time-of-day/calendar condition?</li>
</ul>
<blockquote class="doxtable">
<p>TODO <code>OngoingRouteRule</code>: "Turning" Restrictions </p>
</blockquote>
<p><code>OngoingRouteRule</code>: "Turning" Restrictions</p>
<p><em>Captures restrictions on longitudinal/end-to-end lane transitions.</em></p><ul>
<li>id</li>
<li>applicable originating <code>LaneIdEnd</code></li>
<li>ongoing <code>LaneIdEnd</code></li>
<li>restricted vehicle type<ul>
<li>(not) any</li>
<li>(not) bus</li>
<li>(not) truck</li>
<li>...</li>
</ul>
</li>
<li>time-of-day/calendar condition?</li>
<li>*(Or, maybe this concept is better represented by vehicle restrictions on the ongoing lane instead.)*</li>
</ul>
<blockquote class="doxtable">
<p>TODO <code>PreferentialUseRule</code>: Vehicle Restrictions </p>
</blockquote>
<p><code>PreferentialUseRule</code>: Vehicle Restrictions</p>
<p><em>Captures vehicle-type traffic restrictions.</em></p><ul>
<li>id</li>
<li>zone (<code>LaneSRange</code>)</li>
<li>vehicle type<ul>
<li>high-occupancy vehicles (HOV) only</li>
<li>no trucks</li>
<li>bus only</li>
<li>emergency vehicles only</li>
<li>etc</li>
</ul>
</li>
<li>time-of-day/calendar condition?</li>
<li><em>Should this should be merged with <code>DirectionUsageRule</code>, because lane usage/direction might be specified per vehicle type?</em></li>
</ul>
<blockquote class="doxtable">
<p>TODO Furniture and Physical Features </p>
</blockquote>
<p>Furniture and Physical Features</p>
<p><em>Provide a database of physical features with spatial location and extent.</em></p>
<p>In many cases these are related to rules in the <code>RoadRulebook</code> (e.g., signs and stripes are indicators for rules of the road).</p><ul>
<li>linear features<ul>
<li>striping</li>
</ul>
</li>
<li>areal features<ul>
<li>crosswalks</li>
<li>restricted medians</li>
<li>do-not-block zones</li>
</ul>
</li>
<li>signage<ul>
<li>stop lights, stop signs</li>
<li>turn restrictions</li>
</ul>
</li>
<li>other (volumetric) furniture<ul>
<li>benches</li>
<li>mailboxes</li>
<li>traffic cones</li>
<li>refrigerator that fell off a truck</li>
</ul>
</li>
<li>potholes </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

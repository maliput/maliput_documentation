<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput: maliput Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemaliput.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">maliput Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code in this file is inspired by: <a href="https://github.com/RobotLocomotion/drake/blob/master/common/text_logging.h">https://github.com/RobotLocomotion/drake/blob/master/common/text_logging.h</a>. </p>
<p>Maliput uses the hash_append pattern as described by N3980.</p>
<p>Drake's license follows:</p>
<p>All components of Drake are licensed under the BSD 3-Clause License shown below. Where noted in the source code, some portions may be subject to other permissive, non-viral licenses.</p>
<p>Copyright 2012-2016 Robot Locomotion Group @ CSAIL All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Massachusetts Institute of Technology nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>For a full treatment of the hash_append pattern, refer to: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html</a></p>
<h3>Providing hash_append support within a class</h3>
<p>Maliput types may implement a <code>hash_append</code> function. The function appends every hash-relevant member field into the hasher: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyValue {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  ...<span class="comment"></span></div>
<div class="line"><span class="comment">  /// Implements the @ref hash_append concept.</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HashAlgorithm&gt;</div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespacemaliput_1_1common.html#a44240da1e534b4f1ad217fd60715fefe">hash_append</a>(</div>
<div class="line">      HashAlgorithm&amp; hasher, <span class="keyword">const</span> MyValue&amp; item) noexcept {</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacemaliput_1_1common.html#a44240da1e534b4f1ad217fd60715fefe">maliput::common::hash_append</a>;</div>
<div class="line">    <a class="code" href="namespacemaliput_1_1common.html#a44240da1e534b4f1ad217fd60715fefe">hash_append</a>(hasher, item.my_data_);</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  std::string my_data_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Checklist for reviewing a <code>hash_append</code> implementation:</p>
<ul>
<li>The function cites <code>@ref hash_append</code> in its Doxygen comment.</li>
<li>The function is marked <code>noexcept</code>.</li>
</ul>
<h3>Using hashable types</h3>
<p>Types that implement this pattern may be used in unordered collections: </p><div class="fragment"><div class="line">std::unordered_set&lt;MyValue, maliput::common::DefaultHash&gt; foo;</div>
</div><!-- fragment --><p>Some Maliput types may also choose to specialize <code>std::hash&lt;MyValue&gt;</code> to use <code>DefaultHash</code>, so that the second template argument to <code>std::unordered_set</code> can be omitted. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemaliput_1_1api"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1api.html">api</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1common"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1common.html">common</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1geometry__base"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1geometry__base.html">geometry_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespacemaliput_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace to group basic mathematical and geometric support to <code>maliput</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1plugin"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1plugin.html">plugin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1routing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1routing.html">routing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1utility"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility.html">utility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1_discrete_value_rule_constants.html">DiscreteValueRuleConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to identify attributes of <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html" title="Describes a discrete value rule.">api::rules::DiscreteValueRule</a> Types.  <a href="structmaliput_1_1_discrete_value_rule_constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_intersection.html">Intersection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1_intersection.html" title="An abstract convenience class that aggregates information pertaining to an intersection.">api::Intersection</a> abstract interface.  <a href="classmaliput_1_1_intersection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_intersection_book.html">IntersectionBook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> abstract interface.  <a href="classmaliput_1_1_intersection_book.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_manual_discrete_value_rule_state_provider.html">ManualDiscreteValueRuleStateProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a manual <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule_state_provider.html" title="Abstract interface for the state provider of DiscreteValueRules.">api::rules::DiscreteValueRuleStateProvider</a>.  <a href="classmaliput_1_1_manual_discrete_value_rule_state_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_manual_phase_provider.html">ManualPhaseProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_provider.html" title="Abstract interface for providing the dynamic states (Phase::Id) of a collection of PhaseRings.">api::rules::PhaseProvider</a> abstract interface that allows the current phase to be manually set.  <a href="classmaliput_1_1_manual_phase_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_manual_phase_ring_book.html">ManualPhaseRingBook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> abstract interface that enables manual addition and removal of <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring.html" title="A set of mutually exclusive phases, e.g., that comprise the signaling cycle for an intersection.">api::rules::PhaseRing</a> instances.  <a href="classmaliput_1_1_manual_phase_ring_book.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_manual_range_value_rule_state_provider.html">ManualRangeValueRuleStateProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a manual <a class="el" href="classmaliput_1_1api_1_1rules_1_1_range_value_rule_state_provider.html" title="Abstract interface for the state provider of RangeValueRules.">api::rules::RangeValueRuleStateProvider</a>.  <a href="classmaliput_1_1_manual_range_value_rule_state_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_manual_rulebook.html">ManualRulebook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmaliput_1_1_manual_rulebook.html" title="ManualRulebook is a simple concrete implementation of the api::rules::RoadRulebook abstract interface...">ManualRulebook</a> is a simple concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> abstract interface.  <a href="classmaliput_1_1_manual_rulebook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_phase_based_right_of_way_discrete_value_rule_state_provider.html">PhaseBasedRightOfWayDiscreteValueRuleStateProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the state of Right-Of-Way <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html" title="Describes a discrete value rule.">api::rules::DiscreteValueRule</a> instances based on the current <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase.html" title="A group of RightOfWayRule instances and their states.">api::rules::Phase</a>.  <a href="classmaliput_1_1_phase_based_right_of_way_discrete_value_rule_state_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1_range_value_rule_constants.html">RangeValueRuleConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to identify attributes of <a class="el" href="classmaliput_1_1api_1_1rules_1_1_range_value_rule.html" title="Describes a numeric range based rule.">api::rules::RangeValueRule</a> Types.  <a href="structmaliput_1_1_range_value_rule_constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1_related_rules_keys.html">RelatedRulesKeys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines keys used in <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#ad20a20f4cf3ad282b0f5ea0a716896ed" title="Alias of a map holding groups of related rules.">api::rules::Rule::RelatedRules</a>.  <a href="structmaliput_1_1_related_rules_keys.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1_related_unique_ids_keys.html">RelatedUniqueIdsKeys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines keys used in <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#aae244f337e8af36a083d06ab2de5d250" title="Alias of a map holding groups of related unique ids.">api::rules::Rule::RelatedUniqueIds</a>.  <a href="structmaliput_1_1_related_unique_ids_keys.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1_rule_constants.html">RuleConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to identify attributes used in both api::rules::DiscreteValueRules and api::rules::RangeValueRules Types.  <a href="structmaliput_1_1_rule_constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1_rule_type_filter.html">RuleTypeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to filter by <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">api::rules::Rule::TypeId</a>.  <a href="structmaliput_1_1_rule_type_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_simple_phase_ring_book.html">SimplePhaseRingBook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> abstract interface.  <a href="classmaliput_1_1_simple_phase_ring_book.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_simple_rulebook.html">SimpleRulebook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmaliput_1_1_simple_rulebook.html" title="SimpleRulebook is a simple concrete implementation of the api::rules::RoadRulebook abstract interface...">SimpleRulebook</a> is a simple concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> abstract interface.  <a href="classmaliput_1_1_simple_rulebook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete implementation of the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> abstract interface.  <a href="classmaliput_1_1_traffic_light_book.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af47f9bba35c4e7f194275267573a1faa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#af47f9bba35c4e7f194275267573a1faa">DiscreteValueRuleFilter</a> = std::function&lt; bool(const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html">api::rules::DiscreteValueRule</a> &amp;)&gt;</td></tr>
<tr class="memdesc:af47f9bba35c4e7f194275267573a1faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient alias of a functor to filter api::rules::DiscreteValueRules based on arbitrary criteria from a api::rules::RoadRulebook::QueryResult.  <a href="namespacemaliput.html#af47f9bba35c4e7f194275267573a1faa">More...</a><br /></td></tr>
<tr class="separator:af47f9bba35c4e7f194275267573a1faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab010f6124960691793181deddb8302e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ab010f6124960691793181deddb8302e3">RangeValueRuleFilter</a> = std::function&lt; bool(const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_range_value_rule.html">api::rules::RangeValueRule</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ab010f6124960691793181deddb8302e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient alias of a functor to filter <a class="el" href="classmaliput_1_1api_1_1rules_1_1_range_value_rule.html" title="Describes a numeric range based rule.">api::rules::RangeValueRule</a> based on arbitrary criteria from a api::rules::RoadRulebook::QueryResult.  <a href="namespacemaliput.html#ab010f6124960691793181deddb8302e3">More...</a><br /></td></tr>
<tr class="separator:ab010f6124960691793181deddb8302e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa6b098ad1261c86b7a71c1cb1a558b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a3fa6b098ad1261c86b7a71c1cb1a558b">QueryResults</a> = <a class="el" href="structmaliput_1_1api_1_1rules_1_1_road_rulebook_1_1_query_results.html">api::rules::RoadRulebook::QueryResults</a></td></tr>
<tr class="separator:a3fa6b098ad1261c86b7a71c1cb1a558b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0da2be5e4963c00e7d90bea0c5d6e299"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a0da2be5e4963c00e7d90bea0c5d6e299">RuleType</a> { <a class="el" href="namespacemaliput.html#a0da2be5e4963c00e7d90bea0c5d6e299aff95300802b888f287a7cce6fb26e6de">kDiscreteValueRuleType</a>, 
<a class="el" href="namespacemaliput.html#a0da2be5e4963c00e7d90bea0c5d6e299aa21f41aa0071e057d4063688cde149cd">kRangeValueRuleType</a>, 
<a class="el" href="namespacemaliput.html#a0da2be5e4963c00e7d90bea0c5d6e299acb176da2fcabc07c07cc1a211231a3f1">kUnknownRuleType</a>
 }</td></tr>
<tr class="memdesc:a0da2be5e4963c00e7d90bea0c5d6e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label to identify rule type.  <a href="namespacemaliput.html#a0da2be5e4963c00e7d90bea0c5d6e299">More...</a><br /></td></tr>
<tr class="separator:a0da2be5e4963c00e7d90bea0c5d6e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4e6d552753de675620983cc700fdb774"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html">api::IntersectionBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a4e6d552753de675620983cc700fdb774">LoadIntersectionBook</a> (const std::string &amp;input, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &amp;road_rulebook, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &amp;phase_ring_book, <a class="el" href="classmaliput_1_1_manual_phase_provider.html">ManualPhaseProvider</a> *phase_provider)</td></tr>
<tr class="memdesc:a4e6d552753de675620983cc700fdb774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> instance based on the specified <code>input</code> document.  <a href="namespacemaliput.html#a4e6d552753de675620983cc700fdb774">More...</a><br /></td></tr>
<tr class="separator:a4e6d552753de675620983cc700fdb774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad592986cb5030b6febfdb15f825b152e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html">api::IntersectionBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ad592986cb5030b6febfdb15f825b152e">LoadIntersectionBookFromFile</a> (const std::string &amp;filename, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &amp;road_rulebook, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &amp;phase_ring_book, <a class="el" href="classmaliput_1_1_manual_phase_provider.html">ManualPhaseProvider</a> *phase_provider)</td></tr>
<tr class="memdesc:ad592986cb5030b6febfdb15f825b152e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> instance based on the specified <code>filename</code>.  <a href="namespacemaliput.html#ad592986cb5030b6febfdb15f825b152e">More...</a><br /></td></tr>
<tr class="separator:ad592986cb5030b6febfdb15f825b152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eff4450bcc4e11f38442441cdb5195"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a71eff4450bcc4e11f38442441cdb5195">LoadPhaseRingBookOldRules</a> (const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *rulebook, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *traffic_light_book, const std::string &amp;input)</td></tr>
<tr class="memdesc:a71eff4450bcc4e11f38442441cdb5195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>input</code> <a class="el" href="namespace_y_a_m_l.html">YAML</a> string.  <a href="namespacemaliput.html#a71eff4450bcc4e11f38442441cdb5195">More...</a><br /></td></tr>
<tr class="separator:a71eff4450bcc4e11f38442441cdb5195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179c8e2243d2f113a0574efc1f57758e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a179c8e2243d2f113a0574efc1f57758e">LoadPhaseRingBookFromFileOldRules</a> (const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *rulebook, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *traffic_light_book, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a179c8e2243d2f113a0574efc1f57758e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>filename</code>.  <a href="namespacemaliput.html#a179c8e2243d2f113a0574efc1f57758e">More...</a><br /></td></tr>
<tr class="separator:a179c8e2243d2f113a0574efc1f57758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16da6294622c366500107beede513985"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a16da6294622c366500107beede513985">LoadPhaseRingBook</a> (const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *rulebook, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *traffic_light_book, const std::string &amp;input)</td></tr>
<tr class="memdesc:a16da6294622c366500107beede513985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>input</code> document.  <a href="namespacemaliput.html#a16da6294622c366500107beede513985">More...</a><br /></td></tr>
<tr class="separator:a16da6294622c366500107beede513985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94a8bdc4b38fcc4d05e6637903f0f56"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#aa94a8bdc4b38fcc4d05e6637903f0f56">LoadPhaseRingBookFromFile</a> (const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *rulebook, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *traffic_light_book, const std::string &amp;filename)</td></tr>
<tr class="memdesc:aa94a8bdc4b38fcc4d05e6637903f0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>filename</code>.  <a href="namespacemaliput.html#aa94a8bdc4b38fcc4d05e6637903f0f56">More...</a><br /></td></tr>
<tr class="separator:aa94a8bdc4b38fcc4d05e6637903f0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87bad07e3c579517a7e486544448e59"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ae87bad07e3c579517a7e486544448e59">LoadRoadRulebook</a> (const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *road_geometry, const std::string &amp;input)</td></tr>
<tr class="memdesc:ae87bad07e3c579517a7e486544448e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code> and <code>input</code>.  <a href="namespacemaliput.html#ae87bad07e3c579517a7e486544448e59">More...</a><br /></td></tr>
<tr class="separator:ae87bad07e3c579517a7e486544448e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8bb612786d298f2f4eb0ea5a010caf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#aae8bb612786d298f2f4eb0ea5a010caf">LoadRoadRulebookFromFile</a> (const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *road_geometry, const std::string &amp;filename)</td></tr>
<tr class="memdesc:aae8bb612786d298f2f4eb0ea5a010caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code> and <code>filename</code>.  <a href="namespacemaliput.html#aae8bb612786d298f2f4eb0ea5a010caf">More...</a><br /></td></tr>
<tr class="separator:aae8bb612786d298f2f4eb0ea5a010caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a2036f65730d912b68767e489d36f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a86a2036f65730d912b68767e489d36f4">LoadRoadRulebook</a> (const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *road_geometry, const std::string &amp;input, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &amp;rule_registry)</td></tr>
<tr class="memdesc:a86a2036f65730d912b68767e489d36f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code>, <code>input</code> and <code>rule_registry</code>.  <a href="namespacemaliput.html#a86a2036f65730d912b68767e489d36f4">More...</a><br /></td></tr>
<tr class="separator:a86a2036f65730d912b68767e489d36f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accce2c90d0627fa85c6b11c9924c0609"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#accce2c90d0627fa85c6b11c9924c0609">LoadRoadRulebookFromFile</a> (const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *road_geometry, const std::string &amp;filename, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &amp;rule_registry)</td></tr>
<tr class="memdesc:accce2c90d0627fa85c6b11c9924c0609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code>, <code>filename</code> and <code>rule_registry</code>.  <a href="namespacemaliput.html#accce2c90d0627fa85c6b11c9924c0609">More...</a><br /></td></tr>
<tr class="separator:accce2c90d0627fa85c6b11c9924c0609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fcf00cfd61b5f2c309a471f8973340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaliput_1_1api_1_1rules_1_1_road_rulebook_1_1_query_results.html">api::rules::RoadRulebook::QueryResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ab6fcf00cfd61b5f2c309a471f8973340">FilterRules</a> (const <a class="el" href="structmaliput_1_1api_1_1rules_1_1_road_rulebook_1_1_query_results.html">api::rules::RoadRulebook::QueryResults</a> &amp;rules, const std::vector&lt; <a class="el" href="namespacemaliput.html#af47f9bba35c4e7f194275267573a1faa">DiscreteValueRuleFilter</a> &gt; &amp;discrete_value_rules_filters, const std::vector&lt; <a class="el" href="namespacemaliput.html#ab010f6124960691793181deddb8302e3">RangeValueRuleFilter</a> &gt; &amp;range_value_rules_filters)</td></tr>
<tr class="memdesc:ab6fcf00cfd61b5f2c309a471f8973340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>rules</code> after the application of <code>discrete_value_rules_filters</code> and <code>range_value_rules_filters</code>.  <a href="namespacemaliput.html#ab6fcf00cfd61b5f2c309a471f8973340">More...</a><br /></td></tr>
<tr class="separator:ab6fcf00cfd61b5f2c309a471f8973340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59970e4acc510adc08b7d1b925c79428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a59970e4acc510adc08b7d1b925c79428">DirectionUsageRuleTypeId</a> ()</td></tr>
<tr class="memdesc:a59970e4acc510adc08b7d1b925c79428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> whose string representation is "Direction-Usage Rule Type".  <a href="namespacemaliput.html#a59970e4acc510adc08b7d1b925c79428">More...</a><br /></td></tr>
<tr class="separator:a59970e4acc510adc08b7d1b925c79428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f6afe21f74c97a61caa392f3d99085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1api_1_1rules.html#a2243c6424f27aa59e29bec1413f2d962">api::rules::DiscreteValueRuleTypeAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a88f6afe21f74c97a61caa392f3d99085">BuildDirectionUsageRuleType</a> ()</td></tr>
<tr class="memdesc:a88f6afe21f74c97a61caa392f3d99085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direction usage rule type and its possible discrete values.  <a href="namespacemaliput.html#a88f6afe21f74c97a61caa392f3d99085">More...</a><br /></td></tr>
<tr class="separator:a88f6afe21f74c97a61caa392f3d99085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b426289adb8580f95431a088dca4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ac32b426289adb8580f95431a088dca4a">RightOfWayRuleTypeId</a> ()</td></tr>
<tr class="memdesc:ac32b426289adb8580f95431a088dca4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> whose string representation is "Right-Of-Way Rule Type".  <a href="namespacemaliput.html#ac32b426289adb8580f95431a088dca4a">More...</a><br /></td></tr>
<tr class="separator:ac32b426289adb8580f95431a088dca4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae129ca7ec98c04f107c8ca5642a18805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1api_1_1rules.html#a2243c6424f27aa59e29bec1413f2d962">api::rules::DiscreteValueRuleTypeAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ae129ca7ec98c04f107c8ca5642a18805">BuildRightOfWayRuleType</a> ()</td></tr>
<tr class="memdesc:ae129ca7ec98c04f107c8ca5642a18805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right-of-way rule type and its possible discrete values.  <a href="namespacemaliput.html#ae129ca7ec98c04f107c8ca5642a18805">More...</a><br /></td></tr>
<tr class="separator:ae129ca7ec98c04f107c8ca5642a18805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7b13115e7582b310a1425d0c3a5a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ade7b13115e7582b310a1425d0c3a5a29">VehicleStopInZoneBehaviorRuleTypeId</a> ()</td></tr>
<tr class="memdesc:ade7b13115e7582b310a1425d0c3a5a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> whose string representation is "Vehicle-Stop-In-Zone-Behavior Rule Type".  <a href="namespacemaliput.html#ade7b13115e7582b310a1425d0c3a5a29">More...</a><br /></td></tr>
<tr class="separator:ade7b13115e7582b310a1425d0c3a5a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7764364f52a7f06d32340e697d2fd894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1api_1_1rules.html#a2243c6424f27aa59e29bec1413f2d962">api::rules::DiscreteValueRuleTypeAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a7764364f52a7f06d32340e697d2fd894">BuildVehicleStopInZoneBehaviorRuleType</a> ()</td></tr>
<tr class="memdesc:a7764364f52a7f06d32340e697d2fd894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vehicle stop in zone behavior rule type and its possible discrete values.  <a href="namespacemaliput.html#a7764364f52a7f06d32340e697d2fd894">More...</a><br /></td></tr>
<tr class="separator:a7764364f52a7f06d32340e697d2fd894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fedaec7dc89f069552385eeaf1bddee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a3fedaec7dc89f069552385eeaf1bddee">SpeedLimitRuleTypeId</a> ()</td></tr>
<tr class="memdesc:a3fedaec7dc89f069552385eeaf1bddee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">maliput::api::rules::Rule::TypeId</a> initialized with "Speed-Limit Rule Type".  <a href="namespacemaliput.html#a3fedaec7dc89f069552385eeaf1bddee">More...</a><br /></td></tr>
<tr class="separator:a3fedaec7dc89f069552385eeaf1bddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8578b49883025263c70cb77aea11af3e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a8578b49883025263c70cb77aea11af3e">LoadRuleRegistry</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a8578b49883025263c70cb77aea11af3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> based on the specified <code>input</code>.  <a href="namespacemaliput.html#a8578b49883025263c70cb77aea11af3e">More...</a><br /></td></tr>
<tr class="separator:a8578b49883025263c70cb77aea11af3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c4c176854c7d60524ec666c03f3ff4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a03c4c176854c7d60524ec666c03f3ff4">LoadRuleRegistryFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a03c4c176854c7d60524ec666c03f3ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> based on the specified <code>filename</code>.  <a href="namespacemaliput.html#a03c4c176854c7d60524ec666c03f3ff4">More...</a><br /></td></tr>
<tr class="separator:a03c4c176854c7d60524ec666c03f3ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b23877bdff76d8134d4ae47c0e6001"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a5358e3b05db56d19875bb15f02523f2f">maliput::api::rules::Rule::Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a98b23877bdff76d8134d4ae47c0e6001">GetYieldGroup</a> (const <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html">maliput::api::rules::DiscreteValueRule::DiscreteValue</a> &amp;discrete_value)</td></tr>
<tr class="memdesc:a98b23877bdff76d8134d4ae47c0e6001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of Rule::Ids that represents the yield group of a Right-Of-Way rule state.  <a href="namespacemaliput.html#a98b23877bdff76d8134d4ae47c0e6001">More...</a><br /></td></tr>
<tr class="separator:a98b23877bdff76d8134d4ae47c0e6001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717bbe98643e0f44b2f22588f3876a9d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a5358e3b05db56d19875bb15f02523f2f">maliput::api::rules::Rule::Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a717bbe98643e0f44b2f22588f3876a9d">GetCurrentYieldGroup</a> (const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html">maliput::api::rules::DiscreteValueRule</a> &amp;discrete_value_rule, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule_state_provider.html">maliput::api::rules::DiscreteValueRuleStateProvider</a> *state_provider)</td></tr>
<tr class="memdesc:a717bbe98643e0f44b2f22588f3876a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current yield group of <code>discrete_value_rule</code>.  <a href="namespacemaliput.html#a717bbe98643e0f44b2f22588f3876a9d">More...</a><br /></td></tr>
<tr class="separator:a717bbe98643e0f44b2f22588f3876a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a222c0c4ca44dbc09aa5b9bfa7c63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1_unique_id.html">maliput::api::UniqueId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ace5a222c0c4ca44dbc09aa5b9bfa7c63">GetBulbGroup</a> (const <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html">maliput::api::rules::DiscreteValueRule::DiscreteValue</a> &amp;discrete_value)</td></tr>
<tr class="memdesc:ace5a222c0c4ca44dbc09aa5b9bfa7c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of maliput::api::UniqueIds that represents the bulb group of a Right-Of-Way rule state.  <a href="namespacemaliput.html#ace5a222c0c4ca44dbc09aa5b9bfa7c63">More...</a><br /></td></tr>
<tr class="separator:ace5a222c0c4ca44dbc09aa5b9bfa7c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07de48c35e49e183caf5ad6580b4d0d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1_unique_id.html">maliput::api::UniqueId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a07de48c35e49e183caf5ad6580b4d0d5">GetCurrentBulbGroup</a> (const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html">maliput::api::rules::DiscreteValueRule</a> &amp;discrete_value_rule, const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule_state_provider.html">maliput::api::rules::DiscreteValueRuleStateProvider</a> *state_provider)</td></tr>
<tr class="memdesc:a07de48c35e49e183caf5ad6580b4d0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current bulb group of <code>discrete_value_rule</code>.  <a href="namespacemaliput.html#a07de48c35e49e183caf5ad6580b4d0d5">More...</a><br /></td></tr>
<tr class="separator:a07de48c35e49e183caf5ad6580b4d0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673381fed4e6e5b62a3ffc77f3f9bae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a3673381fed4e6e5b62a3ffc77f3f9bae">LoadTrafficLightBook</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a3673381fed4e6e5b62a3ffc77f3f9bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> instance based on the specified <code>input</code> document.  <a href="namespacemaliput.html#a3673381fed4e6e5b62a3ffc77f3f9bae">More...</a><br /></td></tr>
<tr class="separator:a3673381fed4e6e5b62a3ffc77f3f9bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748a7535cbc24118299c3bcbef33a20d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a748a7535cbc24118299c3bcbef33a20d">LoadTrafficLightBookFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a748a7535cbc24118299c3bcbef33a20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> instance based on the specified <code>filename</code>.  <a href="namespacemaliput.html#a748a7535cbc24118299c3bcbef33a20d">More...</a><br /></td></tr>
<tr class="separator:a748a7535cbc24118299c3bcbef33a20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9fde3287ad8867f768d2f3c05cdf0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a1e9fde3287ad8867f768d2f3c05cdf0a">IsDiscreteValue</a> (const YAML::Node &amp;rule_node)</td></tr>
<tr class="memdesc:a1e9fde3287ad8867f768d2f3c05cdf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code>rule_node</code> corresponds to a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a> description.  <a href="namespacemaliput.html#a1e9fde3287ad8867f768d2f3c05cdf0a">More...</a><br /></td></tr>
<tr class="separator:a1e9fde3287ad8867f768d2f3c05cdf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939fda7aa16deb30b6226ffea2396632"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a939fda7aa16deb30b6226ffea2396632">IsRangeValue</a> (const YAML::Node &amp;rule_node)</td></tr>
<tr class="memdesc:a939fda7aa16deb30b6226ffea2396632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code>rule_node</code> corresponds to a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a> description.  <a href="namespacemaliput.html#a939fda7aa16deb30b6226ffea2396632">More...</a><br /></td></tr>
<tr class="separator:a939fda7aa16deb30b6226ffea2396632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40338e73891cfbcf9072e153710dd68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#af40338e73891cfbcf9072e153710dd68">GetSeverityFromYamlNode</a> (const YAML::Node &amp;node)</td></tr>
<tr class="memdesc:af40338e73891cfbcf9072e153710dd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the severity field value from the <code>node</code>.  <a href="namespacemaliput.html#af40338e73891cfbcf9072e153710dd68">More...</a><br /></td></tr>
<tr class="separator:af40338e73891cfbcf9072e153710dd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733eb44f957c784b58ea15b0cb54687e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a733eb44f957c784b58ea15b0cb54687e">GetRangeMinMaxValuesFromYamlNode</a> (const YAML::Node &amp;node)</td></tr>
<tr class="memdesc:a733eb44f957c784b58ea15b0cb54687e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get min and max values from the yaml node.  <a href="namespacemaliput.html#a733eb44f957c784b58ea15b0cb54687e">More...</a><br /></td></tr>
<tr class="separator:a733eb44f957c784b58ea15b0cb54687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dc4113f3ad71335d63a727cc7152ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#ab3dc4113f3ad71335d63a727cc7152ba">GetValueFromYamlNode</a> (const YAML::Node &amp;node)</td></tr>
<tr class="memdesc:ab3dc4113f3ad71335d63a727cc7152ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a> from a yaml node.  <a href="namespacemaliput.html#ab3dc4113f3ad71335d63a727cc7152ba">More...</a><br /></td></tr>
<tr class="separator:ab3dc4113f3ad71335d63a727cc7152ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa19c2692bbb842a8218d2257e1cd168"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#aaa19c2692bbb842a8218d2257e1cd168">GetDescriptionFromYamlNode</a> (const YAML::Node &amp;node)</td></tr>
<tr class="memdesc:aaa19c2692bbb842a8218d2257e1cd168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a> from a yaml node.  <a href="namespacemaliput.html#aaa19c2692bbb842a8218d2257e1cd168">More...</a><br /></td></tr>
<tr class="separator:aaa19c2692bbb842a8218d2257e1cd168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965f15f535b37a8265347d8d2e5434be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a965f15f535b37a8265347d8d2e5434be">LoadPhaseRingBook</a> (const RoadRulebook *rulebook, const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *traffic_light_book, const std::string &amp;input)</td></tr>
<tr class="separator:a965f15f535b37a8265347d8d2e5434be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265cddc5edae1f57e02d03499c4c29c5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a265cddc5edae1f57e02d03499c4c29c5">LoadPhaseRingBookFromFile</a> (const RoadRulebook *rulebook, const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *traffic_light_book, const std::string &amp;filename)</td></tr>
<tr class="separator:a265cddc5edae1f57e02d03499c4c29c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ad2c0686a0577304e12d2094fa355"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#aa55ad2c0686a0577304e12d2094fa355">LoadPhaseRingBookOldRules</a> (const RoadRulebook *rulebook, const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *traffic_light_book, const std::string &amp;input)</td></tr>
<tr class="separator:aa55ad2c0686a0577304e12d2094fa355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826897c7b08dbb77b64737456e1d0b7a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a826897c7b08dbb77b64737456e1d0b7a">LoadPhaseRingBookFromFileOldRules</a> (const RoadRulebook *rulebook, const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *traffic_light_book, const std::string &amp;filename)</td></tr>
<tr class="separator:a826897c7b08dbb77b64737456e1d0b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d79f56feceef38ffe51eb5e0a1e1b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1common_1_1_logger.html">common::Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput.html#a8d79f56feceef38ffe51eb5e0a1e1b03">log</a> ()</td></tr>
<tr class="separator:a8d79f56feceef38ffe51eb5e0a1e1b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af47f9bba35c4e7f194275267573a1faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47f9bba35c4e7f194275267573a1faa">&#9670;&nbsp;</a></span>DiscreteValueRuleFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput.html#af47f9bba35c4e7f194275267573a1faa">DiscreteValueRuleFilter</a> =  std::function&lt;bool(const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html">api::rules::DiscreteValueRule</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient alias of a functor to filter api::rules::DiscreteValueRules based on arbitrary criteria from a api::rules::RoadRulebook::QueryResult. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemaliput.html#ab6fcf00cfd61b5f2c309a471f8973340" title="Returns rules after the application of discrete_value_rules_filters and range_value_rules_filters.">FilterRules()</a> for further information. </dd></dl>

</div>
</div>
<a id="a3fa6b098ad1261c86b7a71c1cb1a558b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa6b098ad1261c86b7a71c1cb1a558b">&#9670;&nbsp;</a></span>QueryResults</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput.html#a3fa6b098ad1261c86b7a71c1cb1a558b">QueryResults</a> =  <a class="el" href="structmaliput_1_1api_1_1rules_1_1_road_rulebook_1_1_query_results.html">api::rules::RoadRulebook::QueryResults</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab010f6124960691793181deddb8302e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab010f6124960691793181deddb8302e3">&#9670;&nbsp;</a></span>RangeValueRuleFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput.html#ab010f6124960691793181deddb8302e3">RangeValueRuleFilter</a> =  std::function&lt;bool(const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_range_value_rule.html">api::rules::RangeValueRule</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient alias of a functor to filter <a class="el" href="classmaliput_1_1api_1_1rules_1_1_range_value_rule.html" title="Describes a numeric range based rule.">api::rules::RangeValueRule</a> based on arbitrary criteria from a api::rules::RoadRulebook::QueryResult. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemaliput.html#ab6fcf00cfd61b5f2c309a471f8973340" title="Returns rules after the application of discrete_value_rules_filters and range_value_rules_filters.">FilterRules()</a> for further information. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0da2be5e4963c00e7d90bea0c5d6e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da2be5e4963c00e7d90bea0c5d6e299">&#9670;&nbsp;</a></span>RuleType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemaliput.html#a0da2be5e4963c00e7d90bea0c5d6e299">RuleType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Label to identify rule type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0da2be5e4963c00e7d90bea0c5d6e299aff95300802b888f287a7cce6fb26e6de"></a>kDiscreteValueRuleType&#160;</td><td class="fielddoc"><p>Label for a DiscreteValueRule Type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0da2be5e4963c00e7d90bea0c5d6e299aa21f41aa0071e057d4063688cde149cd"></a>kRangeValueRuleType&#160;</td><td class="fielddoc"><p>Label for a RangeValueRule Type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0da2be5e4963c00e7d90bea0c5d6e299acb176da2fcabc07c07cc1a211231a3f1"></a>kUnknownRuleType&#160;</td><td class="fielddoc"><p>Label for an unidentified rule type. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a88f6afe21f74c97a61caa392f3d99085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f6afe21f74c97a61caa392f3d99085">&#9670;&nbsp;</a></span>BuildDirectionUsageRuleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1api_1_1rules.html#a2243c6424f27aa59e29bec1413f2d962">api::rules::DiscreteValueRuleTypeAndValues</a> BuildDirectionUsageRuleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direction usage rule type and its possible discrete values. </p>
<p><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> is initialized via <a class="el" href="namespacemaliput.html#a59970e4acc510adc08b7d1b925c79428" title="Returns a Rule::TypeId whose string representation is &quot;Direction-Usage Rule Type&quot;.">DirectionUsageRuleTypeId()</a>. Values:</p>
<ul>
<li>WithS: travel should proceed in the direction of the +S axis.</li>
<li>AgainstS: travel should proceed opposite the +S axis direction.</li>
<li>Bidirectional: travel is allowed both with the lane direction(+S) or against it.</li>
<li>BidirectionalTurnOnly: travel is allowed both with the lane direction(+S) or against it but should be limited in duration, e.g. when approaching turns.</li>
<li>NoUse: Travel on this lane is prohibited.</li>
<li>Parking: This lane is used to define a parking area.</li>
<li>Undefined: There is no defined direction of travel on this lane.</li>
</ul>
<p>With <a class="el" href="structmaliput_1_1api_1_1rules_1_1_rule_1_1_state.html#ae723a76a2f38404bb7341f2c1ffd890a" title="Defines common Rule severity levels.">api::rules::Rule::State::kStrict</a> strictness level. RelatedRules are empty. </p>

</div>
</div>
<a id="ae129ca7ec98c04f107c8ca5642a18805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae129ca7ec98c04f107c8ca5642a18805">&#9670;&nbsp;</a></span>BuildRightOfWayRuleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1api_1_1rules.html#a2243c6424f27aa59e29bec1413f2d962">api::rules::DiscreteValueRuleTypeAndValues</a> BuildRightOfWayRuleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a right-of-way rule type and its possible discrete values. </p>
<p><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> is initialized via <a class="el" href="namespacemaliput.html#ac32b426289adb8580f95431a088dca4a" title="Returns a Rule::TypeId whose string representation is &quot;Right-Of-Way Rule Type&quot;.">RightOfWayRuleTypeId()</a>. Discrete values are the combination of values and two strictness levels. Values:</p>
<ul>
<li>Go: the vehicle has right-of-way and may proceed across the rule's zone.</li>
<li>Stop: the vehicle does not have right-of-way and must stop prior to entering the rule's zone.</li>
<li>StopThenGo: the vehicle must come to complete stop before entering controlled zone, but may then proceed if safe.</li>
</ul>
<p>Strictness levels are:</p>
<ul>
<li><a class="el" href="structmaliput_1_1api_1_1rules_1_1_rule_1_1_state.html#ae723a76a2f38404bb7341f2c1ffd890a" title="Defines common Rule severity levels.">api::rules::Rule::State::kStrict</a></li>
<li><a class="el" href="structmaliput_1_1api_1_1rules_1_1_rule_1_1_state.html#a7f1130b023df6bd64569f4bd8af34f5d" title="Rule should be obeyed on a best-effort basis.">api::rules::Rule::State::kBestEffort</a></li>
</ul>
<p>RelatedRules are empty. </p>

</div>
</div>
<a id="a7764364f52a7f06d32340e697d2fd894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7764364f52a7f06d32340e697d2fd894">&#9670;&nbsp;</a></span>BuildVehicleStopInZoneBehaviorRuleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1api_1_1rules.html#a2243c6424f27aa59e29bec1413f2d962">api::rules::DiscreteValueRuleTypeAndValues</a> BuildVehicleStopInZoneBehaviorRuleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vehicle stop in zone behavior rule type and its possible discrete values. </p>
<p><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> is initialized via <a class="el" href="namespacemaliput.html#ade7b13115e7582b310a1425d0c3a5a29" title="Returns a Rule::TypeId whose string representation is &quot;Vehicle-Stop-In-Zone-Behavior Rule Type&quot;.">VehicleStopInZoneBehaviorRuleTypeId()</a>. Values:</p>
<ul>
<li>DoNotStop: the vehicle is not allowed to stop.</li>
<li>5MinuteStop: the vehicle is not allowed to park for more than five minutes.</li>
<li>30MinuteStop: the vehicle is not allowed to park for more than five thirty minutes.</li>
<li>45MinuteStop: the vehicle is not allowed to park for more than five forty-five minutes.</li>
<li>1HourStop: the vehicle is not allowed to park for more than five one hour.</li>
<li>2HourStop: the vehicle is not allowed to park for more than five two hours.</li>
<li>4HourStop: the vehicles is not allowed to park for more than five four hours.</li>
<li>UnrestrictedParking: vehicles are allowed to park without any duration restriction.</li>
</ul>
<p>With <a class="el" href="structmaliput_1_1api_1_1rules_1_1_rule_1_1_state.html#ae723a76a2f38404bb7341f2c1ffd890a" title="Defines common Rule severity levels.">api::rules::Rule::State::kStrict</a> strictness level. RelatedRules are empty. </p>

</div>
</div>
<a id="a59970e4acc510adc08b7d1b925c79428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59970e4acc510adc08b7d1b925c79428">&#9670;&nbsp;</a></span>DirectionUsageRuleTypeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a> DirectionUsageRuleTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> whose string representation is "Direction-Usage Rule Type". </p>

</div>
</div>
<a id="ab6fcf00cfd61b5f2c309a471f8973340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fcf00cfd61b5f2c309a471f8973340">&#9670;&nbsp;</a></span>FilterRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaliput_1_1api_1_1rules_1_1_road_rulebook_1_1_query_results.html">api::rules::RoadRulebook::QueryResults</a> FilterRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1api_1_1rules_1_1_road_rulebook_1_1_query_results.html">api::rules::RoadRulebook::QueryResults</a> &amp;&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput.html#af47f9bba35c4e7f194275267573a1faa">DiscreteValueRuleFilter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>discrete_value_rules_filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput.html#ab010f6124960691793181deddb8302e3">RangeValueRuleFilter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range_value_rules_filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>rules</code> after the application of <code>discrete_value_rules_filters</code> and <code>range_value_rules_filters</code>. </p>
<p>Whether a rule is preserved or not is derived from applying each functor in <code>discrete_value_rules_filters</code> and <code>range_value_rules_filters</code> to their respective <code>rules</code> map (by type) as a chain of logic <em>ands</em>. </p>

</div>
</div>
<a id="ace5a222c0c4ca44dbc09aa5b9bfa7c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5a222c0c4ca44dbc09aa5b9bfa7c63">&#9670;&nbsp;</a></span>GetBulbGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1_unique_id.html">maliput::api::UniqueId</a> &gt; GetBulbGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html">maliput::api::rules::DiscreteValueRule::DiscreteValue</a> &amp;&#160;</td>
          <td class="paramname"><em>discrete_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of maliput::api::UniqueIds that represents the bulb group of a Right-Of-Way rule state. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>discrete_value.related_unique_ids</code> does not have <a class="el" href="structmaliput_1_1_related_unique_ids_keys.html#a39d844ef884c68b543f3e4fbb0e7c2cd" title="Key used by Right-Of-Way rules.">RelatedUniqueIdsKeys::kBulbGroup</a> key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07de48c35e49e183caf5ad6580b4d0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07de48c35e49e183caf5ad6580b4d0d5">&#9670;&nbsp;</a></span>GetCurrentBulbGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1_unique_id.html">maliput::api::UniqueId</a> &gt; GetCurrentBulbGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html">maliput::api::rules::DiscreteValueRule</a> &amp;&#160;</td>
          <td class="paramname"><em>discrete_value_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule_state_provider.html">maliput::api::rules::DiscreteValueRuleStateProvider</a> *&#160;</td>
          <td class="paramname"><em>state_provider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current bulb group of <code>discrete_value_rule</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discrete_value_rule</td><td>A Right-Of-Way Rule Type rule. </td></tr>
    <tr><td class="paramname">state_provider</td><td>A state provider to retrieve current <code>discrete_value_rule</code> state. It must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>discrete_value_rule.type_id()</code> is not <a class="el" href="namespacemaliput.html#ac32b426289adb8580f95431a088dca4a" title="Returns a Rule::TypeId whose string representation is &quot;Right-Of-Way Rule Type&quot;.">RightOfWayRuleTypeId()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>state_provider</code> is nullptr. </td></tr>
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>state_provider</code> does not hold any state for <code>discrete_value_rule</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717bbe98643e0f44b2f22588f3876a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717bbe98643e0f44b2f22588f3876a9d">&#9670;&nbsp;</a></span>GetCurrentYieldGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a5358e3b05db56d19875bb15f02523f2f">maliput::api::rules::Rule::Id</a> &gt; GetCurrentYieldGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule.html">maliput::api::rules::DiscreteValueRule</a> &amp;&#160;</td>
          <td class="paramname"><em>discrete_value_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_discrete_value_rule_state_provider.html">maliput::api::rules::DiscreteValueRuleStateProvider</a> *&#160;</td>
          <td class="paramname"><em>state_provider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current yield group of <code>discrete_value_rule</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discrete_value_rule</td><td>A Right-Of-Way Rule Type rule. </td></tr>
    <tr><td class="paramname">state_provider</td><td>A state provider to retrieve current <code>discrete_value_rule</code> state. It must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>discrete_value_rule.type_id()</code> is not <a class="el" href="namespacemaliput.html#ac32b426289adb8580f95431a088dca4a" title="Returns a Rule::TypeId whose string representation is &quot;Right-Of-Way Rule Type&quot;.">RightOfWayRuleTypeId()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>state_provider</code> is nullptr. </td></tr>
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>state_provider</code> does not hold any state for <code>discrete_value_rule</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa19c2692bbb842a8218d2257e1cd168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa19c2692bbb842a8218d2257e1cd168">&#9670;&nbsp;</a></span>GetDescriptionFromYamlNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetDescriptionFromYamlNode </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the description of a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a> from a yaml node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A YAML::Node that contains the description of the api::rules::DiscreteValueRule::Range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string contained in the description field value from the <code>node</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">maliput::common::assertion_error</a></td><td>when the description is ill-defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a733eb44f957c784b58ea15b0cb54687e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733eb44f957c784b58ea15b0cb54687e">&#9670;&nbsp;</a></span>GetRangeMinMaxValuesFromYamlNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; GetRangeMinMaxValuesFromYamlNode </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get min and max values from the yaml node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A YAML::Node that contains the range of the <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The min and max values contained in the range from the node.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">maliput::common::assertion_error</a></td><td>when the range is ill-defined. </td></tr>
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">maliput::common::assertion_error</a></td><td>when the min value is greater than max value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af40338e73891cfbcf9072e153710dd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40338e73891cfbcf9072e153710dd68">&#9670;&nbsp;</a></span>GetSeverityFromYamlNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetSeverityFromYamlNode </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the severity field value from the <code>node</code>. </p>
<p>When severity is undefined, it will return <a class="el" href="structmaliput_1_1api_1_1rules_1_1_rule_1_1_state.html#ae723a76a2f38404bb7341f2c1ffd890a" title="Defines common Rule severity levels.">api::rules::Rule::State::kStrict</a> value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A YAML::Node that contains severity of the <a class="el" href="structmaliput_1_1api_1_1rules_1_1_rule_1_1_state.html" title="Defines a base state for a Rule.">api::rules::Rule::State</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value indicating severityness. 0 is the strictest.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">maliput::common::assertion_error</a></td><td>when the severity is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3dc4113f3ad71335d63a727cc7152ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dc4113f3ad71335d63a727cc7152ba">&#9670;&nbsp;</a></span>GetValueFromYamlNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetValueFromYamlNode </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a> from a yaml node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A YAML::Node that contains the value of the <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string contained in the value from the <code>node</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">maliput::common::assertion_error</a></td><td>when the value is ill-defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98b23877bdff76d8134d4ae47c0e6001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b23877bdff76d8134d4ae47c0e6001">&#9670;&nbsp;</a></span>GetYieldGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a5358e3b05db56d19875bb15f02523f2f">maliput::api::rules::Rule::Id</a> &gt; GetYieldGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html">maliput::api::rules::DiscreteValueRule::DiscreteValue</a> &amp;&#160;</td>
          <td class="paramname"><em>discrete_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of Rule::Ids that represents the yield group of a Right-Of-Way rule state. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaliput_1_1common_1_1assertion__error.html" title="This is what MALIPUT_THROW_UNLESS throws.">common::assertion_error</a></td><td>When <code>discrete_value.related_rules</code> does not have <a class="el" href="structmaliput_1_1_related_rules_keys.html#aa720a4c0de6d923ecf6234a6378edc87" title="Key used by Right-Of-Way rules to yield to other rules.">RelatedRulesKeys::kYieldGroup</a> key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e9fde3287ad8867f768d2f3c05cdf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9fde3287ad8867f768d2f3c05cdf0a">&#9670;&nbsp;</a></span>IsDiscreteValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsDiscreteValue </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>rule_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the <code>rule_node</code> corresponds to a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a> description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule_node</td><td>A YAML::Node that contains information of a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_discrete_value_rule_1_1_discrete_value.html" title="Defines a discrete value for a DiscreteValueRule.">api::rules::DiscreteValueRule::DiscreteValue</a> is contained in <code>rule_node</code>. </dd></dl>

</div>
</div>
<a id="a939fda7aa16deb30b6226ffea2396632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939fda7aa16deb30b6226ffea2396632">&#9670;&nbsp;</a></span>IsRangeValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsRangeValue </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>rule_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the <code>rule_node</code> corresponds to a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a> description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule_node</td><td>A YAML::Node that contains information of a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when a <a class="el" href="structmaliput_1_1api_1_1rules_1_1_range_value_rule_1_1_range.html" title="Defines a range for a RangeValueRule.">api::rules::RangeValueRule::Range</a> is contained in <code>rule_node</code>. </dd></dl>

</div>
</div>
<a id="a4e6d552753de675620983cc700fdb774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6d552753de675620983cc700fdb774">&#9670;&nbsp;</a></span>LoadIntersectionBook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html">api::IntersectionBook</a> &gt; LoadIntersectionBook </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &amp;&#160;</td>
          <td class="paramname"><em>road_rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &amp;&#160;</td>
          <td class="paramname"><em>phase_ring_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1_manual_phase_provider.html">ManualPhaseProvider</a> *&#160;</td>
          <td class="paramname"><em>phase_provider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> instance based on the specified <code>input</code> document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> Intersections document. </td></tr>
    <tr><td class="paramname">road_rulebook</td><td>The book containing the road rules. </td></tr>
    <tr><td class="paramname">phase_ring_book</td><td>The book containing the phase rings. </td></tr>
    <tr><td class="paramname">phase_provider</td><td>The phase provider. Adds PhaseRings and sets their initial states.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> instance. </dd></dl>

</div>
</div>
<a id="ad592986cb5030b6febfdb15f825b152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad592986cb5030b6febfdb15f825b152e">&#9670;&nbsp;</a></span>LoadIntersectionBookFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html">api::IntersectionBook</a> &gt; LoadIntersectionBookFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &amp;&#160;</td>
          <td class="paramname"><em>road_rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a> &amp;&#160;</td>
          <td class="paramname"><em>phase_ring_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1_manual_phase_provider.html">ManualPhaseProvider</a> *&#160;</td>
          <td class="paramname"><em>phase_provider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> instance based on the specified <code>filename</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> file that contains a Intersections document. </td></tr>
    <tr><td class="paramname">road_rulebook</td><td>The book containing the road rules. </td></tr>
    <tr><td class="paramname">phase_ring_book</td><td>The book containing the phase rings. </td></tr>
    <tr><td class="paramname">phase_provider</td><td>The phase provider. Adds PhaseRings and sets their initial states.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1_intersection_book.html" title="An abstract interface for providing the mapping from Intersection::Id to Intersection.">api::IntersectionBook</a> instance. </dd></dl>

</div>
</div>
<a id="a16da6294622c366500107beede513985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16da6294622c366500107beede513985">&#9670;&nbsp;</a></span>LoadPhaseRingBook() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>input</code> document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rulebook</td><td>Contains the rules.</td></tr>
    <tr><td class="paramname">traffic_light_book</td><td>Contains the traffic lights.</td></tr>
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> PhaseRings document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance. </dd></dl>

</div>
</div>
<a id="a965f15f535b37a8265347d8d2e5434be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965f15f535b37a8265347d8d2e5434be">&#9670;&nbsp;</a></span>LoadPhaseRingBook() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBook </td>
          <td>(</td>
          <td class="paramtype">const RoadRulebook *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa94a8bdc4b38fcc4d05e6637903f0f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94a8bdc4b38fcc4d05e6637903f0f56">&#9670;&nbsp;</a></span>LoadPhaseRingBookFromFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBookFromFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>filename</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rulebook</td><td>Contains the rules.</td></tr>
    <tr><td class="paramname">traffic_light_book</td><td>Contains the traffic lights.</td></tr>
    <tr><td class="paramname">filename</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> file that contains a PhaseRings document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance. </dd></dl>

</div>
</div>
<a id="a265cddc5edae1f57e02d03499c4c29c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265cddc5edae1f57e02d03499c4c29c5">&#9670;&nbsp;</a></span>LoadPhaseRingBookFromFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBookFromFile </td>
          <td>(</td>
          <td class="paramtype">const RoadRulebook *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a179c8e2243d2f113a0574efc1f57758e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179c8e2243d2f113a0574efc1f57758e">&#9670;&nbsp;</a></span>LoadPhaseRingBookFromFileOldRules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBookFromFileOldRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>filename</code>. </p>
<p>Based on old rule API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rulebook</td><td>Contains the rules.</td></tr>
    <tr><td class="paramname">traffic_light_book</td><td>Contains the traffic lights.</td></tr>
    <tr><td class="paramname">filename</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> file that contains a PhaseRings document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance. </dd></dl>

</div>
</div>
<a id="a826897c7b08dbb77b64737456e1d0b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826897c7b08dbb77b64737456e1d0b7a">&#9670;&nbsp;</a></span>LoadPhaseRingBookFromFileOldRules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBookFromFileOldRules </td>
          <td>(</td>
          <td class="paramtype">const RoadRulebook *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71eff4450bcc4e11f38442441cdb5195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eff4450bcc4e11f38442441cdb5195">&#9670;&nbsp;</a></span>LoadPhaseRingBookOldRules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBookOldRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance based on the specified <code>rulebook</code>, and <code>input</code> <a class="el" href="namespace_y_a_m_l.html">YAML</a> string. </p>
<p>Based on old rule API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rulebook</td><td>Contains the rules.</td></tr>
    <tr><td class="paramname">traffic_light_book</td><td>Contains the traffic lights.</td></tr>
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> string which describes the PhaseRings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html" title="Abstract interface for providing the mapping from RightOfWayRule::Id to PhaseRing.">api::rules::PhaseRingBook</a> instance. </dd></dl>

</div>
</div>
<a id="aa55ad2c0686a0577304e12d2094fa355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55ad2c0686a0577304e12d2094fa355">&#9670;&nbsp;</a></span>LoadPhaseRingBookOldRules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1api_1_1rules_1_1_phase_ring_book.html">api::rules::PhaseRingBook</a>&gt; maliput::LoadPhaseRingBookOldRules </td>
          <td>(</td>
          <td class="paramtype">const RoadRulebook *&#160;</td>
          <td class="paramname"><em>rulebook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1_traffic_light_book.html">TrafficLightBook</a> *&#160;</td>
          <td class="paramname"><em>traffic_light_book</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae87bad07e3c579517a7e486544448e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87bad07e3c579517a7e486544448e59">&#9670;&nbsp;</a></span>LoadRoadRulebook() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt; LoadRoadRulebook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *&#160;</td>
          <td class="paramname"><em>road_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code> and <code>input</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">road_geometry</td><td>The road geometry to which the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> to be loaded applies.</td></tr>
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> RoadRulebook document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> containing the rules specified in <code>input</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="namespace_y_a_m_l.html">YAML</a> document within <code>input</code> is invalid, or an api::rules::RightOfWayRule within <code>input</code> has an invalid state or zone type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a2036f65730d912b68767e489d36f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a2036f65730d912b68767e489d36f4">&#9670;&nbsp;</a></span>LoadRoadRulebook() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt; LoadRoadRulebook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *&#160;</td>
          <td class="paramname"><em>road_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>rule_registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code>, <code>input</code> and <code>rule_registry</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">road_geometry</td><td>The road geometry to which the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> to be loaded applies. It must not be nullptr.</td></tr>
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> RoadRulebook document.</td></tr>
    <tr><td class="paramname">rule_registry</td><td>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> for creating allowed rule types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> containing the rules specified in <code>input</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="namespace_y_a_m_l.html">YAML</a> document in <code>input</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae8bb612786d298f2f4eb0ea5a010caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8bb612786d298f2f4eb0ea5a010caf">&#9670;&nbsp;</a></span>LoadRoadRulebookFromFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt; LoadRoadRulebookFromFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *&#160;</td>
          <td class="paramname"><em>road_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code> and <code>filename</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">road_geometry</td><td>The road geometry to which the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> to be loaded applies.</td></tr>
    <tr><td class="paramname">filename</td><td>The path to the <a class="el" href="namespace_y_a_m_l.html">YAML</a> RoadRulebook document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> containing the rules specified in <code>input</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="namespace_y_a_m_l.html">YAML</a> document in <code>filename</code> is invalid, or an api::rules::RightOfWayRule within that document has an invalid state or zone type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accce2c90d0627fa85c6b11c9924c0609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accce2c90d0627fa85c6b11c9924c0609">&#9670;&nbsp;</a></span>LoadRoadRulebookFromFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html">api::rules::RoadRulebook</a> &gt; LoadRoadRulebookFromFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> *&#160;</td>
          <td class="paramname"><em>road_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>rule_registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> based on the specified <code>road_geometry</code>, <code>filename</code> and <code>rule_registry</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">road_geometry</td><td>The road geometry to which the <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> to be loaded applies. It must not be nullptr.</td></tr>
    <tr><td class="paramname">filename</td><td>The path to the <a class="el" href="namespace_y_a_m_l.html">YAML</a> RoadRulebook document.</td></tr>
    <tr><td class="paramname">rule_registry</td><td>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> for creating allowed rule types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_road_rulebook.html" title="Abstract interface for querying &quot;rules of the road&quot;.">api::rules::RoadRulebook</a> containing the rules specified in <code>input</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="namespace_y_a_m_l.html">YAML</a> document in <code>filename</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8578b49883025263c70cb77aea11af3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8578b49883025263c70cb77aea11af3e">&#9670;&nbsp;</a></span>LoadRuleRegistry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &gt; LoadRuleRegistry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> based on the specified <code>input</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> RuleRegistry document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> containing the rule types for DiscreteValueRule and RangeValueRule Types specified in <code>input</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="namespace_y_a_m_l.html">YAML</a> document within <code>input</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03c4c176854c7d60524ec666c03f3ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c4c176854c7d60524ec666c03f3ff4">&#9670;&nbsp;</a></span>LoadRuleRegistryFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html">api::rules::RuleRegistry</a> &gt; LoadRuleRegistryFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> based on the specified <code>filename</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to the <a class="el" href="namespace_y_a_m_l.html">YAML</a> RuleRegistry document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule_registry.html" title="A registry for Rule types.">api::rules::RuleRegistry</a> containing the rule types for DiscreteValueRule and RangeValueRule Types specified in the file.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="namespace_y_a_m_l.html">YAML</a> document referred by <code>filename</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3673381fed4e6e5b62a3ffc77f3f9bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673381fed4e6e5b62a3ffc77f3f9bae">&#9670;&nbsp;</a></span>LoadTrafficLightBook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> &gt; LoadTrafficLightBook </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> instance based on the specified <code>input</code> document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> TrafficLights document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> instance. </dd></dl>

</div>
</div>
<a id="a748a7535cbc24118299c3bcbef33a20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748a7535cbc24118299c3bcbef33a20d">&#9670;&nbsp;</a></span>LoadTrafficLightBookFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html">api::rules::TrafficLightBook</a> &gt; LoadTrafficLightBookFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates and returns an <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> instance based on the specified <code>filename</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The <a class="el" href="namespace_y_a_m_l.html">YAML</a> file that contains a TrafficLights document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classmaliput_1_1api_1_1rules_1_1_traffic_light_book.html" title="Abstract interface for providing the mapping from TrafficLight::Id to TrafficLight.">api::rules::TrafficLightBook</a> instance. </dd></dl>

</div>
</div>
<a id="a8d79f56feceef38ffe51eb5e0a1e1b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d79f56feceef38ffe51eb5e0a1e1b03">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1common_1_1_logger.html">common::Logger</a>* maliput::log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32b426289adb8580f95431a088dca4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32b426289adb8580f95431a088dca4a">&#9670;&nbsp;</a></span>RightOfWayRuleTypeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a> RightOfWayRuleTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> whose string representation is "Right-Of-Way Rule Type". </p>

</div>
</div>
<a id="a3fedaec7dc89f069552385eeaf1bddee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fedaec7dc89f069552385eeaf1bddee">&#9670;&nbsp;</a></span>SpeedLimitRuleTypeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a> SpeedLimitRuleTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">maliput::api::rules::Rule::TypeId</a> initialized with "Speed-Limit Rule Type". </p>

</div>
</div>
<a id="ade7b13115e7582b310a1425d0c3a5a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7b13115e7582b310a1425d0c3a5a29">&#9670;&nbsp;</a></span>VehicleStopInZoneBehaviorRuleTypeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1">api::rules::Rule::TypeId</a> VehicleStopInZoneBehaviorRuleTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmaliput_1_1api_1_1rules_1_1_rule.html#a4a4b94bba0865a112a84d2b4a054b6b1" title="Alias for the Rule&#39;s type.">Rule::TypeId</a> whose string representation is "Vehicle-Stop-In-Zone-Behavior Rule Type". </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacemaliput_1_1common_html_a44240da1e534b4f1ad217fd60715fefe"><div class="ttname"><a href="namespacemaliput_1_1common.html#a44240da1e534b4f1ad217fd60715fefe">maliput::common::hash_append</a></div><div class="ttdeci">std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; hash_append(HashAlgorithm &amp;hasher, const T &amp;item) noexcept</div><div class="ttdoc">Provides hash_append for integral constants.</div><div class="ttdef"><b>Definition:</b> maliput_hash.h:102</div></div>
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemaliput.html">maliput</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput_malidrive: Malidrive RoadCurve Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput_malidrive
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('malidrive_road_curve_design.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Malidrive RoadCurve Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#road_curve_concepts">RoadCurve concepts and definitions</a><ul><li class="level2"><a href="#mapping_the_inertial_frame">Mapping the INERTIAL Frame</a></li>
<li class="level2"><a href="#tangent_vector_road_surface">Computing the tangent vector</a></li>
<li class="level2"><a href="#orientation">Orientation</a><ul><li class="level3"><a href="#orientation_at_the_centerline">Orientation at the centerline</a></li>
<li class="level3"><a href="#orientation_at_any_point">Orientation at any point in the road volume</a></li>
</ul>
</li>
<li class="level2"><a href="#inverse_function">Inverse function</a></li>
</ul>
</li>
<li class="level1"><a href="#math_reformulation">Alternate formulation of math problem</a><ul><li class="level2"><a href="#at_a_lateral_offset">Rotation at a lateral offset</a></li>
<li class="level2"><a href="#motion_derivatives">Motion derivatives</a></li>
</ul>
</li>
<li class="level1"><a href="#questions">Questions</a><ul><li class="level2"><a href="#comparing_definitions_of_frenet_frame">Comparing definitions of the Frenet-like frame</a></li>
<li class="level2"><a href="#roll_pitch_yaw_orthogonality">&lt;tt&gt;RollPitchYaw&lt;/tt&gt; orthogonality</a></li>
<li class="level2"><a href="#continuity_requirements">Continuity requirements</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Agustin Alba Chicar </dd>
<dd>
Steven Peters </dd></dl>
<dl class="section date"><dt>Date</dt><dd>July 29, 2020</dd></dl>
<h1><a class="anchor" id="road_curve_concepts"></a>
RoadCurve concepts and definitions</h1>
<p>RoadCurve defines an interface for a path in a Segment object surface. The path is defined by an elevation and superelevation Function objects and a GroundCurve reference curve. The latter is a C¹ function in the \( z=0 \) plane. Its domain is constrained in \( [GroundCurve::p0(); GroundCurve::p1()] \) interval and it should map a ℝ² curve.</p>
<p>As per notation, \( p \) is the parameter of the reference curve, not necessarily arc length \( s \), and function interpolations and function derivatives as well as headings and heading derivatives are expressed in INERTIAL Frame coordinates.</p>
<p>The geometry here revolves around an abstract "world function":</p>
<p>\( W: (p,r,h) \mapsto (x,y,z) ∈ ℝ³ \)</p>
<p>which maps a <code>Lane</code>-frame position to its corresponding representation in world coordinates (with the caveat that instead of the lane's native longitudinal coordinate <code>s</code>, the reference curve parameter <code>p</code> is used).</p>
<p>\( W \) is derived from three functions which define the lane:</p>
<ul>
<li>\( G: p \mapsto (x,y) \) : the reference ground curve (a <code>GroundCurve</code> implementation).</li>
<li>\( Z: p \mapsto z \) : the elevation function (a <code>Function</code> implementation).</li>
<li>\( Θ: p \mapsto θ \) : the superelevation function (a <code>Function</code> implementation).</li>
</ul>
<p>as:</p>
<p>\( (x,y,z) = W(p,r,h) = (G(p), Z(p)) + R_{αβγ} x (0, r, h) \)</p>
<p>where:</p>
<ul>
<li>\( R_{αβγ} \) is the roll/pitch/yaw rotation given by angles:<ul>
<li>\( α = Θ(p) \)</li>
<li>\( β = -atan2(\frac{dZ}{dp}, sqrt((\frac{dG_x}{dp})^2 + (\frac{dG_y}{dp})^2)) \) at \( p \)</li>
<li>\( γ = atan2(\frac{dG_y}{dp}, \frac{dG_x}{dp}) \) at \( p \)</li>
</ul>
</li>
</ul>
<p>( \( R_{αβγ} \) is essentially the orientation of the \( (s,r,h) \) <code>Lane</code>-frame at a location \( (s,0,0) \) on the reference-line of the lane. However, it is <em>not</em> necessarily the correct orientation at \( r \ne 0 \) or \( h \ne 0 \).)</p>
<p>The \( W(p,r,h) \) "world function" is defined by the RoadCurve referenced by a Lane's Segment. A Lane is also defined by a \( r0 \) lateral offset with respect to the reference curve of the RoadCurve. Thus, a mapping from the local \( (s,r,h) \) lane-frame of the Lane becomes:</p>
<p>\( (x,y,z) = L(s,r,h) = W(P(s, r0), r + r0, h) \)</p>
<p>Where</p><ul>
<li>\( P: (s, r0) \mapsto (p) \) is a (potentially non-linear) function dependent on the RoadCurve's reference-curve, elevation, and superelevation functions.</li>
<li>\( L: (s, r, h) \mapsto (x, y, z) \) is the "lane function", a lateral offset of the world function which lays on the road surface. Note that it is parametrized with its arc length \( s \) instead of an arbitrary parameter \( p \).</li>
</ul>
<h2><a class="anchor" id="mapping_the_inertial_frame"></a>
Mapping the INERTIAL Frame</h2>
<p>Let \( p_L = (p, r, h) \) be a point in the RoadCurve surface. The image of the world function \( W(p_L) \) can be expressed as:</p>
<p>\( W(p_L) = W(p, r, h) = (G(p), Z(p)) + R_{αβγ} x (0, r, h) \)</p>
<h2><a class="anchor" id="tangent_vector_road_surface"></a>
Computing the tangent vector</h2>
<p>Let \( p_L = (p, r, h) \) be a point in the RoadCurve surface. The tangent vector expressed as the derivative of the world function with respect to \( p \) can be expressed as:</p>
<p>\( \frac{\partial W(p_L)}{\partial p} = \frac{\partial W(p, r, h)}{\partial p} \)</p>
<p>\( \frac{\partial W(p_L)}{\partial p} = (\frac{dG(p)}{dp}, \frac{dZ(p)}{dp}) + \frac{dR_{αβγ}}{dp} x (0, r, h) \)</p>
<p>and</p>
<p>\( \frac{dR_{αβγ}}{dp} = (\frac{dR_{αβγ}}{dα} \frac{dR_{αβγ}}{dβ} \frac{dR_{αβγ}}{dγ}) x (\frac{dα}{dp}, \frac{dβ}{dp}, \frac{dγ}{dp}) \)</p>
<p>There are analytic definitions for each derivative expressed above via the API of <code>GroundCurve</code>, <code>Function</code>, and <code>RollPitchYaw</code> classes.</p>
<h2><a class="anchor" id="orientation"></a>
Orientation</h2>
<h3><a class="anchor" id="orientation_at_the_centerline"></a>
Orientation at the centerline</h3>
<p>Specifically, the orientation at the centerline is the orientation of the surface in the INERTIAL frame at any point mapped by the world function whose domain is \( (p, 0, 0) \) (which yields a curve on the surface).</p>
<ul>
<li>\( α = Θ(p) \)</li>
<li>\( β = -atan2(\frac{dZ}{dp}, \sqrt{(\frac{dG_x}{dp})^2 + (\frac{dG_y}{dp})^2}) \)</li>
<li>\( γ = atan2(\frac{dG_y}{dp}, \frac{dG_x}{dp}) \)</li>
</ul>
<p>Then, \( R_{αβγ} = R(α, β, γ) \)</p>
<h3><a class="anchor" id="orientation_at_any_point"></a>
Orientation at any point in the road volume</h3>
<p>Lanes in <code>maliput</code> define a volume as a orthonormal extrusion of the surface in the elevation bounds. The orientation \( p_L = (p, r, h) \) is computed as:</p>
<p>\( \hat{s} = ||\frac{\partial W(p, r, h)}{\partial p}|| \)</p>
<p>\( \hat{r} = R_{αβγ} * (0., 1., 0.) \)</p>
<blockquote class="doxtable">
<p>Note that in certain cases \( \hat{s}, \hat{r} \) are not orthogonal, as documented in <a href="https://github.com/ToyotaResearchInstitute/malidrive/issues/458#issuecomment-663767176">https://github.com/ToyotaResearchInstitute/malidrive/issues/458#issuecomment-663767176</a> </p>
</blockquote>
<p>And,</p>
<ul>
<li>\( γ = atan2(\hat{s}[1], \hat{s}[0]) \)</li>
<li>\( β = atan2(-\hat{s}[2], ||(\hat{s}[0], \hat{s}[1])||) \)</li>
<li>\( α = atan2(\frac{\hat{r}[2]}{cos(β)}, \frac{\hat{r}[1] x \hat{s}[0] - \hat{r}[0] x \hat{s}[1])}{cos(β)}) \)</li>
</ul>
<p>Then, we can compute the rotation matrix out of \( (α, β, γ) \).</p>
<h2><a class="anchor" id="inverse_function"></a>
Inverse function</h2>
<p>Given a point \( p_W = (x, y, z) \) there might exist a point \( p_L = (p, r, h)\) that satisfies \( W(p_L) = p_W \).</p>
<p>The inverse function is procedurally computed by:</p>
<ul>
<li>Compute the \( p \), the parameter value that satisfies \( p_{L_0} = (x, y) \) such that \( G(p) = p_{L_0} \) (the inverse function of G, which has a closed analytic solution).</li>
<li>Iterate while not satisfying tolerance (i.e. Δp &gt; linear_tolerance):<ul>
<li>Compute \( p_{W_0} \), the image of \( W(p, 0, 0)\).</li>
<li>Compute \( Δp_W = p_W - p_{W_0} \)</li>
<li>Compute \( W^{&#39;}(p_{W_0}) = \frac{\partial W(p, 0, 0)}{\partial p}\)</li>
<li>Compute Δp as first order Newton approximation: \( Δp = \frac{&lt;Δp_W, W^{&#39;}(p_{W_0})&gt;}{|| W^{&#39;}(p_{W_0}) ||} \)</li>
<li>Compute \( p = p + Δp \).</li>
</ul>
</li>
<li>Compute \( \hat{s}, \hat{r}, \hat{h} = \hat{s} x \hat{r} \).</li>
<li>Compute \( p_L = (p, &lt;\hat{r}, Δp_W&gt;, &lt;\hat{h}, Δp_W&gt;)\).</li>
</ul>
<h1><a class="anchor" id="math_reformulation"></a>
Alternate formulation of math problem</h1>
<p>Consider a parameterized curve in 3D space called \( C_{0} \) whose coordinates in an inertial frame with orthonormal basis vectors \( \hat{x}, \hat{y}, \hat{z} \) are defined by continuous functions of \( p ∈ [p_0, p_1] \): \( x(p), y(p), z(p) \) with the requirement that \( x(p), y(p) \) do not jointly stagnate with respect to \( p \) (i.e. that there exists a value of \( k \) such that \( (\frac{dx}{dp})^2 + (\frac{dy}{dp})^2 &gt;= k &gt; 0 \)).</p>
<p>The unit vector tangent to \( C_{0} \) is given by \( \hat{t}(p) = \frac{1}{\sqrt{(\frac{dx}{dp})^2 + (\frac{dy}{dp})^2 + (\frac{dz}{dp})^2}} [ \frac{dx}{dp}, \frac{dy}{dp}, \frac{dz}{dp} ]^T = \frac{C_{0}&#39;}{||C_{0}&#39;||}\)</p>
<p>A vector \( n_0(p) \) is defined as the component of \( \hat{z} \) that is orthogonal to \( \hat{t} \) as \( n_0(p) = \hat{z} - &lt;\hat{t}, \hat{z}&gt; \hat{t} \). The vector \( n_0(p) \) has non-zero length if \( \hat{z} \) and \( \hat{t} \) are not identical, and the condition restricting joint stagnation of \( x(p), y(p) \) is sufficient to guarantee this. A unit vector \( \hat{n}_0 \) is defined by normalizing \( n_0 \): \( \hat{n}_0(p) = \frac{n_0}{||n_0||} \)</p>
<p>A third unit vector orthogonal to both \( \hat{n}_0(p), \hat{t}(p) \) is defined as \( \hat{b}_0(p) = \hat{n}_0(p) \times \hat{t}(p) \). The unit vectors \( \hat{t}(p), \hat{b}_0(p), \hat{n}_0(p) \) form an orthonormal basis.</p>
<p>Another orthonormal basis is defined by rotating \( \hat{t}(p), \hat{b}_0(p), \hat{n}_0(p) \) about \( \hat{t}(p) \) by an angle specified by a continuous function \( Θ(p) \). Using the <a href="https://math.stackexchange.com/a/142831">Rodrigues rotation formula</a>: with components of \( \hat{t} \) in the inertial frame given as \( \hat{t}(p) = t_x \hat{x} + t_y \hat{y} + t_z \hat{z} \), identity matrix \( I \), and \( W = \begin{pmatrix} 0 &amp; -t_z &amp; t_y \\ t_z &amp; 0 &amp; -t_x \\ -t_y &amp; t_x &amp; 0 \end{pmatrix} \), a Rotation matrix is defined as \( R_Θ(p) = I + \sin Θ(p) W + 2 \sin^2 \frac{Θ(p)}{2} W^2 \). By construction, rotation by \( R_Θ(p) \) does not affect \( \hat{t}(p) \), so the new basis vectors are defined as \( \hat{t}, \hat{b} = R_Θ(p) \hat{b}_0, \hat{n} = R_Θ(p) \hat{n}_0 \). A rotation matrix \( R_{\hat{t},\hat{b},\hat{n}} \) is defined with these unit vectors as its columns: \( R_{\hat{t},\hat{b},\hat{n}} = [\hat{t},\hat{b},\hat{n}] \).</p>
<p>Note that these basis vectors \( \hat{t}, \hat{b}, \hat{n} \) bear some resemblance to the basis vectors of a Frenet-Serret frame, since the tangent vector \( \hat{t} \) is identical in both formulations, but the other unit vectors have significant differences. Whereas the Frenet-Serret normal unit vector is defined based on the curvature of the 3D curve, in this formulation it is constrained to be a projection of the inertial \( \hat{z} \) axis subject to a specified rotation. Additionally, the order of the unit vectors differs, with Frenet-Serret defining a right-hand basis with tangent, normal, and binormal ( \( \hat{T} \times \hat{N} = \hat{B} \)), while this formulation defines the right-hand basis with tangent, binormal, normal ( \( \hat{t} \times \hat{b} = \hat{n} \)).</p>
<p>To compute the derivative of the rotation matrix \( R_{\hat{t},\hat{b},\hat{n}} \) with respect to \( p \), the following relationship is used that involves \( ω_{\hat{t},\hat{b},\hat{n}} \), which is like an angular velocity of the basis vectors expressed in the inertial frame with respect to changes in \( p \) rather than changes in time: \( \frac{dR_{\hat{t},\hat{b},\hat{n}}}{dp} = ω_{\hat{t},\hat{b},\hat{n}} \times R_{\hat{t},\hat{b},\hat{n}} \). The term \( ω_{\hat{t},\hat{b},\hat{n}} \) is a a sum of two components: a component \( ω_{⟂ \hat{t}} \) that is orthogonal to \( \hat{t} \) and a component parallel to \( \hat{t} \), which is derived from the derivative of the rotation function \( Θ&#39;(p) = \frac{dΘ}{dp} \).</p>
<p>\( ω_{\hat{t},\hat{b},\hat{n}} = ω_{⟂ \hat{t}} + Θ&#39;(p) \hat{t} \)</p>
<p>Since \( \hat{t} \) has unit length, its derivative \( \frac{d\hat{t}}{dp} \) can be expressed as a cross product with the angular velocity component \( ω_{⟂ \hat{t}} \) that is orthogonal to \( \hat{t} \):</p>
<p>\( \frac{d\hat{t}}{dp} = ω_{⟂ \hat{t}} \times \hat{t} \).</p>
<p>Recalling that \( \hat{t} = \frac{C_{0}&#39;}{||C_{0}&#39;||}\), its derivative is computed as:</p>
<p>\( \frac{d\hat{t}}{dp} = \frac{||C_{0}&#39;|| C_{0}&#39;&#39; - \frac{d||C_{0}&#39;||}{dp} C_{0}&#39;}{||C_{0}&#39;||^2} \)</p>
<p>Recalling that \( ||C_{0}&#39;|| = \sqrt{x&#39;^2 + y&#39;^2 + z&#39;^2} \),</p>
<p>it can be differentiated as:</p>
<p>\( \frac{d||C_{0}&#39;||}{dp} = \frac{1}{2 ||C_{0}&#39;||} (2 x&#39; x&#39;&#39; + 2 y&#39; y&#39;&#39; + 2 z&#39; z&#39;&#39;) \).</p>
<p>\( \frac{d||C_{0}&#39;||}{dp} = \frac{&lt;C_{0}&#39;, C_{0}&#39;&#39;&gt;}{||C_{0}&#39;||} \)</p>
<p>\( \frac{d||C_{0}&#39;||}{dp} = &lt;\hat{t}, C_{0}&#39;&#39;&gt; \)</p>
<p>and substituted back as</p>
<p>\( \frac{d\hat{t}}{dp} = \frac{||C_{0}&#39;|| C_{0}&#39;&#39; - &lt;\hat{t}, C_{0}&#39;&#39;&gt; C_{0}&#39;}{||C_{0}&#39;||^2} \)</p>
<p>\( \frac{d\hat{t}}{dp} = \frac{C_{0}&#39;&#39; - &lt;\hat{t}, C_{0}&#39;&#39;&gt; \hat{t}}{||C_{0}&#39;||} \)</p>
<p>\( \frac{d\hat{t}}{dp} = \frac{C_{0 ⟂ \hat{t}}&#39;&#39;}{||C_{0}&#39;||} \)</p>
<p>where \( C_{0 ⟂ \hat{t}}&#39;&#39; \) is the component of \( C_{0}&#39;&#39; \) that is orthogonal to \( \hat{t} \).</p>
<p>Then</p>
<p>\( \frac{d\hat{t}}{dp} = \frac{C_{0 ⟂ \hat{t}}&#39;&#39;}{||C_{0}&#39;||} = ω_{⟂ \hat{t}} \times \hat{t} \).</p>
<p>Since both \( C_{0 ⟂ \hat{t}}&#39;&#39; \) and \( ω_{⟂ \hat{t}} \) are orthogonal to \( \hat{t} \), the following can be shown to be equivalent:</p>
<p>\( ω_{⟂ \hat{t}} \times \hat{t} = \frac{C_{0 ⟂ \hat{t}}&#39;&#39;}{||C_{0}&#39;||} \)</p>
<p>and</p>
<p>\( ω_{⟂ \hat{t}} = \hat{t} \times \frac{C_{0 ⟂ \hat{t}}&#39;&#39;}{||C_{0}&#39;||} \).</p>
<p>The derivative of the rotation matrix is thus</p>
<p>\( \frac{dR_{\hat{t},\hat{b},\hat{n}}}{dp} = (\hat{t} \times \frac{C_{0 ⟂ \hat{t}}&#39;&#39;}{||C_{0}&#39;||} + Θ&#39;(p) \hat{t}) \times R_{\hat{t},\hat{b},\hat{n}} \).</p>
<p>Consider a surface that contains \( C_{0} \) and whose surface normal at each point on \( C_{0} \) is given by \( \hat{n} \).</p>
<h2><a class="anchor" id="at_a_lateral_offset"></a>
Rotation at a lateral offset</h2>
<p>Let the previous parametrized curve in 3D be called \( C_{0} \) and let \( C_{offset} \) be an offset curve at a distance \( r_{(p)} \) along \( \hat{b}_{(p, 0)} \) on the surface where \( C_{0} \) is defined. \( r_{(p)} \) is a C¹ function of \( p \). Then, the curve \( C_{offset_{(p)}} \) can be expressed as:</p>
<p>\( C_{offset_{(p)}} = C_{0_{(p)}} + r_{(p)} \hat{b}_{(p, 0)} \)</p>
<p>We would like to compute the rotation matrix out of the frame basis for any \( p ∈ [p_0, p_1] \) in \( C_{offset_{(p)}} \). To that end, we compute \( C_{offset_{(p)}} \) derivative with respect to \( p \):</p>
<p>\( \frac{dC_{offset_{(p)}}}{dp} = \frac{dC_{0_{(p)}}}{dp} + \frac{dr_{(p)}}{dp} \hat{b}_{(p, 0)} + r_{(p)} \frac{d\hat{b}_{(p, 0)}}{dp} \)</p>
<p>And to compute \( \hat{t}_{(p,r)}, \hat{b}_{(p,r)}, \hat{n}_{(p,r)} \) (i.e. \( \hat{t}_{offset}, \hat{b}_{offset}, \hat{n}_{offset} \) ) we use the same procedure as above.</p>
<h2><a class="anchor" id="motion_derivatives"></a>
Motion derivatives</h2>
<p>Let the previous parametrized curve in 3D be called \( C_{0} \) and let \( C_{offset} \) be an offset curve at a distance \( r_{(p)} \) along \( \hat{b}_{(p, 0)} \) on the surface where \( C_{0} \) is defined. And let \( r_{k} \) be a scalar measured in the \( \hat{b}_{(p, r_{(p)})} \) axis from a point in the \( C_{offset} \) curve at a certain \( p \) value. In addition, let \( v \) be a linear speed vector expressed in the orthonormal basis \( \hat{t}_{offset}, \hat{b}_{offset}, \hat{n}_{offset} \) at \( C_{offset_{(p)}} \).</p>
<p>We are interested in measuring the derivative at the \( r_{k} \) distance from \( C_{offset(p)} \) along \( \hat{b}_{(p, 0)} \). That point in the INERTIAL Frame can be expressed as:</p>
<p>\( C_{offset_{(p, r_{k})}} = C_{offset_{(p)}} + r_{k} \hat{b}_{p, r_{(p)}} \)</p>
<p>\( C&#39;_{offset_{(p, r_{k})}} = C&#39;_{offset_{(p)}} + r_{k} \hat{b}&#39;_{p, r_{(p)}} \)</p>
<blockquote class="doxtable">
<p>TODO(agalbachicar / scpeters): I think the next step should be something like the following: \( C&#39;_{offset_{(p, r_{k})}} = C&#39;_{offset_{(p)}} + r_{k} ω_{⟂ \hat{b}_{p, r_{(p)}}} \times \hat{b}_{p, r_{(p)}} &lt;/blockquote&gt; \)</p>
<p>\( C&#39;_{offset_{(p, r_{k})}} = (1 - r_{k} κ_{offset_{(p)}}) C&#39;_{offset_{(p)}} \)</p>
<p>Where \( κ_{offset_{(p)}} = || \hat{t}&#39;_{(p, r_{(p)})} || \). Consequently, it is expected a change \( v \) by a factor of \( (1 - r_{k} κ_{offset_{(p)}}) \) in the \( \hat{t}_{(p, r_{(p)})} \) direction.</p>
<p>&gt; TODO(agalbachicar / scpeters): Given an offset in the &gt; \( \hat{n}_{p, r_{(p)}}\) direction at \( C_{offset_{(p)}} \), is there any &gt; <em>vertical</em> curvature like quantity that we can introduce to scale &gt; \( v \) ?</p>
<p>Another route to derive the same, i.e. the scaling of \( v \) at a certain position in the curve offset ( \( C_{offset} \)) frame at \( p \), would imply the following procedure:</p>
<p>\( C_{offset_{(p)}} = C_{0(p)} + R_{\hat{t}, \hat{b}, \hat{n}} \times [0, r_{(p)}, 0]^T \)</p>
<p>And the position of a point with a displacement \( [0, r_k, h_k] \) from the curve offset at \( p \) is:</p>
<p>\( C_{offset_{(p, r_k, h_k)}} = C_{0(p)} + R_{\hat{t}, \hat{b}, \hat{n}} \times [0, r_{(p)}, 0]^T + R_{offset_{\hat{t}, \hat{b}, \hat{n}}} \times [0, r_k, h_k]^T \)</p>
<p>\( C_{offset_{(p, r_k, h_k)}} = C_{offset_{(p)}} + R_{offset_{\hat{t}, \hat{b}, \hat{n}}} \times [0, r_k, h_k]^T \)</p>
<p>Where \( R_{offset_{\hat{t}, \hat{b}, \hat{n}}} \) is the rotation matrix at \( C_{offset_{(p)}} \) which is computed from \( \hat{t}_{offset}, \hat{b}_{offset}, \hat{n}_{offset}\). The procedure to compute the basis is exactly the same as it was computed before to derive \( R_{\hat{t}, \hat{b}, \hat{n}} \) but, this time, \( C&#39;_{offset_{(p)}} \) is required to obtain \( \hat{t}_{offset} \) and the other vectors.</p>
<p>To compute \( C&#39;_{offset_{(p, r_k, h_k)}} \), we make use of \( C&#39;_{offset_{(p)}} \):</p>
<p>\( C&#39;_{offset_{(p, r_k, h_k)}} = C&#39;_{offset_{(p)}} + R&#39;_{offset_{\hat{t}, \hat{b}, \hat{n}}} \times [0, r_k, h_k]^T \)</p>
<p>We can apply an analogous procedure to compute \( R&#39;_{offset_{\hat{t}, \hat{b}, \hat{n}}} \) and replace the subscript \( _{0} \) by \( _{offset} \). However, the expansion of \( C&#39;&#39;_{offset} \) requires \( R&#39;&#39;_{\hat{t}, \hat{b}, \hat{n}} \) to exist, leading to the need of \( C&#39;&#39;&#39;_{0} \) to exist too.</p>
<p>&gt; TODO(agalbachicar / scpeters): Determine whether \( C&#39;&#39;&#39;_{0} \) is &gt; really needed or not and if for the geometries we are working with there &gt; is a real need of it to be other than a zero, or a well-known constant.</p>
<p>For planar curves, it is expected a change \( v \) by a factor of \( \frac{|| C&#39;_{offset_{(p, r_k, h_k)}} ||}{|| C&#39;_{offset_{(p)}} ||} \) which is the scale ratio of tangent vectors.</p>
<p></p>
</blockquote>
<h1><a class="anchor" id="questions"></a>
Questions</h1>
<h2><a class="anchor" id="comparing_definitions_of_frenet_frame"></a>
Comparing definitions of the Frenet-like frame</h2>
<p>This document contains two separate approaches for defining a Frenet-like coordinate frame for each point on a 3D curve \( C_0 \): using <code>RollPitchYaw</code> and by computing unit vectors directly.</p>
<p><b>Q: Are these approaches equivalent? Are they correct?</b></p>
<h2><a class="anchor" id="roll_pitch_yaw_orthogonality"></a>
&lt;tt&gt;RollPitchYaw&lt;/tt&gt; orthogonality</h2>
<p>Consider a point fixed to \( C_0 \)'s Frenet-like frame. By computing the velocity of that point, an additional (recursive) Frenet-like frame can be computed at that point, starting with a tangent vector computed from the velocity of that point.</p>
<p><b>Q: For the formulation based on <code>RollPitchYaw</code>, the tangent and binormal unit vectors of that recursive Frenet-like frame are not orthogonal. Where is the problem? Should the approach based on unit vectors be preferred?</b></p>
<h2><a class="anchor" id="continuity_requirements"></a>
Continuity requirements</h2>
<p>In the road context, our documentation says in several places that C¹ continuity is required for the ground curve function, but the formulation defined using unit vectors includes references to the second derivative of \( C_0 \) when computing the velocity of points fixed to the Frenet-like frame. Furthermore, when defining an additional curve at a specified offset from \( C_0 \) and computing a Frenet-like frame for the offset curve, then computing the velocity of points fixed to the offset Frenet-like frame have references to the third derivative of \( C_0 \).</p>
<p><b>Q: What continuity constraints are required for the curve</b> \( C_0 \) <b>? And to the surface where the curve</b> \( C_0 \) <b>and its offsets are embedded?</b> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

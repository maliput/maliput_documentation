<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput_multilane: Multilane Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput_multilane
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('multilane_design.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Multilane Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#concrete_implementation_maliput_multilane">Concrete Implementation: &lt;tt&gt;maliput::multilane&lt;/tt&gt;</a><ul><li class="level2"><a href="#segment_geometry">&lt;tt&gt;Segment&lt;/tt&gt; Geometry</a></li>
<li class="level2"><a href="#lane_geometry">&lt;tt&gt;Lane&lt;/tt&gt; Geometry</a></li>
<li class="level2"><a href="#ensuring_g1_contiguity">Ensuring G¹ Continuity</a></li>
<li class="level2"><a href="#builder_helper_interface">&lt;tt&gt;Builder&lt;/tt&gt; helper interface</a></li>
<li class="level2"><a href="#yaml_file_format">YAML file format</a><ul><li class="level3"><a href="#general_considerations">General considerations</a></li>
<li class="level3"><a href="#example_of_general_structure">Example of General Structure</a></li>
<li class="level3"><a href="#entities">Entities</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Matt Marjanović </dd>
<dd>
Chien-Liang Fok </dd>
<dd>
Agustin Alba Chicar </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 21, 2020</dd></dl>
<h1><a class="anchor" id="concrete_implementation_maliput_multilane"></a>
Concrete Implementation: &lt;tt&gt;maliput::multilane&lt;/tt&gt;</h1>
<p>So-named because it admits multiple <code>Lanes</code> per <code>Segment</code>, an advance over its predecessor (<code>monolane</code>) which only admitted a single <code>Lane</code> per <code>Segment</code>.</p>
<p><code>multilane</code> is an implementation of the <code>maliput</code> geometry API which synthesizes a road network from a small set of primitive building blocks, mimicking techniques used in the geometric design of real roads. The basic geometry of a <code>Segment</code> is derived from the combination of a plane curve, an elevation function, and a superelevation function, combined together to define a ruled surface. A <code>Segment</code> has a longitudinal <em>reference curve</em> (similar to a <code>Lane</code>'s centerline) and each of the <code>Lanes</code> of a <code>Segment</code> is defined via a constant lateral offset, along the segment surface, from that reference curve.</p>
<p>Three coordinate frames are involved in the following discussion:</p><ul>
<li>\((x,y,z)\) is a position in the <code>World</code>-frame.</li>
<li>\((s,r,h)_{LANE,i}\) is a position in the <code>Lane</code>-frame (discussed in section world_frame_versus_lane_frame ) of the <code>Lane</code> with index \(i\).</li>
<li>\((p,r,h)_{SEG}\) is a position in a curvilinear reference frame of the <code>Segment</code>, analogous to \((s,r,h)_{LANE,i}\) for a <code>Lane</code>. The parameter \(p_{SEG} \in [0, 1]\) spans the <code>Segment</code> longitudinally. \(r_{SEG}\) is a lateral offset from the <code>Segment</code>'s reference curve, along the <code>Segment</code> surface. \(h_SEG\) is height above the surface.</li>
</ul>
<h2><a class="anchor" id="segment_geometry"></a>
&lt;tt&gt;Segment&lt;/tt&gt; Geometry</h2>
<blockquote class="doxtable">
<p>TODO Reconsider the use of the word "geometry" below. The geometry of a <code>Segment</code> is completely derived from a map</p>
<p class="formulaDsp">
\[ W: (p,r,h)_{SEG} \mapsto (x,y,z) \]
</p>
<p>which we will construct in stages, starting with the <code>Segment</code> reference curve</p>
<p class="formulaDsp">
\[ W(p_{SEG}) \equiv W(p_{SEG},0,0), \]
</p>
<p>followed by the <code>Segment</code> surface</p>
<p class="formulaDsp">
\[ W(p_{SEG},r_{SEG}) \equiv W(p_{SEG},r_{SEG},0). \]
</p>
 </blockquote>
<p>The construction of \(W(p_{SEG},r_{SEG},h_{SEG})\) will involve three fundamental functions, \(G_\text{xy}\), \(G_z\), and \(\Theta\).</p>
<p>The first fundamental function \(G_\text{xy}\) defines a two dimensional <em>planar primitive curve</em> in the \(xy\) -plane:</p>
<p class="formulaDsp">
\[ G_{xy}: p_{SEG} \mapsto (x,y). \]
</p>
<p>This curve establishes the basic geometric primitive of the <code>Segment</code> (e.g., "constant-radius arc"). We define \(l\) as a path-length along this plane curve, in the range \([0, l_\text{max}]\), where \(l_\text{max}\) is the total path-length of the curve. \(G_{xy}\) is specifically parameterized such that</p>
<p class="formulaDsp">
\[ p_{SEG} \equiv \frac{l}{l_\text{max}}; \]
</p>
<p>in other words, \(p_{SEG}\) is linear in path-length along the planar primitive curve and \(p_{SEG} \in [0,1]\).</p>
<p>The second fundamental function \(G_z\) specifies elevation above the \((xy)\)-plane (albeit with a peculiar scale factor):</p>
<p class="formulaDsp">
\[ G_z: p_{SEG} \mapsto \frac{1}{l_\text{max}}z \]
</p>
<p>Taking \(G_{xy} = (G_x, G_y)\) and \(G_z\) together,</p>
<blockquote class="doxtable">
<p class="formulaDsp">
\[ \left(\begin{array}{c} G_{xy}\\ l_\text{max}G_z \end{array}\right): p_{SEG} \mapsto \left(\begin{array}{c}x\\y\\z\end{array}\right) \]
</p>
 </blockquote>
<p class="formulaDsp">
\[ \left(\begin{array}{c}x\\y\\z\end{array}\right) = W(p_{SEG}) = \left(\begin{array}{c} G_x(p_{SEG})\\ G_y(p_{SEG})\\ l_\text{max}G_z(p_{SEG}) \end{array}\right) \]
</p>
<p>defines the three dimensional <em>reference curve</em> \(W(p_{SEG})\) for the <code>Segment</code>. \(G_z\) is constructed with the scale factor of \(1/l_\text{max}\) specifically so that:</p>
<p class="formulaDsp">
\[ \begin{eqnarray*} z &amp; = &amp; l_\text{max} G_z(p_{SEG})\\ &amp; = &amp; l_\text{max} G_z\left(\frac{l}{l_\text{max}}\right)\\ \dot{z} &amp; = &amp; \frac{dz}{dl} = \frac{d}{dp_{SEG}}G_z(p_{SEG}) \end{eqnarray*} \]
</p>
<p>This allows us to derive the first derivative of \(G_z\) directly from the <code>World</code>-frame slope \(\dot{z} = \frac{dz}{dl}\) of the segment surface along its reference curve. This is convenient because \(\dot{z}\) is what a road designer would nominally specify as the "slope of the road" or the "grade of the road".</p>
<p>The third fundamental function \(\Theta\) specifies the superelevation of the <code>Segment</code> surface:</p>
<p class="formulaDsp">
\[ \Theta: p_{SEG} \mapsto \frac{1}{l_\text{max}}\theta \]
</p>
<p>Superelevation \(\theta\) is the "twist" in a road, given as a right-handed angle of rotation around the tangent of the reference curve \(W(p_{SEG})\). Zero superelevation leaves the surface parallel with the \(xy\) plane. Note that superelevation becomes ambiguous when the tangent of the reference curve points in the \(\hat{z}\) direction.</p>
<p>As with \(G_z\), \(\Theta\) is scaled so that:</p>
<p class="formulaDsp">
\[ \begin{eqnarray*} \theta &amp; = &amp; l_\text{max} \Theta\left(\frac{l}{l_\text{max}}\right)\\ \dot{\theta} &amp; = &amp; \frac{d\theta}{dl} = \frac{d}{dp_{SEG}}\Theta(p_{SEG}) \end{eqnarray*} \]
</p>
<blockquote class="doxtable">
<p>With the three fundamental functions in hand, we can express the orientation of the \((\hat{p},\hat{r},\hat{h})_{SEG}\) frame along the reference curve, with respect to the <code>World</code>-frame, as a roll/pitch/yaw rotation: </p>
</blockquote>
<p>We use all three fundamental functions to define a rotation</p>
<p class="formulaDsp">
\[ \begin{align*} \mathbf{R}(p_{SEG}) &amp;= \mathbf{R}_{\gamma(p_{SEG})} \mathbf{R}_{\beta(p_{SEG})} \mathbf{R}_{\alpha(p_{SEG})} \end{align*} \]
</p>
<p>where</p>
<p class="formulaDsp">
\[ \begin{align*} \mathbf{R}_{\gamma(p_{SEG})} &amp;= \left(\begin{array}{rrr} \cos\gamma &amp; -\sin\gamma &amp; 0 \\ \sin\gamma &amp; \cos\gamma &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array}\right) &amp; \text{(yaw)}\\ \end{align*} \]
</p>
<p class="formulaDsp">
\[ \begin{align*} \mathbf{R}_{\beta(p_{SEG})} &amp;= \left(\begin{array}{rrr} \cos\beta &amp; 0 &amp; \sin\beta \\ 0 &amp; 1 &amp; 0 \\ -\sin\beta &amp; 0 &amp; \cos\beta \end{array}\right) &amp; \text{(pitch)} \\ \end{align*} \]
</p>
<p class="formulaDsp">
\[ \begin{align*} \mathbf{R}_{\alpha(p_{SEG})} &amp;= \left(\begin{array}{rrr} 1 &amp; 0 &amp; 0 \\ 0 &amp; \cos\alpha &amp; -\sin\alpha \\ 0 &amp; \sin\alpha &amp; \cos\alpha \end{array}\right) &amp; \text{(roll)} \end{align*} \]
</p>
<p>and</p>
<p class="formulaDsp">
\[ \begin{align*} \gamma(p_{SEG}) &amp;= \mathrm{atan2}\negthickspace\left(\frac{dG_y}{dp_{SEG}}, \frac{dG_x}{dp_{SEG}}\right) &amp; \text{(yaw)}\\ \beta(p_{SEG}) &amp;= \arctan\negthickspace\left(\frac{dG_z} {dp_{SEG}}\right) &amp; \text{(pitch)} \\ \alpha(p_{SEG}) &amp;= l_\text{max}\Theta(p_{SEG}) &amp; \text{(roll)} \end{align*} \]
</p>
<blockquote class="doxtable">
<p>Note that \(\hat{p}_{SEG}\) is solely determined by \(W(p_{SEG})\), and as expected, \(\hat{p}_{SEG} = \frac{W&#39;(p_{SEG})}{\lVert W&#39;(p_{SEG})\rVert}\). </p>
</blockquote>
<p>With \(\mathbf{R}(p_{SEG})\) , we can extend the <code>Segment</code> reference curve \(W(p_{SEG})\) to construct the <code>Segment</code> <em>surface</em> \(W(p_{SEG}, r_{SEG})\) as:</p>
<p class="formulaDsp">
\[ \begin{align*} \left(\begin{array}{c}x\\y\\z\end{array}\right) = W(p_{SEG},r_{SEG}) = \left( \begin{array}{c} G_{xy}(p_{SEG})\\ l_\text{max} G_z(p_{SEG}) \end{array} \right) + \mathbf{R}(p_{SEG})\negthickspace \begin{pmatrix} 0\\ r_{SEG} \\ 0 \end{pmatrix}. \end{align*} \]
</p>
<p>This function defines a <em>ruled surface</em>. For any \(p_{SEG}\), \(W(p_{SEG},r_{SEG})\) is linear in \(r_{SEG}\) and motion along \(r_{SEG}\) is in a straight line.</p>
<p>Now that we have the surface embedding \(W(p_{SEG},r_{SEG})\), we can derive the basis vectors \((\hat{p}, \hat{r}, \hat{h})_{SEG}\) along the surface and the corresponding orientation \(\mathbf{R}(p_{SEG},r_{SEG})\):</p>
<p class="formulaDsp">
\[ \begin{align*} \mathbf{R}(p_{SEG},r_{SEG}) &amp;= \begin{pmatrix}\hat{p} &amp; \hat{r} &amp; \hat{h}\end{pmatrix}\\ \hat{p}_{SEG} &amp;= \frac{\partial_{p_{SEG}} W(p_{SEG},r_{SEG})}{\lVert\partial_{p_{SEG}} W(p_{SEG},r_{SEG})\rVert}\\ \hat{r}_{SEG} &amp;= \frac{\partial_{r_{SEG}} W(p_{SEG},r_{SEG})}{\lVert\partial_{r_{SEG}} W(p_{SEG},r_{SEG})\rVert}\\ \hat{h}_{SEG} &amp;= \hat{p}_{SEG} \times \hat{r}_{SEG} \end{align*} \]
</p>
<p>A few things are worth noting at this point:</p>
<ul>
<li>\(\hat{r}_{SEG} = \mathbf{R}(p_{SEG}) \begin{pmatrix}0\\1\\0\end{pmatrix}\). Thus, \(\hat{r}_{SEG}\) is independent of \(r_{SEG}\).</li>
<li>\(\mathbf{R}(p_{SEG},r_{SEG}) = \mathbf{R}(p_{SEG})\) along \(r_{SEG} = 0\) just as it should be; the orientation along the <code>Segment</code>'s reference curve is consistent in both expressions.</li>
<li>\(\hat{p}_{SEG}\) is <em>not necessarily</em> independent of \(r_{SEG}\). Consequently, \(\mathbf{R}(p_{SEG},r_{SEG})\) is not necessarily equal to \(\mathbf{R}(p_{SEG})\) for \(r_{SEG}\ne 0\). This will become important when we try to join <code>Segments</code> end-to-end preserving \(G^1\) continuity, discussed in section <a class="el" href="multilane_design.html#ensuring_g1_contiguity">Ensuring G¹ Continuity</a> .</li>
</ul>
<p><em>Finally</em>, with \(\mathbf{R}(p_{SEG},r_{SEG})\) in hand (and points 1 and 2 above), we can define the complete volumetric world map \(W(p_{SEG},r_{SEG},h_{SEG})\) for a <code>Segment</code>'s geometry:</p>
<p class="formulaDsp">
\[ \begin{align*} \begin{pmatrix}x\\y\\z\end{pmatrix} = W(p_{SEG},r_{SEG},h_{SEG}) = \left( \begin{array}{c} G_x(p_{SEG})\\ G_y(p_{SEG})\\ l_\text{max} G_z(p_{SEG}) \end{array} \right) + \mathbf{R}(p_{SEG},r_{SEG})\negthickspace \begin{pmatrix} 0\\ r_{SEG} \\ h_{SEG} \end{pmatrix}. \end{align*} \]
</p>
<p>This is simply \(W(p_{SEG},r_{SEG})\) displaced by \(h_{SEG}\) along the surface normal \(\hat{h}_{SEG}\).</p>
<h2><a class="anchor" id="lane_geometry"></a>
&lt;tt&gt;Lane&lt;/tt&gt; Geometry</h2>
<p>A <code>Lane</code> derives its geometry from its <code>Segment</code>. In <code>multilane</code>, the centerline of the <code>Lane</code> with index \(i\) is a parallel curve with a constant lateral offset \(r_i\) from the reference curve (at \(r_{SEG} = 0\)) of the <code>Segment</code>. We can express this relationship as a transform between \((s,r,h)_{LANE,i}\) (<code>Lane</code>-frame) and \((p,r,h)_{SEG}\) (<code>Segment</code>-frame):</p>
<p class="formulaDsp">
\[ \begin{align*} \begin{pmatrix} p_{SEG}\\ r_{SEG}\\ h_{SEG} \end{pmatrix} &amp;= \begin{pmatrix} P(s_{LANE,i})\\ r_{LANE,i} + r_i\\ h_{LANE,i} \end{pmatrix} \end{align*} \]
</p>
<p>The tricky part here is \(P:s_{LANE,i} \mapsto p_{SEG}\), which relates \(s_{LANE,i}\) to \(p_{SEG}\), and involves the path-length integral over \(W(p_{SEG},r_{SEG})\).</p>
<p><code>maliput</code> defines \(s_{LANE,i}\) as the path-length along a <code>Lane</code>'s centerline, and in <code>multilane</code> that centerline is a curve with constant \(r_{SEG} = r_i\). Thus:</p>
<p class="formulaDsp">
\[ \begin{align*} s_{LANE,i} = S(p_{SEG}) &amp;= \left. \int \left\lVert \partial_{p_{SEG}}W(p_{SEG}, r_{SEG}) \right\rVert dp_{SEG} \right\rvert_{r_{SEG} = r_i}. \end{align*} \]
</p>
<p>The function \(P\) that we need is the inverse of the path-integral \(S\).</p>
<p>Unfortunately, there is generally no closed-form solution for either \(S\) or \(P\), particularly if the surface is not flat. <code>multilane</code> will compute \(P(s_{LANE,i})\) and \(S(p_{SEG})\) analytically if possible (e.g., for some flat surfaces) and otherwise will use more costly numerical methods to ensure accurate results. Which makes us wonder, perhaps the <code>Lane</code>-frame of <code>maliput</code> would be better off using an arbitrary longitudinal parameter \(p_{LANE,i}\) which could be converted to a distance \(s_{LANE,i}\) on demand, instead of the other way around.</p>
<blockquote class="doxtable">
<p>TODO: Derivation of orientation at arbitrary \((s,r,h)_{LANE,i}\) point.</p>
<p>TODO: Derivation of motion-derivatives.</p>
<p>TODO: Derivation of surface/path curvatures. </p>
</blockquote>
<h3>Available Implementations of \(G_\text{xy}\), \(G_z\), and \(\Theta\)</h3>
<p><code>multilane</code> currently implements one form for each of \(G_{xy}\), \(G_z\), and \(\Theta\). \(G_{xy}\) is implemented for a constant curvature arc (which includes zero curvature, i.e., straight line segments). Elevation \(G_z\) and superelevation \(\Theta\) are implemented for cubic polynomials. These forms were chosen because they provide the smallest, simplest set of primitives that allow for the assembly of fully three-dimensional road networks that maintain \(G^1\) continuity across segment boundaries.</p>
<p>The exact form that \(G_{xy}\) takes is:</p>
<p class="formulaDsp">
\[ \begin{align*} \begin{pmatrix} x\\ y \end{pmatrix} = G_\text{xy}(p_{SEG}) &amp;= \begin{pmatrix}x_0\\ y_0\end{pmatrix} + \left\lbrace \begin{array} \frac{1}{\kappa}\begin{pmatrix} \cos(\kappa l_\text{max} p_{SEG} + \gamma_0 - \frac{\pi}{2}) - \cos(\gamma_0 - \frac{\pi}{2})\\ \sin(\kappa l_\text{max} p_{SEG} + \gamma_0 - \frac{\pi}{2}) - \sin(\gamma_0 - \frac{\pi}{2}) \end{pmatrix} &amp; \text{for }\kappa &gt; 0\\ l_\text{max} p_{SEG} \begin{pmatrix}\cos{\gamma_0}\\ \sin{\gamma_0}\end{pmatrix} &amp; \text{for }\kappa = 0\\ \frac{1}{\kappa}\begin{pmatrix} \cos(\kappa l_\text{max} p_{SEG} + \gamma_0 + \frac{\pi}{2}) - \cos(\gamma_0 + \frac{\pi}{2})\\ \sin(\kappa l_\text{max} p_{SEG} + \gamma_0 + \frac{\pi}{2}) - \sin(\gamma_0 + \frac{\pi}{2}) \end{pmatrix} &amp; \text{for }\kappa &lt; 0\\ \end{array} \right\rbrace \end{align*} \]
</p>
<p>where \(\kappa\) is the signed curvature (positive is counterclockwise/leftward), \(l_\text{max}\) is the arc length, \(\begin{pmatrix}x_0\\y_0\end{pmatrix}\) is the starting point of the arc, and \(\gamma_0\) is the initial yaw of the (tangent) of the arc (with \(\gamma_0 = 0\) in the \(+\hat{x}\) direction). Note that the \(\kappa = 0\) expression is simply a line segment of length \(l_\text{max}\), and it is the limit of the \(\kappa \neq 0\) expressions as \(\kappa \to 0\).</p>
<p>With regards to geometric road design, a constant curvature \(G_\text{xy}\) does not provide a complete toolkit. Most road designs involve clothoid spirals, which are plane curves with curvature that is /linear/ in path length.This is so that vehicles can navigate roads using continuous changes in steering angle, and, likewise, so that their occupants will experience continuous changes in radial acceleration. <code>multilane</code> is expected to extend support for clothoid \(G_\text{xy}\) in the future.</p>
<p>For \(G_z\) and \(\Theta\), a cubic polynomial is the lowest-degree polynomial which allows for independently specifying the value and the first derivative at both endpoints. Thus, \(G_z\) takes the form:</p>
<p class="formulaDsp">
\[ \begin{align*} \begin{split} \frac{1}{l_\text{max}}z = G_z(p_{SEG}) &amp;= \frac{z_0}{l_\text{max}} + \dot{z_0} p_{SEG} + \left(\frac{3(z_1 - z_0)}{l_\text{max}} - 2\dot{z_0} - \dot{z_1}\right) p_{SEG}^2 \\ &amp;\quad + \left(\dot{z_0} + \dot{z_1} - \frac{2(z_1 - z_0)}{l_\text{max}}\right) p_{SEG}^3 \end{split} \end{align*} \]
</p>
<p>where \(z_0\) and \(z_1\) are the initial and final elevation respectively, and \(\dot{z_0}\) and \(\dot{z_1}\) are the initial and final \(\frac{dz}{dl}\), which is simply the slope of the road as measured by the intuitive "rise over run". \(\Theta\) has an identical expression, with every \(z\) replaced by \(\theta\). Note that \(\dot{\theta} = \frac{d\theta}{dl}\), the rate of twisting of the road, is not particularly intuitive, but that's ok because in general \(\dot{\theta_0}\) and \(\dot{\theta_1}\) will be set by <code>multilane</code> and not by the road designer, as we will see in section <a class="el" href="multilane_design.html#ensuring_g1_contiguity">Ensuring G¹ Continuity</a> .</p>
<h2><a class="anchor" id="ensuring_g1_contiguity"></a>
Ensuring G¹ Continuity</h2>
<blockquote class="doxtable">
<p>TODO: Tell me more! </p>
</blockquote>
<h2><a class="anchor" id="builder_helper_interface"></a>
&lt;tt&gt;Builder&lt;/tt&gt; helper interface</h2>
<p>Users are not expected to assemble a <code>multilane::RoadGeometry</code> by constructing individual instances of <code>multilane::Lane</code>, etc, by hand. Instead, <code>multilane</code> provides a <code>Builder</code> interface which handles many of the constraints involved in constructing a valid <code>RoadGeometry</code>.</p>
<blockquote class="doxtable">
<p>TODO: Tell me more! </p>
</blockquote>
<h2><a class="anchor" id="yaml_file_format"></a>
YAML file format</h2>
<p>Multilane provides two loader methods ( <a class="el" href="namespacemaliput_1_1multilane.html#a034a42c5b4901fd03dd3ada497c1cf65">Load()</a> and <a class="el" href="namespacemaliput_1_1multilane.html#a2eabcbf6793594cc9cc5832b3c13545d">LoadFile()</a> ) that will parse a <a class="elRef" href="../../maliput/html/namespace_y_a_m_l.html">YAML</a> file or string by calling appropriate <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> methods to create a <code>RoadGeometry</code>.</p>
<p>The serialization is a fairly straightforward mapping of the <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> interface onto <a class="elRef" href="../../maliput/html/namespace_y_a_m_l.html">YAML</a>.</p>
<p>The basic idea is, however:</p>
<ul>
<li>general parameters (i.e., lane_width, elevation bounds, linear and angular tolerance)</li>
<li>a collection of named 'points', which are specifications of explicitly named Endpoints</li>
<li>a collection of named 'connections', whose start Endpoints are specified by reference to either a named Endpoint or the start or end of a named Connection</li>
<li>a collection of named 'groups', specified by sequences of named Connections</li>
</ul>
<p>Parsing will fail if there is no way to concretely resolve all of the Endpoint references, e.g., if a document specifies that Connection-A is an arc starting at the end of Connection-B and that Connection-B is an arc starting at the end of Connection-A. All referential chains must bottom out in explicitly-named Endpoints.</p>
<h3><a class="anchor" id="general_considerations"></a>
General considerations</h3>
<p>All the road geometry information must be under a root node called <code>maliput_multilane_builder</code>, otherwise it will not be parsed.</p>
<h4>Units</h4>
<p>The following list shows the expected units for floating-point quantities:</p>
<ul>
<li>Positions, distances and lengths: meters [m].</li>
<li>Angles: degrees [°] (no minutes nor seconds, just degrees).</li>
<li>Derivatives of positions: meters per meter [m/m] (i.e., a unitless slope).</li>
<li>Derivatives of angles: degrees per meter [°/m].</li>
</ul>
<p>All positions, distances, lengths, angles and derivatives are floating point numbers. Other type of quantities will be integers.</p>
<h4>Miscellaneous</h4>
<p>Clarifications to better understand the nomenclature used within this description:</p>
<ul>
<li>In code snippets, strings in capital letters represent values that the <a class="elRef" href="../../maliput/html/namespace_y_a_m_l.html">YAML</a> writer must choose and the others are keywords to be parsed.</li>
<li>When referring to keywords in the <a class="elRef" href="../../maliput/html/namespace_y_a_m_l.html">YAML</a>, <code>non-capitalized</code> strings will be used.</li>
<li>When referring to types within <code>maliput</code>, <code>Capitalized</code> strings will be used.</li>
</ul>
<h4>Coordinates and frames</h4>
<p>For points in space, a right handed, orthonormal and inertial ℝ³ frame is used. Its basis is (x̂, ŷ, ẑ), where x̂, ŷ are coplanar with the ground and ẑ points upwards, and positions are expressed as <code>(x, y, z)</code> triples. Also, the Θ angle rotating around the ẑ axis is used to define headings. These rotations are right handed and an angle of 0° points in the x̂ direction. Angles with respect to a plane parallel to <code>z = 0</code> can be defined. A heading vector pointing the direction of the lane at that point is used as rotation axis and the angle is clockwise. Those will express superelevation.</p>
<h3><a class="anchor" id="example_of_general_structure"></a>
Example of General Structure</h3>
<p>Below you can see a snippet with the general <a class="elRef" href="../../maliput/html/namespace_y_a_m_l.html">YAML</a> structure.</p>
<div class="fragment"><div class="line">maliput_multilane_builder:</div>
<div class="line"> id: &quot;my_road_geometry&quot;</div>
<div class="line"> lane_width: 3.2</div>
<div class="line"> left_shoulder: 1.25</div>
<div class="line"> right_shoulder: 2.47</div>
<div class="line"> elevation_bounds: [0., 7.6]</div>
<div class="line"> scale_length: 1.</div>
<div class="line"> linear_tolerance: 0.1</div>
<div class="line"> angular_tolerance: 0.1</div>
<div class="line"> computation_policy: prefer-accuracy</div>
<div class="line"> points:</div>
<div class="line">   point_a:</div>
<div class="line">     xypoint: [0, 0, 0]</div>
<div class="line">     zpoint: [0, 0, 0, 0]</div>
<div class="line">   point_b:</div>
<div class="line">     xypoint: [50, 5, 0]</div>
<div class="line">     zpoint: [0, 0, 0]</div>
<div class="line">   ...</div>
<div class="line"> connections:</div>
<div class="line">   conn_a:</div>
<div class="line">      left_shoulder: 1.3 # Optional</div>
<div class="line">      lanes: [3, 2, -5.3]</div>
<div class="line">      start: [&quot;lane.1&quot;, &quot;points.point_a.forward&quot;]</div>
<div class="line">      arc: [30.25, -45]</div>
<div class="line">      z_end: [&quot;lane.0&quot;, [0, 3, 30, 3.1]]</div>
<div class="line">   conn_b:</div>
<div class="line">   ...</div>
<div class="line"> groups:</div>
<div class="line">   group_A: [conn_a, conn_b]</div>
</div><!-- fragment --><h3><a class="anchor" id="entities"></a>
Entities</h3>
<h4><code>maliput_multilane_builder</code></h4>
<p><code>maliput_multilane_builder</code> holds all the common and default configurations to build a <code>RoadGeometry</code>. All of them, except <code>groups</code>, must be defined though some of them may be empty.</p>
<p>It will be represented as a mapping:</p>
<div class="fragment"><div class="line">maliput_multilane_builder:</div>
<div class="line"> id: &quot;ID&quot;</div>
<div class="line"> lane_width: LW</div>
<div class="line"> left_shoulder: LS</div>
<div class="line"> right_shoulder: RS</div>
<div class="line"> elevation_bounds: [EB_MIN, EB_MAX]</div>
<div class="line"> linear_tolerance: LT</div>
<div class="line"> angular_tolerance: AT</div>
<div class="line"> scale_length: SL</div>
<div class="line"> computation_policy: CP</div>
<div class="line"> points:</div>
<div class="line">   ...</div>
<div class="line"> connections:</div>
<div class="line">   ...</div>
<div class="line"> groups:</div>
<div class="line">   ...</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><em>ID</em> is a string scalar that defines the <em>ID</em> of the <code>RoadGeometry</code>.</li>
<li><em>LW</em> is the width of the lanes. Lane’s centerline will be placed at the same lane width distance one from the other. It must be non negative.</li>
<li><em>LS</em> and <em>RS</em> are default left and right shoulders are extra spaces added to the right of the last lane and left to the first lane respectively. Their purpose is to increase segment bounds. Both must be non negative.</li>
<li><em>EB_MIN</em> and <em>EB_MAX</em> define minimum and maximum height values of the road’s volume. The minimum value must be non positive, thus the maximum must be non negative.</li>
<li><em>LT</em> and <em>AT</em> are position and orientation tolerances which are non negative numbers that define the error of mapping a world coordinate or orientation in a custom lane-frame.</li>
<li><em>SL</em> is the minimum spatial period of variation in <code>connections</code>' reference curve.</li>
<li>A <em>CP</em> label, which could either be <code>prefer-accuracy</code> or <code>prefer-speed</code> The former guides the computations to be as accurate as precision states. The latter will be accurate whenever possible, but it's not guaranteed in favor of faster computations.</li>
<li><em>points</em> is a map of <code>endpoint</code>s to build <code>connection</code>s. At least one point is required to anchor the connections to world-frame.</li>
<li><em>connections</em> is a map that holds all the <code>connection</code> definitions. It may be empty if no <code>Connection</code> is going to be defined.</li>
<li><em>groups</em> is a map of <code>groups</code> where <code>connections</code> can be put together. It may be empty or not defined if no group is going to be made.</li>
</ul>
<h4><code>points</code></h4>
<p>A collection of points in 3D space. Each one will be under a tag (used to reference it within <code>connection</code> description) and defined by an <code>endpoint_xy</code> and a <code>endpoint_z</code>. Both sequences must be provided.</p>
<p>It will be represented as a mapping like:</p>
<div class="fragment"><div class="line">endpoint:</div>
<div class="line">  xypoint: [X, Y, THETHA]</div>
<div class="line">  zpoint: [Z, Z_DOT, THETA, THETA_DOT]</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><code>xypoint</code> is the <code>endpoint_xy</code> sequence.</li>
<li><code>zpoint</code> is the <code>endpoint_z</code> sequence.</li>
</ul>
<h4><code>endpoint_xy</code></h4>
<p>A point in the plane <code>z = 0</code> expressed as <code>(x, y, Θ)</code>, where <code>(x, y)</code> defines the position and Θ defines the heading angle of the endpoint. All coordinates must be provided.</p>
<p>It will be represented as a sequence:</p>
<div class="fragment"><div class="line">endpoint_xy: [X, Y, THETA]</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><em>X</em> is the <code>x</code> coordinate.</li>
<li><em>Y</em> is the <code>y</code> coordinate.</li>
<li><em>THETA</em> is the Θ coordinate.</li>
</ul>
<h4><code>endpoint_z</code></h4>
<p>Specifies elevation, slope, superelevation and its speed of change at a point over the plane <code>z = 0</code> as &lsquo;(z, z&rsquo;, Θ, Θ')<code>, where</code>z&lsquo; and Θ&rsquo; are the elevation and superelevation of the road at the endpoint and &lsquo;z&rsquo;&lsquo; and Θ&rsquo; are their respective derivatives with respect to an arc-length coordinate <code>t</code> that travels along curve’s projection over the <code>z = 0</code> plane. All coordinates must be provided.</p>
<p>It will be represented as a sequence:</p>
<div class="fragment"><div class="line">endpoint_z: [Z, Z_DOT, THETA, THETA_DOT]</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><em>Z</em> is the <code>z</code> coordinate.</li>
<li><em>Z_DOT</em> is the <code>z′</code> coordinate.</li>
<li><em>THETA</em> is the Θ coordinate.</li>
<li><em>THETA_DOT</em> is the Θ′ coordinate. This parameter is optional, and typically should be omitted. When omitted, this value will be automatically calculated such that <em>G1</em> continuity of the road surface is preserved.</li>
</ul>
<h4><code>connections</code></h4>
<p>A <code>connection</code> defines a <code>Segment</code> and must provide the number of lanes, start <code>endpoint</code> and end <code>endpoint_z</code> information. Either line <code>length</code> or <code>arc</code> must be provided to define the planar geometry of that <code>connection</code>. Optional extra information can also be provided and it will modify the way the <code>connection</code> will be created. <code>connections</code> is a collection of <code>connection</code>s and those will be identified by their tag. Each tag will name a <code>connection</code>, can be referenced by other <code>connection</code>s and to create <code>group</code>s, and will be used as <code>Segment</code>'s ID as well.</p>
<p><code>start</code> <code>endpoint</code> and <code>end</code> <code>endpoint_z</code> can either refer to a reference road curve or to the lane start and end <code>Endpoint</code>s. When only <code>start</code> and <code>z_end</code> or <code>explicit_end</code> are provided, those will refer to the reference road curve of the <code>Connection</code>. <code>r_ref</code> can be provided to state the offset distance from the reference road curve to <code>ref_lane</code> <code>connection</code>’s lane. Lanes are 0-indexed. In addition, left and right shoulder distances can be provided and those will override default values. <code>left_shoulder</code> and <code>right_shoulder</code> must be bigger or equal to zero if provided.</p>
<p>Sample line-connections mapping are shown below:</p>
<ul>
<li>Example 1: reference curve from points.</li>
</ul>
<div class="fragment"><div class="line">CONNECTION_NAME:</div>
<div class="line">  left_shoulder: LS</div>
<div class="line">  right_shoulder: RS</div>
<div class="line">  lanes: [NL, NREF, RREF]</div>
<div class="line">  start: [&quot;ref&quot;, &quot;points.POINT_NAME_1.(forward|reverse)&quot;]</div>
<div class="line">  length: L</div>
<div class="line">  z_end: [&quot;ref&quot;, [Z, Z_DOT, THETA, THETA_DOT]]</div>
<div class="line">  # The following can be used instead of z_end:</div>
<div class="line">  # explicit_end: [&quot;ref&quot;, &quot;points.POINT_NAME_2.(forward|reverse)&quot;]</div>
</div><!-- fragment --><p>Within <code>z_end</code>, <em>THETA_DOT</em> is optional, and typically should be omitted. When omitted, this value will be automatically calculated such that <em>G1</em> continuity of the road surface is preserved. Otherwise, provided <em>THETA_DOT</em> will be used and the <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> will check whether or not <em>G1</em> is preserved.</p>
<p>When <code>explicit_end</code> is used, <em>THETA_DOT</em> will be set by <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> to preserve <em>G1</em> road surface continuity.</p>
<ul>
<li>Example 2: reference curve from connections.</li>
</ul>
<div class="fragment"><div class="line">CONNECTION_NAME:</div>
<div class="line">  left_shoulder: LS</div>
<div class="line">  right_shoulder: RS</div>
<div class="line">  lanes: [NL, NREF, RREF]</div>
<div class="line">  start: [</div>
<div class="line">    &quot;ref&quot;,</div>
<div class="line">    &quot;connections.CONN_NAME_1.(start|end).ref.(forward|reverse)&quot;</div>
<div class="line">  ]</div>
<div class="line">  length: L</div>
<div class="line">  explicit_end: [</div>
<div class="line">    &quot;ref&quot;,</div>
<div class="line">    &quot;connections.CONN_NAME_2.(start|end).ref.(forward|reverse)&quot;</div>
<div class="line">  ]</div>
<div class="line">  # The following can be used instead of explicit_end:</div>
<div class="line">  # z_end: [&quot;ref&quot;, [Z, Z_DOT, THETA, THETA_DOT]]</div>
</div><!-- fragment --><p>Within <code>z_end</code>, <em>THETA_DOT</em> is optional, and typically should be omitted. When omitted, this value will be automatically calculated such that <em>G1</em> continuity of the road surface is preserved. Otherwise, provided <em>THETA_DOT</em> will be used and the <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> will check whether or not <em>G1</em> is preserved.</p>
<p>When <code>explicit_end</code> is used, <em>THETA_DOT</em> will be set by <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> to preserve <em>G1</em> continuity of the road surface.</p>
<ul>
<li>Example 3: lane curve from points.</li>
</ul>
<div class="fragment"><div class="line">CONNECTION_NAME:</div>
<div class="line">  left_shoulder: LS</div>
<div class="line">  right_shoulder: RS</div>
<div class="line">  lanes: [NL, NREF, RREF]</div>
<div class="line">  start: [&quot;lane.LN_1&quot;, &quot;points.POINT_NAME_1.(forward|reverse)&quot;]</div>
<div class="line">  length: L</div>
<div class="line">  z_end: [&quot;lane.LN_2&quot;, [Z, Z_DOT, THETA]]</div>
<div class="line">  # The following can be used instead of z_end:</div>
<div class="line">  # explicit_end: [&quot;lane.LN_2&quot;, &quot;points.POINT_NAME_2.(forward|reverse)&quot;]</div>
</div><!-- fragment --><p>None of the lane-based flavors allow to have <em>THETA_DOT</em> at either <code>start</code> or <code>z_end</code>. <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> will adjust them to preserve <em>G1</em> continuity of the road surface.</p>
<ul>
<li>Example 4: lane curve from other connections' lane curves.</li>
</ul>
<div class="fragment"><div class="line">CONNECTION_NAME:</div>
<div class="line">  left_shoulder: LS</div>
<div class="line">  right_shoulder: RS</div>
<div class="line">  lanes: [NL, NREF, RREF]</div>
<div class="line">  start: [</div>
<div class="line">    &quot;lane.LN_1&quot;,</div>
<div class="line">    &quot;connections.CONN_NAME_1.(start|end).LN_2.(forward|reverse)&quot;</div>
<div class="line">  ]</div>
<div class="line">  length: L</div>
<div class="line">  explicit_end: [</div>
<div class="line">    &quot;lane.LN_2&quot;,</div>
<div class="line">    &quot;connections.CONN_NAME_2.(start|end).LN_4.(forward|reverse)&quot;</div>
<div class="line">  ]</div>
<div class="line">  # The following can be used instead of explicit_end:</div>
<div class="line">  # z_end: [&quot;lane.LN_2&quot;, [Z, Z_DOT, THETA]]</div>
</div><!-- fragment --><p>None of the lane-based flavors allow to have <em>THETA_DOT</em> at either <code>start</code> or <code>z_end</code>. <a class="el" href="classmaliput_1_1multilane_1_1_builder.html">Builder</a> will adjust them to preserve <em>G1</em> continuity of the road surface.</p>
<p>From examples above:</p>
<ul>
<li><code>lanes</code> holds number of lanes, reference lane and distance from the reference lane to the reference curve.</li>
<li><code>left_shoulder</code> is the extra space at the right side of the last lane of the connection. It will override default values.</li>
<li><code>right_shoulder</code> is the extra space at the left side of the first lane of the <code>connection</code>. It will override default values.</li>
<li><code>start</code> is used to define the start <code>endpoint</code> of one the <code>connection</code>’s curves. It may have multiple options. Those can be split into two elements:<ul>
<li>The first element could be:<ol type="1">
<li><code>ref</code> to point the reference curve.</li>
<li><code>lane.LN</code> to point a specific lane.<br  />
</li>
</ol>
</li>
<li>The second element is composed of one of the following options:<ol type="1">
<li>A reference to an <code>endpoint</code> in the points collection. Either <code>forward</code> or <code>reverse</code> should be used to indicate the direction of the <code>endpoint</code>.</li>
<li>The start or end <code>endpoint</code> of a <code>connection</code>’s reference curve or lane. Either forward or reverse should be used to indicate the direction of the <code>endpoint</code>. When using the forward the <code>endpoint</code> will be used as is. Otherwise (using <code>reverse</code>) the <code>Endpoint</code> will be reversed.</li>
</ol>
</li>
</ul>
</li>
<li><code>length</code> is the <code>connection</code>’s reference road curve planar line length.</li>
<li><code>arc</code> is the <code>connection</code>’s reference curve planar piece of arc.</li>
<li><code>z_end</code> is the <code>endpoint_z</code> information to end one of the <code>connection</code>’s curves. It is composed of two elements too. The first one points to the reference curve when <code>ref</code> is present. Otherwise, <code>lane.LN</code> must be specified.</li>
<li><code>explicit_end</code> is a node similar to <code>start</code>. It is composed of two parts. The first one points to the reference curve when <code>ref</code> is present. Otherwise, <code>lane.LN</code> must be specified. The second part is used to point the <code>endpoint</code> information which could be provided by a <code>connection</code> or the <code>points</code> collection. When using a <code>connection</code>, two options are available: the reference curve or a lane.</li>
</ul>
<p>Possible combinations to define a <code>connection</code> node are:</p>
<ul>
<li>Each <code>connection</code> must have either <code>length</code> or <code>arc</code>.</li>
<li>Each <code>connection</code> must have either <code>z_end</code> or <code>explicit_end</code>.</li>
<li><code>start</code> and <code>explicit_end</code> possible combinations:<ol type="1">
<li>This LANE from other LANE.</li>
<li>This REF from other REF.</li>
<li>This LANE from POINT.</li>
<li>This REF from POINT.</li>
</ol>
</li>
</ul>
<p>At least one connection must <em>start</em> with "LANE from POINT" or "REF from
POINT" in order to anchor the road geometry in the world frame.</p>
<h4><code>arc</code></h4>
<p>Constant radius arcs are defined in terms of a radius and an angle span. <code>arc</code>s are used to define planar curves on the the <code>z = 0</code> plane, starting from an <code>endpoint_xy</code>. Radius must be positive, and arc's center would be to the left (i.e. rotating +90° start <code>endpoint_xy</code>’s heading vector) when theta is positive, otherwise it would be to the right (i.e. rotating -90° start <code>endpoint_xy</code>’s heading).</p>
<p>It will be represented as a sequence:</p>
<div class="fragment"><div class="line">arc: [RADIUS, THETA]</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><em>RADIUS</em> is the radius of the <code>arc</code>.</li>
<li><em>THETA</em> is the angle span of the <code>arc</code>.</li>
</ul>
<h4><code>groups</code></h4>
<p>A group specifies a set of connections whose Segments will be placed together in the same <code>Junction</code>. A <code>connection</code> may only belong to a single <code>group</code>. If a <code>connection</code> is not in any <code>group</code>, its <code>Segment</code> will receive its own <code>Junction</code>.</p>
<p>It will be represented as a mapping:</p>
<div class="fragment"><div class="line">GROUP_NAME: [C_1, C_2, C_3]</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><code>C_1</code>, <code>C_2</code>, <code>C_3</code> are <code>connections</code>’ IDs. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

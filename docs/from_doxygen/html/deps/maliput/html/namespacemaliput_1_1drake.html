<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput: maliput::drake Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemaliput_1_1drake.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">maliput::drake Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemaliput_1_1drake_1_1assert"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake_1_1assert.html">assert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1drake_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1drake_1_1logging"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake_1_1logging.html">logging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1drake_1_1systems"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html">systems</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemaliput_1_1drake_1_1trajectories"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake_1_1trajectories.html">trajectories</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully type-erased container class.  <a href="classmaliput_1_1drake_1_1_abstract_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer with deep copy semantics.  <a href="classmaliput_1_1drake_1_1copyable__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1_delegating_hasher.html">DelegatingHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter that forwards the HashAlgorithm::operator(data, length) function concept into a runtime-provided std::function of the same signature.  <a href="structmaliput_1_1drake_1_1_delegating_hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1dummy__value.html">dummy_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a "dummy" value for a ScalarType &ndash; a value that is unlikely to be mistaken for a purposefully-computed value, useful for initializing a value before the true result is available.  <a href="structmaliput_1_1drake_1_1dummy__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1dummy__value_3_01int_01_4.html">dummy_value&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_eigen_ptr.html">EigenPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This wrapper class provides a way to write non-template functions taking raw pointers to Eigen objects as parameters while limiting the number of copies, similar to <code>Eigen::Ref</code>.  <a href="classmaliput_1_1drake_1_1_eigen_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_dynamic.html">EigenSizeMinPreferDynamic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_dynamic.html#adfbd84e9619cf3366fb744d3f70c8c23">EigenSizeMinPreferDynamic&lt;a, b&gt;::value</a> gives the min between compile-time sizes <code>a</code> and <code>b</code>.  <a href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_fixed.html">EigenSizeMinPreferFixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_fixed.html" title="EigenSizeMinPreferFixed is a variant of EigenSizeMinPreferDynamic.">EigenSizeMinPreferFixed</a> is a variant of <a class="el" href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_dynamic.html" title="EigenSizeMinPreferDynamic&lt;a, b&gt;::value gives the min between compile-time sizes a and b.">EigenSizeMinPreferDynamic</a>.  <a href="structmaliput_1_1drake_1_1_eigen_size_min_prefer_fixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_identifier.html">Identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple identifier class.  <a href="classmaliput_1_1drake_1_1_identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1is__eigen__nonvector__of.html">is_eigen_nonvector_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1is__eigen__type.html">is_eigen_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1is__eigen__vector.html">is_eigen_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1_multiply_eigen_sizes.html">MultiplyEigenSizes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MultiplyEigenSizes&lt;a, b&gt; gives a * b if both of a and b are fixed sizes.  <a href="structmaliput_1_1drake_1_1_multiply_eigen_sizes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1never__destroyed.html">never_destroyed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an underlying type T such that its storage is a direct member field of this object (i.e., without any indirection into the heap), but <em>unlike</em> most member fields T's destructor is never invoked.  <a href="classmaliput_1_1drake_1_1never__destroyed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_nice_type_name.html">NiceTypeName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains canonicalized, platform-independent, human-readable names for arbitrarily-complicated C++ types.  <a href="classmaliput_1_1drake_1_1_nice_type_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar multi-variate polynomial, modeled after the msspoly in spotless.  <a href="classmaliput_1_1drake_1_1_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_random_generator.html">RandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines Drake's canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a few conventional extras beyond the concept, e.g., seeds).  <a href="classmaliput_1_1drake_1_1_random_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1reset__on__copy.html">reset_on_copy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type wrapper that performs value-initialization on copy construction or assignment.  <a href="classmaliput_1_1drake_1_1reset__on__copy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1scalar__predicate.html">scalar_predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits struct that describes the return type of predicates over a scalar type (named <code>T</code>).  <a href="structmaliput_1_1drake_1_1scalar__predicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-safe non-negative index class.  <a href="classmaliput_1_1drake_1_1_type_safe_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1drake_1_1uhash.html">uhash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashing functor, somewhat like <code>std::hash</code>.  <a href="structmaliput_1_1drake_1_1uhash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1_value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class for an arbitrary type T (with some restrictions).  <a href="classmaliput_1_1drake_1_1_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1f1c657c4d2cf400649123a7c2573d5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f1c657c4d2cf400649123a7c2573d5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a> = typename <a class="el" href="structmaliput_1_1drake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a1f1c657c4d2cf400649123a7c2573d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a boolean-like value, conditioned on the scalar type <code>T</code>.  <a href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">More...</a><br /></td></tr>
<tr class="separator:a1f1c657c4d2cf400649123a7c2573d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13e10d823b0e212fdfb27cc8f18065a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ae13e10d823b0e212fdfb27cc8f18065a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ae13e10d823b0e212fdfb27cc8f18065a">eigen_aligned_std_map</a> = std::map&lt; Key, T, std::less&lt; Key &gt;, Eigen::aligned_allocator&lt; std::pair&lt; Key const, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ae13e10d823b0e212fdfb27cc8f18065a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::map that uses Eigen::aligned_allocator so that the contained types may be fixed-size Eigen values.  <a href="namespacemaliput_1_1drake.html#ae13e10d823b0e212fdfb27cc8f18065a">More...</a><br /></td></tr>
<tr class="separator:ae13e10d823b0e212fdfb27cc8f18065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcadf96d397f45d041d01bf17061bc32"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:afcadf96d397f45d041d01bf17061bc32"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#afcadf96d397f45d041d01bf17061bc32">eigen_aligned_std_unordered_map</a> = std::unordered_map&lt; Key, T, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, Eigen::aligned_allocator&lt; std::pair&lt; Key const, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:afcadf96d397f45d041d01bf17061bc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::unordered_map that uses Eigen::aligned_allocator so that the contained types may be fixed-size Eigen values.  <a href="namespacemaliput_1_1drake.html#afcadf96d397f45d041d01bf17061bc32">More...</a><br /></td></tr>
<tr class="separator:afcadf96d397f45d041d01bf17061bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4150555527b3cf871fe911f8776f301a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4150555527b3cf871fe911f8776f301a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a4150555527b3cf871fe911f8776f301a">eigen_aligned_std_vector</a> = std::vector&lt; T, Eigen::aligned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a4150555527b3cf871fe911f8776f301a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector that uses Eigen::aligned_allocator so that the contained types may be fixed-size Eigen values.  <a href="namespacemaliput_1_1drake.html#a4150555527b3cf871fe911f8776f301a">More...</a><br /></td></tr>
<tr class="separator:a4150555527b3cf871fe911f8776f301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda0b15d77e4c1701d160b17a2cb2ea8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acda0b15d77e4c1701d160b17a2cb2ea8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#acda0b15d77e4c1701d160b17a2cb2ea8">Vector0</a> = Eigen::Matrix&lt; Scalar, 0, 1 &gt;</td></tr>
<tr class="memdesc:acda0b15d77e4c1701d160b17a2cb2ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty column vector (zero rows, one column), templated on scalar type.  <a href="namespacemaliput_1_1drake.html#acda0b15d77e4c1701d160b17a2cb2ea8">More...</a><br /></td></tr>
<tr class="separator:acda0b15d77e4c1701d160b17a2cb2ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359dfdb84d6c13b606bb3ed7b821e23"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af359dfdb84d6c13b606bb3ed7b821e23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af359dfdb84d6c13b606bb3ed7b821e23">Vector1</a> = Eigen::Matrix&lt; Scalar, 1, 1 &gt;</td></tr>
<tr class="memdesc:af359dfdb84d6c13b606bb3ed7b821e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 1 (that is, a scalar), templated on scalar type.  <a href="namespacemaliput_1_1drake.html#af359dfdb84d6c13b606bb3ed7b821e23">More...</a><br /></td></tr>
<tr class="separator:af359dfdb84d6c13b606bb3ed7b821e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d923e79e6e92c2556edd86520145077"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a6d923e79e6e92c2556edd86520145077">Vector1d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 1, 1 &gt;</td></tr>
<tr class="memdesc:a6d923e79e6e92c2556edd86520145077"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 1 of doubles.  <a href="namespacemaliput_1_1drake.html#a6d923e79e6e92c2556edd86520145077">More...</a><br /></td></tr>
<tr class="separator:a6d923e79e6e92c2556edd86520145077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a> = Eigen::Matrix&lt; Scalar, 2, 1 &gt;</td></tr>
<tr class="memdesc:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 2, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#ab9f8b7dbd727440c2dd207bf43812f1e">More...</a><br /></td></tr>
<tr class="separator:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a> = Eigen::Matrix&lt; Scalar, 3, 1 &gt;</td></tr>
<tr class="memdesc:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 3, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a0ad29daab565ce347c4d1c5aae6a76c2">More...</a><br /></td></tr>
<tr class="separator:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e96394aef85f13f3fc84d3c3c238b3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af7e96394aef85f13f3fc84d3c3c238b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a> = Eigen::Matrix&lt; Scalar, 4, 1 &gt;</td></tr>
<tr class="memdesc:af7e96394aef85f13f3fc84d3c3c238b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 4, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#af7e96394aef85f13f3fc84d3c3c238b3">More...</a><br /></td></tr>
<tr class="separator:af7e96394aef85f13f3fc84d3c3c238b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa433aedda321a15238f2d4074d4c3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a14aa433aedda321a15238f2d4074d4c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a> = Eigen::Matrix&lt; Scalar, 6, 1 &gt;</td></tr>
<tr class="memdesc:a14aa433aedda321a15238f2d4074d4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 6.  <a href="namespacemaliput_1_1drake.html#a14aa433aedda321a15238f2d4074d4c3">More...</a><br /></td></tr>
<tr class="separator:a14aa433aedda321a15238f2d4074d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f103cf5fdeb3f539ceeeb9cd3a0a28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 6, 1 &gt;</td></tr>
<tr class="memdesc:a44f103cf5fdeb3f539ceeeb9cd3a0a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 6 of doubles.  <a href="namespacemaliput_1_1drake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">More...</a><br /></td></tr>
<tr class="separator:a44f103cf5fdeb3f539ceeeb9cd3a0a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ae662d5635b7c9efe03d15d976f7a8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int Rows&gt; </td></tr>
<tr class="memitem:a01ae662d5635b7c9efe03d15d976f7a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a> = Eigen::Matrix&lt; Scalar, Rows, 1 &gt;</td></tr>
<tr class="memdesc:a01ae662d5635b7c9efe03d15d976f7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector templated on the number of rows.  <a href="namespacemaliput_1_1drake.html#a01ae662d5635b7c9efe03d15d976f7a8">More...</a><br /></td></tr>
<tr class="separator:a01ae662d5635b7c9efe03d15d976f7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of any size, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">More...</a><br /></td></tr>
<tr class="separator:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbacdba0566fe8958cfafd659b4373f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:adfbacdba0566fe8958cfafd659b4373f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#adfbacdba0566fe8958cfafd659b4373f">VectorUpTo6</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1, 0, 6, 1 &gt;</td></tr>
<tr class="memdesc:adfbacdba0566fe8958cfafd659b4373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of dynamic size templated on scalar type, up to a maximum of 6 elements.  <a href="namespacemaliput_1_1drake.html#adfbacdba0566fe8958cfafd659b4373f">More...</a><br /></td></tr>
<tr class="separator:adfbacdba0566fe8958cfafd659b4373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54e1f7aa3341a5f6b305705452d9bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afc54e1f7aa3341a5f6b305705452d9bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#afc54e1f7aa3341a5f6b305705452d9bd">RowVector2</a> = Eigen::Matrix&lt; Scalar, 1, 2 &gt;</td></tr>
<tr class="memdesc:afc54e1f7aa3341a5f6b305705452d9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 2, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#afc54e1f7aa3341a5f6b305705452d9bd">More...</a><br /></td></tr>
<tr class="separator:afc54e1f7aa3341a5f6b305705452d9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aee4ae0d841ea1629551bf77fd5d9ec9e">RowVector3</a> = Eigen::Matrix&lt; Scalar, 1, 3 &gt;</td></tr>
<tr class="memdesc:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 3, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#aee4ae0d841ea1629551bf77fd5d9ec9e">More...</a><br /></td></tr>
<tr class="separator:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b373b2971391d9054b431d8a3e4b33"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aa9b373b2971391d9054b431d8a3e4b33"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aa9b373b2971391d9054b431d8a3e4b33">RowVector4</a> = Eigen::Matrix&lt; Scalar, 1, 4 &gt;</td></tr>
<tr class="memdesc:aa9b373b2971391d9054b431d8a3e4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 4, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#aa9b373b2971391d9054b431d8a3e4b33">More...</a><br /></td></tr>
<tr class="separator:aa9b373b2971391d9054b431d8a3e4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad88c2d704ccb2899d475d3ae05de14"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3ad88c2d704ccb2899d475d3ae05de14"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a3ad88c2d704ccb2899d475d3ae05de14">RowVector6</a> = Eigen::Matrix&lt; Scalar, 1, 6 &gt;</td></tr>
<tr class="memdesc:a3ad88c2d704ccb2899d475d3ae05de14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 6.  <a href="namespacemaliput_1_1drake.html#a3ad88c2d704ccb2899d475d3ae05de14">More...</a><br /></td></tr>
<tr class="separator:a3ad88c2d704ccb2899d475d3ae05de14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9dffa1f3d48e4c5fe406e5a4617fe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int Cols&gt; </td></tr>
<tr class="memitem:a3eb9dffa1f3d48e4c5fe406e5a4617fe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a3eb9dffa1f3d48e4c5fe406e5a4617fe">RowVector</a> = Eigen::Matrix&lt; Scalar, 1, Cols &gt;</td></tr>
<tr class="memdesc:a3eb9dffa1f3d48e4c5fe406e5a4617fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector templated on the number of columns.  <a href="namespacemaliput_1_1drake.html#a3eb9dffa1f3d48e4c5fe406e5a4617fe">More...</a><br /></td></tr>
<tr class="separator:a3eb9dffa1f3d48e4c5fe406e5a4617fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f39990d2d9090c7a25c9c18cbf832"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a218f39990d2d9090c7a25c9c18cbf832"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a218f39990d2d9090c7a25c9c18cbf832">RowVectorX</a> = Eigen::Matrix&lt; Scalar, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a218f39990d2d9090c7a25c9c18cbf832"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of any size, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a218f39990d2d9090c7a25c9c18cbf832">More...</a><br /></td></tr>
<tr class="separator:a218f39990d2d9090c7a25c9c18cbf832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06406a5da633da84f911e2979aa48549"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a06406a5da633da84f911e2979aa48549"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a> = Eigen::Matrix&lt; Scalar, 2, 2 &gt;</td></tr>
<tr class="memdesc:a06406a5da633da84f911e2979aa48549"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 2 rows and 2 columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a06406a5da633da84f911e2979aa48549">More...</a><br /></td></tr>
<tr class="separator:a06406a5da633da84f911e2979aa48549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922cc0c6264e8ff225a6aa0dd993667"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3922cc0c6264e8ff225a6aa0dd993667"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> = Eigen::Matrix&lt; Scalar, 3, 3 &gt;</td></tr>
<tr class="memdesc:a3922cc0c6264e8ff225a6aa0dd993667"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 3 rows and 3 columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a3922cc0c6264e8ff225a6aa0dd993667">More...</a><br /></td></tr>
<tr class="separator:a3922cc0c6264e8ff225a6aa0dd993667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74155a11dfcdaad0adc0349f0956148"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae74155a11dfcdaad0adc0349f0956148"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a> = Eigen::Matrix&lt; Scalar, 4, 4 &gt;</td></tr>
<tr class="memdesc:ae74155a11dfcdaad0adc0349f0956148"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 4 rows and 4 columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#ae74155a11dfcdaad0adc0349f0956148">More...</a><br /></td></tr>
<tr class="separator:ae74155a11dfcdaad0adc0349f0956148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f9aa896d31437a219ed19fa944fe20"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a11f9aa896d31437a219ed19fa944fe20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a> = Eigen::Matrix&lt; Scalar, 6, 6 &gt;</td></tr>
<tr class="memdesc:a11f9aa896d31437a219ed19fa944fe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows and 6 columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a11f9aa896d31437a219ed19fa944fe20">More...</a><br /></td></tr>
<tr class="separator:a11f9aa896d31437a219ed19fa944fe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13883859324817e6310d04a6d2fe206"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af13883859324817e6310d04a6d2fe206"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af13883859324817e6310d04a6d2fe206">Matrix2X</a> = Eigen::Matrix&lt; Scalar, 2, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:af13883859324817e6310d04a6d2fe206"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 2 rows, dynamic columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#af13883859324817e6310d04a6d2fe206">More...</a><br /></td></tr>
<tr class="separator:af13883859324817e6310d04a6d2fe206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2dee57bc492bfbd96fe078b65ab00"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acfe2dee57bc492bfbd96fe078b65ab00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a> = Eigen::Matrix&lt; Scalar, 3, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:acfe2dee57bc492bfbd96fe078b65ab00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 3 rows, dynamic columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#acfe2dee57bc492bfbd96fe078b65ab00">More...</a><br /></td></tr>
<tr class="separator:acfe2dee57bc492bfbd96fe078b65ab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585f047d94502e00bfb163347abbc771"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a585f047d94502e00bfb163347abbc771"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a585f047d94502e00bfb163347abbc771">Matrix4X</a> = Eigen::Matrix&lt; Scalar, 4, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a585f047d94502e00bfb163347abbc771"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 4 rows, dynamic columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a585f047d94502e00bfb163347abbc771">More...</a><br /></td></tr>
<tr class="separator:a585f047d94502e00bfb163347abbc771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e1152f8b876967b9093ae4d95298b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a668e1152f8b876967b9093ae4d95298b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a668e1152f8b876967b9093ae4d95298b">Matrix6X</a> = Eigen::Matrix&lt; Scalar, 6, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a668e1152f8b876967b9093ae4d95298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows, dynamic columns, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a668e1152f8b876967b9093ae4d95298b">More...</a><br /></td></tr>
<tr class="separator:a668e1152f8b876967b9093ae4d95298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c58d881c60e96f48a7a4e32a699b95"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a28c58d881c60e96f48a7a4e32a699b95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a28c58d881c60e96f48a7a4e32a699b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of dynamic size, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">More...</a><br /></td></tr>
<tr class="separator:a28c58d881c60e96f48a7a4e32a699b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0efed85a04025fda487f0d59b71d5d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abc0efed85a04025fda487f0d59b71d5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#abc0efed85a04025fda487f0d59b71d5d">MatrixUpTo6</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic, 0, 6, 6 &gt;</td></tr>
<tr class="memdesc:abc0efed85a04025fda487f0d59b71d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of dynamic size templated on scalar type, up to a maximum of 6 rows and 6 columns.  <a href="namespacemaliput_1_1drake.html#abc0efed85a04025fda487f0d59b71d5d">More...</a><br /></td></tr>
<tr class="separator:abc0efed85a04025fda487f0d59b71d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0be18a912f9cacfec6d0a0a6d873c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae2b0be18a912f9cacfec6d0a0a6d873c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ae2b0be18a912f9cacfec6d0a0a6d873c">Matrix6xUpTo6</a> = Eigen::Matrix&lt; Scalar, 6, Eigen::Dynamic, 0, 6, 6 &gt;</td></tr>
<tr class="memdesc:ae2b0be18a912f9cacfec6d0a0a6d873c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows and dynamic column size up to a maximum of 6, templated on scalar type.  <a href="namespacemaliput_1_1drake.html#ae2b0be18a912f9cacfec6d0a0a6d873c">More...</a><br /></td></tr>
<tr class="separator:ae2b0be18a912f9cacfec6d0a0a6d873c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156bf453a5b323356d7cc784dfdf084"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a4156bf453a5b323356d7cc784dfdf084"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a4156bf453a5b323356d7cc784dfdf084">Quaternion</a> = Eigen::Quaternion&lt; Scalar &gt;</td></tr>
<tr class="memdesc:a4156bf453a5b323356d7cc784dfdf084"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quaternion templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a4156bf453a5b323356d7cc784dfdf084">More...</a><br /></td></tr>
<tr class="separator:a4156bf453a5b323356d7cc784dfdf084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d91e75997a81a48adea1e83caddde4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a90d91e75997a81a48adea1e83caddde4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a90d91e75997a81a48adea1e83caddde4">AngleAxis</a> = Eigen::AngleAxis&lt; Scalar &gt;</td></tr>
<tr class="memdesc:a90d91e75997a81a48adea1e83caddde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AngleAxis templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a90d91e75997a81a48adea1e83caddde4">More...</a><br /></td></tr>
<tr class="separator:a90d91e75997a81a48adea1e83caddde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb383d64a842ca9002f66b2e10254aa"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9eb383d64a842ca9002f66b2e10254aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a> = Eigen::Transform&lt; Scalar, 3, Eigen::Isometry &gt;</td></tr>
<tr class="memdesc:a9eb383d64a842ca9002f66b2e10254aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Isometry templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a9eb383d64a842ca9002f66b2e10254aa">More...</a><br /></td></tr>
<tr class="separator:a9eb383d64a842ca9002f66b2e10254aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f8d19f395776637448f26e734228f6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a50f8d19f395776637448f26e734228f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a50f8d19f395776637448f26e734228f6">Translation3</a> = Eigen::Translation&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:a50f8d19f395776637448f26e734228f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A translation in 3D templated on scalar type.  <a href="namespacemaliput_1_1drake.html#a50f8d19f395776637448f26e734228f6">More...</a><br /></td></tr>
<tr class="separator:a50f8d19f395776637448f26e734228f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf249fd84580486a877500bed5a0b8e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afbf249fd84580486a877500bed5a0b8e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#afbf249fd84580486a877500bed5a0b8e">TwistVector</a> = Eigen::Matrix&lt; Scalar, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, 1 &gt;</td></tr>
<tr class="memdesc:afbf249fd84580486a877500bed5a0b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector consisting of one twist.  <a href="namespacemaliput_1_1drake.html#afbf249fd84580486a877500bed5a0b8e">More...</a><br /></td></tr>
<tr class="separator:afbf249fd84580486a877500bed5a0b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30fe85a821bd0e0ab46f2e165c8e480"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af30fe85a821bd0e0ab46f2e165c8e480"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af30fe85a821bd0e0ab46f2e165c8e480">TwistMatrix</a> = Eigen::Matrix&lt; Scalar, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:af30fe85a821bd0e0ab46f2e165c8e480"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with one twist per column, and dynamically many columns.  <a href="namespacemaliput_1_1drake.html#af30fe85a821bd0e0ab46f2e165c8e480">More...</a><br /></td></tr>
<tr class="separator:af30fe85a821bd0e0ab46f2e165c8e480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa72a15690d6e4db2040ebc8814a74e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3aa72a15690d6e4db2040ebc8814a74e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a3aa72a15690d6e4db2040ebc8814a74e">SquareTwistMatrix</a> = Eigen::Matrix&lt; Scalar, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a> &gt;</td></tr>
<tr class="memdesc:a3aa72a15690d6e4db2040ebc8814a74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A six-by-six matrix.  <a href="namespacemaliput_1_1drake.html#a3aa72a15690d6e4db2040ebc8814a74e">More...</a><br /></td></tr>
<tr class="separator:a3aa72a15690d6e4db2040ebc8814a74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98fed5f98c376f4d45fff56bb96c8e1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af98fed5f98c376f4d45fff56bb96c8e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af98fed5f98c376f4d45fff56bb96c8e1">WrenchVector</a> = Eigen::Matrix&lt; Scalar, 6, 1 &gt;</td></tr>
<tr class="memdesc:af98fed5f98c376f4d45fff56bb96c8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector consisting of one wrench (spatial force) = <code>[r X f; f]</code>, where f is a force (translational force) applied at a point <code>P</code> and <code>r</code> is the position vector from a point <code>O</code> (called the "moment center") to point <code>P</code>.  <a href="namespacemaliput_1_1drake.html#af98fed5f98c376f4d45fff56bb96c8e1">More...</a><br /></td></tr>
<tr class="separator:af98fed5f98c376f4d45fff56bb96c8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a11519c4c803fc3f2118df94e858e95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a> = <a class="el" href="classmaliput_1_1drake_1_1internal_1_1_f_n_v1a_hasher.html">internal::FNV1aHasher</a></td></tr>
<tr class="memdesc:a5a11519c4c803fc3f2118df94e858e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default HashAlgorithm concept implementation across Drake.  <a href="namespacemaliput_1_1drake.html#a5a11519c4c803fc3f2118df94e858e95">More...</a><br /></td></tr>
<tr class="separator:a5a11519c4c803fc3f2118df94e858e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2a4541f86da3123b759d584b6f34ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a0b2a4541f86da3123b759d584b6f34ab">DefaultHash</a> = <a class="el" href="structmaliput_1_1drake_1_1uhash.html">maliput::drake::uhash</a>&lt; <a class="el" href="namespacemaliput_1_1drake.html#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a> &gt;</td></tr>
<tr class="memdesc:a0b2a4541f86da3123b759d584b6f34ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default hashing functor, akin to std::hash.  <a href="namespacemaliput_1_1drake.html#a0b2a4541f86da3123b759d584b6f34ab">More...</a><br /></td></tr>
<tr class="separator:a0b2a4541f86da3123b759d584b6f34ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158f68939b94f6c2c5ea353d652919da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a158f68939b94f6c2c5ea353d652919da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a158f68939b94f6c2c5ea353d652919da">is_cloneable</a> = is_cloneable_internal::is_cloneable_helper&lt; T, void &gt;</td></tr>
<tr class="separator:a158f68939b94f6c2c5ea353d652919da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a2621977171e1d2d5b64c55141b9b2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a></td></tr>
<tr class="separator:ab0a2621977171e1d2d5b64c55141b9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cbebcd97766579bb36e35abcf44acf"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a></td></tr>
<tr class="memdesc:a00cbebcd97766579bb36e35abcf44acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of polynomials; used in several optimization classes.  <a href="namespacemaliput_1_1drake.html#a00cbebcd97766579bb36e35abcf44acf">More...</a><br /></td></tr>
<tr class="separator:a00cbebcd97766579bb36e35abcf44acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af8777bc10296f9d39d52753861110e26"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> { <a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a">kAbsolute</a>, 
<a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">kRelative</a>
 }</td></tr>
<tr class="separator:af8777bc10296f9d39d52753861110e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72383be4710d27584d0821effc6506a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> { <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50">kUniform</a> = 0, 
<a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0">kGaussian</a> = 1, 
<a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6">kExponential</a> = 2
 }</td></tr>
<tr class="memdesc:a72383be4710d27584d0821effc6506a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drake supports explicit reasoning about a few carefully chosen random distributions.  <a href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">More...</a><br /></td></tr>
<tr class="separator:a72383be4710d27584d0821effc6506a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a18197d6999dda546d996d5b8dfccd53a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a18197d6999dda546d996d5b8dfccd53a"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a18197d6999dda546d996d5b8dfccd53a">all</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a18197d6999dda546d996d5b8dfccd53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks truth for all elements in matrix <code>m</code>.  <a href="namespacemaliput_1_1drake.html#a18197d6999dda546d996d5b8dfccd53a">More...</a><br /></td></tr>
<tr class="separator:a18197d6999dda546d996d5b8dfccd53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea88dde6d4dd05c07a631ac8b94ef5e7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aea88dde6d4dd05c07a631ac8b94ef5e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aea88dde6d4dd05c07a631ac8b94ef5e7">all_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:aea88dde6d4dd05c07a631ac8b94ef5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code>pred</code> holds for all elements in the matrix <code>m</code>.  <a href="namespacemaliput_1_1drake.html#aea88dde6d4dd05c07a631ac8b94ef5e7">More...</a><br /></td></tr>
<tr class="separator:aea88dde6d4dd05c07a631ac8b94ef5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f661d87ca8519af1494a8c045aef91"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a87f661d87ca8519af1494a8c045aef91"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a87f661d87ca8519af1494a8c045aef91">any</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a87f661d87ca8519af1494a8c045aef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks truth for at least one element in matrix <code>m</code>.  <a href="namespacemaliput_1_1drake.html#a87f661d87ca8519af1494a8c045aef91">More...</a><br /></td></tr>
<tr class="separator:a87f661d87ca8519af1494a8c045aef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581bce854832eed48d47ead042014dd0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a581bce854832eed48d47ead042014dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a581bce854832eed48d47ead042014dd0">any_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:a581bce854832eed48d47ead042014dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code>pred</code> holds for at least one element in the matrix <code>m</code>.  <a href="namespacemaliput_1_1drake.html#a581bce854832eed48d47ead042014dd0">More...</a><br /></td></tr>
<tr class="separator:a581bce854832eed48d47ead042014dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e78dcc4c899c0f86a05e8f8c5df78f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78e78dcc4c899c0f86a05e8f8c5df78f"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a78e78dcc4c899c0f86a05e8f8c5df78f">none</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a78e78dcc4c899c0f86a05e8f8c5df78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that no elements of <code>m</code> are true. An empty matrix returns true.  <a href="namespacemaliput_1_1drake.html#a78e78dcc4c899c0f86a05e8f8c5df78f">More...</a><br /></td></tr>
<tr class="separator:a78e78dcc4c899c0f86a05e8f8c5df78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc3e8670f86d1c69eaf29ad072865cc"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acfc3e8670f86d1c69eaf29ad072865cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#acfc3e8670f86d1c69eaf29ad072865cc">none_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:acfc3e8670f86d1c69eaf29ad072865cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code>pred</code> holds for no elements in the matrix <code>m</code>.  <a href="namespacemaliput_1_1drake.html#acfc3e8670f86d1c69eaf29ad072865cc">More...</a><br /></td></tr>
<tr class="separator:acfc3e8670f86d1c69eaf29ad072865cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef84e5a8cff869d8a840d52578ae89db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef84e5a8cff869d8a840d52578ae89db"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aef84e5a8cff869d8a840d52578ae89db">DRAKE_DEPRECATED</a> (&quot;2020-08-01&quot;, &quot;Provide a specific overload of <a class="el" href="namespacemaliput_1_1drake.html#ab4b4b76d02b97e432f12b85f16d06a83">ExtractDoubleOrThrow</a> for <a class="el" href="namespacemaliput_1_1drake.html#a87f661d87ca8519af1494a8c045aef91">any</a> &quot; &quot;type that really is sensible at compile time and should &quot; &quot;defer failure to runtime; this version was too generic.&quot;) typename std</td></tr>
<tr class="memdesc:aef84e5a8cff869d8a840d52578ae89db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ScalarType value to a double, failing at runtime (not compile time) if the type cannot be converted to a double.  <a href="namespacemaliput_1_1drake.html#aef84e5a8cff869d8a840d52578ae89db">More...</a><br /></td></tr>
<tr class="separator:aef84e5a8cff869d8a840d52578ae89db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4b76d02b97e432f12b85f16d06a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ab4b4b76d02b97e432f12b85f16d06a83">ExtractDoubleOrThrow</a> (<a class="el" href="classdouble.html">double</a> scalar)</td></tr>
<tr class="memdesc:ab4b4b76d02b97e432f12b85f16d06a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>scalar</code> as a double. Never throws.  <a href="namespacemaliput_1_1drake.html#ab4b4b76d02b97e432f12b85f16d06a83">More...</a><br /></td></tr>
<tr class="separator:ab4b4b76d02b97e432f12b85f16d06a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb565e9a203554c64228bfea2808935"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acbb565e9a203554c64228bfea2808935"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;, Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, Derived::Options, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#acbb565e9a203554c64228bfea2808935">ExtractDoubleOrThrow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:acbb565e9a203554c64228bfea2808935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code>matrix</code>.  <a href="namespacemaliput_1_1drake.html#acbb565e9a203554c64228bfea2808935">More...</a><br /></td></tr>
<tr class="separator:acbb565e9a203554c64228bfea2808935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0284bfa9d633e202f564338a6cf623b4"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:a0284bfa9d633e202f564338a6cf623b4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a0284bfa9d633e202f564338a6cf623b4">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a0284bfa9d633e202f564338a6cf623b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for integral constants.  <a href="namespacemaliput_1_1drake.html#a0284bfa9d633e202f564338a6cf623b4">More...</a><br /></td></tr>
<tr class="separator:a0284bfa9d633e202f564338a6cf623b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c729e47e35c048046d463e042446b36"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:a5c729e47e35c048046d463e042446b36"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_enum_v&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a5c729e47e35c048046d463e042446b36">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a5c729e47e35c048046d463e042446b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for enumerations.  <a href="namespacemaliput_1_1drake.html#a5c729e47e35c048046d463e042446b36">More...</a><br /></td></tr>
<tr class="separator:a5c729e47e35c048046d463e042446b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb07677aa04f0138bd05f7d361466e93"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:acb07677aa04f0138bd05f7d361466e93"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#acb07677aa04f0138bd05f7d361466e93">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:acb07677aa04f0138bd05f7d361466e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for floating point values.  <a href="namespacemaliput_1_1drake.html#acb07677aa04f0138bd05f7d361466e93">More...</a><br /></td></tr>
<tr class="separator:acb07677aa04f0138bd05f7d361466e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a837d489bcc6395a68518f05f84171"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class Traits , class Allocator &gt; </td></tr>
<tr class="memitem:ad0a837d489bcc6395a68518f05f84171"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ad0a837d489bcc6395a68518f05f84171">hash_append</a> (HashAlgorithm &amp;hasher, const std::basic_string&lt; char, Traits, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:ad0a837d489bcc6395a68518f05f84171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::string.  <a href="namespacemaliput_1_1drake.html#ad0a837d489bcc6395a68518f05f84171">More...</a><br /></td></tr>
<tr class="separator:ad0a837d489bcc6395a68518f05f84171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3a753d7c4264b50a08d98ab24cd9b5"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afd3a753d7c4264b50a08d98ab24cd9b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#afd3a753d7c4264b50a08d98ab24cd9b5">hash_append</a> (HashAlgorithm &amp;hasher, const std::pair&lt; T1, T2 &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:afd3a753d7c4264b50a08d98ab24cd9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::pair.  <a href="namespacemaliput_1_1drake.html#afd3a753d7c4264b50a08d98ab24cd9b5">More...</a><br /></td></tr>
<tr class="separator:afd3a753d7c4264b50a08d98ab24cd9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135056b56b4b74592a8bb99e661e3824"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:a135056b56b4b74592a8bb99e661e3824"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a135056b56b4b74592a8bb99e661e3824">hash_append</a> (HashAlgorithm &amp;hasher, const std::optional&lt; T &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a135056b56b4b74592a8bb99e661e3824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::optional.  <a href="namespacemaliput_1_1drake.html#a135056b56b4b74592a8bb99e661e3824">More...</a><br /></td></tr>
<tr class="separator:a135056b56b4b74592a8bb99e661e3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61c75c1d13adf6bab150b67a38b84d3"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class Iter &gt; </td></tr>
<tr class="memitem:ad61c75c1d13adf6bab150b67a38b84d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ad61c75c1d13adf6bab150b67a38b84d3">hash_append_range</a> (HashAlgorithm &amp;hasher, Iter begin, Iter end) noexcept</td></tr>
<tr class="memdesc:ad61c75c1d13adf6bab150b67a38b84d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for a range, as given by two iterators.  <a href="namespacemaliput_1_1drake.html#ad61c75c1d13adf6bab150b67a38b84d3">More...</a><br /></td></tr>
<tr class="separator:ad61c75c1d13adf6bab150b67a38b84d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f49ebd9ac9892798c67660d47780bb6"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T1 , class T2 , class Compare , class Allocator &gt; </td></tr>
<tr class="memitem:a7f49ebd9ac9892798c67660d47780bb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a7f49ebd9ac9892798c67660d47780bb6">hash_append</a> (HashAlgorithm &amp;hasher, const std::map&lt; T1, T2, Compare, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a7f49ebd9ac9892798c67660d47780bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::map.  <a href="namespacemaliput_1_1drake.html#a7f49ebd9ac9892798c67660d47780bb6">More...</a><br /></td></tr>
<tr class="separator:a7f49ebd9ac9892798c67660d47780bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc126047be01b9fcf50d66794419b2f5"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class Key , class Compare , class Allocator &gt; </td></tr>
<tr class="memitem:abc126047be01b9fcf50d66794419b2f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#abc126047be01b9fcf50d66794419b2f5">hash_append</a> (HashAlgorithm &amp;hasher, const std::set&lt; Key, Compare, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:abc126047be01b9fcf50d66794419b2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::set.  <a href="namespacemaliput_1_1drake.html#abc126047be01b9fcf50d66794419b2f5">More...</a><br /></td></tr>
<tr class="separator:abc126047be01b9fcf50d66794419b2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe934638081d5266e1b191d2a3ae7d"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a04fe934638081d5266e1b191d2a3ae7d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a04fe934638081d5266e1b191d2a3ae7d">to_string</a> (const <a class="el" href="classmaliput_1_1drake_1_1_identifier.html">maliput::drake::Identifier</a>&lt; Tag &gt; &amp;id)</td></tr>
<tr class="memdesc:a04fe934638081d5266e1b191d2a3ae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables use of identifiers with to_string.  <a href="namespacemaliput_1_1drake.html#a04fe934638081d5266e1b191d2a3ae7d">More...</a><br /></td></tr>
<tr class="separator:a04fe934638081d5266e1b191d2a3ae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36150fcc9734997befa37c4c9c8ac80b"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a36150fcc9734997befa37c4c9c8ac80b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a36150fcc9734997befa37c4c9c8ac80b">static_pointer_cast</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a36150fcc9734997befa37c4c9c8ac80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; no runtime type checking is performed.  <a href="namespacemaliput_1_1drake.html#a36150fcc9734997befa37c4c9c8ac80b">More...</a><br /></td></tr>
<tr class="separator:a36150fcc9734997befa37c4c9c8ac80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c423659476de5c504384a34a7a48de"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a44c423659476de5c504384a34a7a48de"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a44c423659476de5c504384a34a7a48de">dynamic_pointer_cast</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a44c423659476de5c504384a34a7a48de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if the cast fails, returns nullptr.  <a href="namespacemaliput_1_1drake.html#a44c423659476de5c504384a34a7a48de">More...</a><br /></td></tr>
<tr class="separator:a44c423659476de5c504384a34a7a48de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc8d19ae3df0e6cb635460680f4335d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afdc8d19ae3df0e6cb635460680f4335d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#afdc8d19ae3df0e6cb635460680f4335d">dynamic_pointer_cast_or_throw</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:afdc8d19ae3df0e6cb635460680f4335d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if <code>other</code> is nullptr or the cast fails, throws a std::exception.  <a href="namespacemaliput_1_1drake.html#afdc8d19ae3df0e6cb635460680f4335d">More...</a><br /></td></tr>
<tr class="separator:afdc8d19ae3df0e6cb635460680f4335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e1a1d5235229e09f8af51fe653d896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54e1a1d5235229e09f8af51fe653d896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a54e1a1d5235229e09f8af51fe653d896">pow</a> (const <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;base, typename <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;::PowerType exponent)</td></tr>
<tr class="memdesc:a54e1a1d5235229e09f8af51fe653d896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides power function for <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="namespacemaliput_1_1drake.html#a54e1a1d5235229e09f8af51fe653d896">More...</a><br /></td></tr>
<tr class="separator:a54e1a1d5235229e09f8af51fe653d896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9bb65194582cce374b2a7d01a09610"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:a3b9bb65194582cce374b2a7d01a09610"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a3b9bb65194582cce374b2a7d01a09610">operator&lt;&lt;</a> (std::ostream &amp;os, const Eigen::Matrix&lt; <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;, Rows, Cols &gt; &amp;poly_mat)</td></tr>
<tr class="separator:a3b9bb65194582cce374b2a7d01a09610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7459c4a03d4b4f77eea119df933489da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7459c4a03d4b4f77eea119df933489da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a7459c4a03d4b4f77eea119df933489da">CalcProbabilityDensity</a> (<a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> distribution, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;x)</td></tr>
<tr class="memdesc:a7459c4a03d4b4f77eea119df933489da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the density (probability density function) of the multivariate distribution.  <a href="namespacemaliput_1_1drake.html#a7459c4a03d4b4f77eea119df933489da">More...</a><br /></td></tr>
<tr class="separator:a7459c4a03d4b4f77eea119df933489da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157c1d75c2e52df3370e5f458022ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1logging.html#a9cae370466ffb304c10aebea42eca26b">logging::logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aa157c1d75c2e52df3370e5f458022ee9">log</a> ()</td></tr>
<tr class="memdesc:aa157c1d75c2e52df3370e5f458022ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an instance of a logger to use for logging; for example:  <a href="namespacemaliput_1_1drake.html#aa157c1d75c2e52df3370e5f458022ee9">More...</a><br /></td></tr>
<tr class="separator:aa157c1d75c2e52df3370e5f458022ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f5d094c05d975c3fb1eb735d7e0428"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:ab6f5d094c05d975c3fb1eb735d7e0428"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ab6f5d094c05d975c3fb1eb735d7e0428">operator==</a> (const U &amp;value, const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:ab6f5d094c05d975c3fb1eb735d7e0428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689b232e965c2a9cb7b98e702eb8502f"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a689b232e965c2a9cb7b98e702eb8502f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a689b232e965c2a9cb7b98e702eb8502f">operator!=</a> (const U &amp;value, const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a689b232e965c2a9cb7b98e702eb8502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67239655b7c6173aa85ba63103d62382"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a67239655b7c6173aa85ba63103d62382"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a67239655b7c6173aa85ba63103d62382">operator&lt;</a> (const U &amp;value, const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a67239655b7c6173aa85ba63103d62382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc287d6eb32ff6e9287c29d414a2e046"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:adc287d6eb32ff6e9287c29d414a2e046"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#adc287d6eb32ff6e9287c29d414a2e046">operator&lt;=</a> (const U &amp;value, const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:adc287d6eb32ff6e9287c29d414a2e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8073dc48e59dfd721a71171a88763b7e"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a8073dc48e59dfd721a71171a88763b7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a8073dc48e59dfd721a71171a88763b7e">operator&gt;</a> (const U &amp;value, const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a8073dc48e59dfd721a71171a88763b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8637931173103787c3afd15dbeb4a1"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:aae8637931173103787c3afd15dbeb4a1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aae8637931173103787c3afd15dbeb4a1">operator&gt;=</a> (const U &amp;value, const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:aae8637931173103787c3afd15dbeb4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbd758ec364c16c9c4137651e771013"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acbbd758ec364c16c9c4137651e771013"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#acbbd758ec364c16c9c4137651e771013">unused</a> (const Args &amp;...)</td></tr>
<tr class="memdesc:acbbd758ec364c16c9c4137651e771013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning.  <a href="namespacemaliput_1_1drake.html#acbbd758ec364c16c9c4137651e771013">More...</a><br /></td></tr>
<tr class="separator:acbbd758ec364c16c9c4137651e771013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bce133654002443b7d69eec8835b39"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a10bce133654002443b7d69eec8835b39">CalcProbabilityDensity&lt; double &gt;</a> (<a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a10bce133654002443b7d69eec8835b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a07869e660ffe730425feca7595de2273"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a07869e660ffe730425feca7595de2273">kQuaternionSize</a> = 4</td></tr>
<tr class="separator:a07869e660ffe730425feca7595de2273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869092c52ed7cc9d2db40ce56050c7c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a> = 3</td></tr>
<tr class="separator:af869092c52ed7cc9d2db40ce56050c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab5b0d99cafc2f6ae5812128cea27a3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aeab5b0d99cafc2f6ae5812128cea27a3">kRpySize</a> = 3</td></tr>
<tr class="separator:aeab5b0d99cafc2f6ae5812128cea27a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce1d9cce0ad61dd2f5a295c1a10fc8"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a> = 6</td></tr>
<tr class="memdesc:ac9ce1d9cce0ad61dd2f5a295c1a10fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Screw_theory#Twist">https://en.wikipedia.org/wiki/Screw_theory#Twist</a>  <a href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">More...</a><br /></td></tr>
<tr class="separator:ac9ce1d9cce0ad61dd2f5a295c1a10fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c55e4d8662e0986e79d11486334486"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a63c55e4d8662e0986e79d11486334486">kHomogeneousTransformSize</a> = 16</td></tr>
<tr class="memdesc:a63c55e4d8662e0986e79d11486334486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/">http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/</a>  <a href="namespacemaliput_1_1drake.html#a63c55e4d8662e0986e79d11486334486">More...</a><br /></td></tr>
<tr class="separator:a63c55e4d8662e0986e79d11486334486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace32fe90adc0d2100ad4fc9f4bc6f79a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ace32fe90adc0d2100ad4fc9f4bc6f79a">kRotmatSize</a> = <a class="el" href="namespacemaliput_1_1drake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a> * <a class="el" href="namespacemaliput_1_1drake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a></td></tr>
<tr class="separator:ace32fe90adc0d2100ad4fc9f4bc6f79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ffa02b326b2dd39e7f6cbc4606b61c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#ae5ffa02b326b2dd39e7f6cbc4606b61c">kDrakeAssertIsArmed</a> = true</td></tr>
<tr class="separator:ae5ffa02b326b2dd39e7f6cbc4606b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef73489ed741143f9d712623e53b6da"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#aaef73489ed741143f9d712623e53b6da">kDrakeAssertIsDisarmed</a> = false</td></tr>
<tr class="separator:aaef73489ed741143f9d712623e53b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4278037dcb693a8ee6b06709bf630e7c"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a4278037dcb693a8ee6b06709bf630e7c">kNameChars</a> [] = &quot;@#_.abcdefghijklmnopqrstuvwxyz&quot;</td></tr>
<tr class="separator:a4278037dcb693a8ee6b06709bf630e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb8cf48cd1a44df66b82ec47978884b"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a3eb8cf48cd1a44df66b82ec47978884b">kNumNameChars</a> = sizeof(<a class="el" href="namespacemaliput_1_1drake.html#a4278037dcb693a8ee6b06709bf630e7c">kNameChars</a>) - 1</td></tr>
<tr class="separator:a3eb8cf48cd1a44df66b82ec47978884b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beaa96b5dc7c903f4412e3f6ce95bf9"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#a8beaa96b5dc7c903f4412e3f6ce95bf9">kNameLength</a> = 4</td></tr>
<tr class="separator:a8beaa96b5dc7c903f4412e3f6ce95bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa3b7e9b38e1a49824ae3edfcca411f"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1drake.html#affa3b7e9b38e1a49824ae3edfcca411f">kMaxNamePart</a> = 923521</td></tr>
<tr class="separator:affa3b7e9b38e1a49824ae3edfcca411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a90d91e75997a81a48adea1e83caddde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d91e75997a81a48adea1e83caddde4">&#9670;&nbsp;</a></span>AngleAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a90d91e75997a81a48adea1e83caddde4">AngleAxis</a> =  Eigen::AngleAxis&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An AngleAxis templated on scalar type. </p>

</div>
</div>
<a id="a1f1c657c4d2cf400649123a7c2573d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c657c4d2cf400649123a7c2573d5b">&#9670;&nbsp;</a></span>boolean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a> =  typename <a class="el" href="structmaliput_1_1drake_1_1scalar__predicate.html">scalar_predicate</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a boolean-like value, conditioned on the scalar type <code>T</code>. </p>
<p>In many cases this will be a synonym for <code>bool</code>, e.g., when <code>T = double</code>. When <code>T = symbolic::Expression</code>, this is a synonym for <code>symbolic::Formula</code>. This is a convenience abbreviation for <a class="el" href="structmaliput_1_1drake_1_1scalar__predicate.html#a945d5b96b85fa30cf7587ef08b38f3d2" title="The return type of predicates over T.">scalar_predicate&lt;T&gt;::type</a>. </p>

</div>
</div>
<a id="a0b2a4541f86da3123b759d584b6f34ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2a4541f86da3123b759d584b6f34ab">&#9670;&nbsp;</a></span>DefaultHash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a0b2a4541f86da3123b759d584b6f34ab">DefaultHash</a> =  <a class="el" href="structmaliput_1_1drake_1_1uhash.html">maliput::drake::uhash</a>&lt;<a class="el" href="namespacemaliput_1_1drake.html#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default hashing functor, akin to std::hash. </p>

</div>
</div>
<a id="a5a11519c4c803fc3f2118df94e858e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a11519c4c803fc3f2118df94e858e95">&#9670;&nbsp;</a></span>DefaultHasher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a> =  <a class="el" href="classmaliput_1_1drake_1_1internal_1_1_f_n_v1a_hasher.html">internal::FNV1aHasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default HashAlgorithm concept implementation across Drake. </p>
<p>This is guaranteed to have a result_type of size_t to be compatible with std::hash. </p>

</div>
</div>
<a id="ae13e10d823b0e212fdfb27cc8f18065a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13e10d823b0e212fdfb27cc8f18065a">&#9670;&nbsp;</a></span>eigen_aligned_std_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#ae13e10d823b0e212fdfb27cc8f18065a">eigen_aligned_std_map</a> =  std::map&lt;Key, T, std::less&lt;Key&gt;, Eigen::aligned_allocator&lt;std::pair&lt;Key const, T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::map that uses Eigen::aligned_allocator so that the contained types may be fixed-size Eigen values. </p>

</div>
</div>
<a id="afcadf96d397f45d041d01bf17061bc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcadf96d397f45d041d01bf17061bc32">&#9670;&nbsp;</a></span>eigen_aligned_std_unordered_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#afcadf96d397f45d041d01bf17061bc32">eigen_aligned_std_unordered_map</a> =  std::unordered_map&lt;Key, T, std::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Eigen::aligned_allocator&lt;std::pair&lt;Key const, T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::unordered_map that uses Eigen::aligned_allocator so that the contained types may be fixed-size Eigen values. </p>

</div>
</div>
<a id="a4150555527b3cf871fe911f8776f301a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4150555527b3cf871fe911f8776f301a">&#9670;&nbsp;</a></span>eigen_aligned_std_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a4150555527b3cf871fe911f8776f301a">eigen_aligned_std_vector</a> =  std::vector&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::vector that uses Eigen::aligned_allocator so that the contained types may be fixed-size Eigen values. </p>

</div>
</div>
<a id="a158f68939b94f6c2c5ea353d652919da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158f68939b94f6c2c5ea353d652919da">&#9670;&nbsp;</a></span>is_cloneable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a158f68939b94f6c2c5ea353d652919da">is_cloneable</a> =  is_cloneable_internal::is_cloneable_helper&lt;T, void&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="is_cloneable_doc"></a>Provides method for determining at run time if a class is "cloneable".</p>
<p><b>Usage</b></p>
<p>This gets used like <code>type_traits</code> functions (e.g., <code>is_copy_constructible</code>, <code>is_same</code>, etc.) To determine if a class is cloneable simply invoke:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> value = <a class="code" href="namespacemaliput_1_1drake.html#a158f68939b94f6c2c5ea353d652919da">maliput::drake::is_cloneable&lt;Foo&gt;::value</a>;</div>
</div><!-- fragment --><p>If <code>Foo</code> is cloneable, it will evaluate to true. It can also be used in compile-time tests (e.g., SFINAE and <code>static_assert</code>s):</p>
<div class="fragment"><div class="line">static_assert(is_cloneable&lt;Foo&gt;::value, <span class="stringliteral">&quot;This method requires its classes to &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;be cloneable.&quot;</span>);</div>
</div><!-- fragment --><p><b>Definition of "cloneability"</b></p>
<p>To be cloneable, the class <code>Foo</code> must have a <em>public</em> method of the form: </p><div class="fragment"><div class="line">unique_ptr&lt;Foo&gt; Foo::Clone() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Note that "friend" access for the is_cloneable-using class is not sufficient. The <code>Foo::Clone()</code> method must actually be public.</p>
<p>The pointer contained in the returned <code>unique_ptr</code> must point to a heap-allocated deep copy of the <em>concrete</em> object. This test can confirm the proper signature, but cannot confirm the heap-allocated deep copy. A Clone() method that doesn't return such a copy of the <em>concrete</em> object should be considered a malformed function.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is important to note, that a <code>Clone()</code> method that returns a <code>unique_ptr</code> to a <em>super</em> class is <em>not</em> sufficient to be cloneable. In other words the presence of: <div class="fragment"><div class="line">unique_ptr&lt;Base&gt; Derived::Clone() <span class="keyword">const</span>;</div>
</div><!-- fragment --> will not make the <code>Derived</code> class cloneable.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The class to test for cloneability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eb383d64a842ca9002f66b2e10254aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb383d64a842ca9002f66b2e10254aa">&#9670;&nbsp;</a></span>Isometry3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a> =  Eigen::Transform&lt;Scalar, 3, Eigen::Isometry&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Isometry templated on scalar type. </p>

</div>
</div>
<a id="a06406a5da633da84f911e2979aa48549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06406a5da633da84f911e2979aa48549">&#9670;&nbsp;</a></span>Matrix2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a> =  Eigen::Matrix&lt;Scalar, 2, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 2 rows and 2 columns, templated on scalar type. </p>

</div>
</div>
<a id="af13883859324817e6310d04a6d2fe206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13883859324817e6310d04a6d2fe206">&#9670;&nbsp;</a></span>Matrix2X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#af13883859324817e6310d04a6d2fe206">Matrix2X</a> =  Eigen::Matrix&lt;Scalar, 2, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 2 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="a3922cc0c6264e8ff225a6aa0dd993667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3922cc0c6264e8ff225a6aa0dd993667">&#9670;&nbsp;</a></span>Matrix3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> =  Eigen::Matrix&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 3 rows and 3 columns, templated on scalar type. </p>

</div>
</div>
<a id="acfe2dee57bc492bfbd96fe078b65ab00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2dee57bc492bfbd96fe078b65ab00">&#9670;&nbsp;</a></span>Matrix3X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a> =  Eigen::Matrix&lt;Scalar, 3, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 3 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="ae74155a11dfcdaad0adc0349f0956148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74155a11dfcdaad0adc0349f0956148">&#9670;&nbsp;</a></span>Matrix4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a> =  Eigen::Matrix&lt;Scalar, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 4 rows and 4 columns, templated on scalar type. </p>

</div>
</div>
<a id="a585f047d94502e00bfb163347abbc771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585f047d94502e00bfb163347abbc771">&#9670;&nbsp;</a></span>Matrix4X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a585f047d94502e00bfb163347abbc771">Matrix4X</a> =  Eigen::Matrix&lt;Scalar, 4, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 4 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="a11f9aa896d31437a219ed19fa944fe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f9aa896d31437a219ed19fa944fe20">&#9670;&nbsp;</a></span>Matrix6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a> =  Eigen::Matrix&lt;Scalar, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows and 6 columns, templated on scalar type. </p>

</div>
</div>
<a id="a668e1152f8b876967b9093ae4d95298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e1152f8b876967b9093ae4d95298b">&#9670;&nbsp;</a></span>Matrix6X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a668e1152f8b876967b9093ae4d95298b">Matrix6X</a> =  Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="ae2b0be18a912f9cacfec6d0a0a6d873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0be18a912f9cacfec6d0a0a6d873c">&#9670;&nbsp;</a></span>Matrix6xUpTo6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#ae2b0be18a912f9cacfec6d0a0a6d873c">Matrix6xUpTo6</a> =  Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic, 0, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows and dynamic column size up to a maximum of 6, templated on scalar type. </p>

</div>
</div>
<a id="abc0efed85a04025fda487f0d59b71d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0efed85a04025fda487f0d59b71d5d">&#9670;&nbsp;</a></span>MatrixUpTo6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#abc0efed85a04025fda487f0d59b71d5d">MatrixUpTo6</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic, 0, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of dynamic size templated on scalar type, up to a maximum of 6 rows and 6 columns. </p>
<p>Rectangular matrices, with different number of rows and columns, are allowed. </p>

</div>
</div>
<a id="a28c58d881c60e96f48a7a4e32a699b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c58d881c60e96f48a7a4e32a699b95">&#9670;&nbsp;</a></span>MatrixX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of dynamic size, templated on scalar type. </p>

</div>
</div>
<a id="ab0a2621977171e1d2d5b64c55141b9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a2621977171e1d2d5b64c55141b9b2">&#9670;&nbsp;</a></span>Polynomiald</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4156bf453a5b323356d7cc784dfdf084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4156bf453a5b323356d7cc784dfdf084">&#9670;&nbsp;</a></span>Quaternion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a4156bf453a5b323356d7cc784dfdf084">Quaternion</a> =  Eigen::Quaternion&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A quaternion templated on scalar type. </p>

</div>
</div>
<a id="a3eb9dffa1f3d48e4c5fe406e5a4617fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9dffa1f3d48e4c5fe406e5a4617fe">&#9670;&nbsp;</a></span>RowVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a3eb9dffa1f3d48e4c5fe406e5a4617fe">RowVector</a> =  Eigen::Matrix&lt;Scalar, 1, Cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector templated on the number of columns. </p>

</div>
</div>
<a id="afc54e1f7aa3341a5f6b305705452d9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54e1f7aa3341a5f6b305705452d9bd">&#9670;&nbsp;</a></span>RowVector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#afc54e1f7aa3341a5f6b305705452d9bd">RowVector2</a> =  Eigen::Matrix&lt;Scalar, 1, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 2, templated on scalar type. </p>

</div>
</div>
<a id="aee4ae0d841ea1629551bf77fd5d9ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4ae0d841ea1629551bf77fd5d9ec9e">&#9670;&nbsp;</a></span>RowVector3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#aee4ae0d841ea1629551bf77fd5d9ec9e">RowVector3</a> =  Eigen::Matrix&lt;Scalar, 1, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 3, templated on scalar type. </p>

</div>
</div>
<a id="aa9b373b2971391d9054b431d8a3e4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b373b2971391d9054b431d8a3e4b33">&#9670;&nbsp;</a></span>RowVector4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#aa9b373b2971391d9054b431d8a3e4b33">RowVector4</a> =  Eigen::Matrix&lt;Scalar, 1, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 4, templated on scalar type. </p>

</div>
</div>
<a id="a3ad88c2d704ccb2899d475d3ae05de14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad88c2d704ccb2899d475d3ae05de14">&#9670;&nbsp;</a></span>RowVector6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a3ad88c2d704ccb2899d475d3ae05de14">RowVector6</a> =  Eigen::Matrix&lt;Scalar, 1, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 6. </p>

</div>
</div>
<a id="a218f39990d2d9090c7a25c9c18cbf832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f39990d2d9090c7a25c9c18cbf832">&#9670;&nbsp;</a></span>RowVectorX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a218f39990d2d9090c7a25c9c18cbf832">RowVectorX</a> =  Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of any size, templated on scalar type. </p>

</div>
</div>
<a id="a3aa72a15690d6e4db2040ebc8814a74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa72a15690d6e4db2040ebc8814a74e">&#9670;&nbsp;</a></span>SquareTwistMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a3aa72a15690d6e4db2040ebc8814a74e">SquareTwistMatrix</a> =  Eigen::Matrix&lt;Scalar, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A six-by-six matrix. </p>

</div>
</div>
<a id="a50f8d19f395776637448f26e734228f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f8d19f395776637448f26e734228f6">&#9670;&nbsp;</a></span>Translation3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a50f8d19f395776637448f26e734228f6">Translation3</a> =  Eigen::Translation&lt;Scalar, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A translation in 3D templated on scalar type. </p>

</div>
</div>
<a id="af30fe85a821bd0e0ab46f2e165c8e480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30fe85a821bd0e0ab46f2e165c8e480">&#9670;&nbsp;</a></span>TwistMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#af30fe85a821bd0e0ab46f2e165c8e480">TwistMatrix</a> =  Eigen::Matrix&lt;Scalar, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix with one twist per column, and dynamically many columns. </p>

</div>
</div>
<a id="afbf249fd84580486a877500bed5a0b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf249fd84580486a877500bed5a0b8e">&#9670;&nbsp;</a></span>TwistVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#afbf249fd84580486a877500bed5a0b8e">TwistVector</a> =  Eigen::Matrix&lt;Scalar, <a class="el" href="namespacemaliput_1_1drake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector consisting of one twist. </p>

</div>
</div>
<a id="a01ae662d5635b7c9efe03d15d976f7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ae662d5635b7c9efe03d15d976f7a8">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a> =  Eigen::Matrix&lt;Scalar, Rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector templated on the number of rows. </p>

</div>
</div>
<a id="acda0b15d77e4c1701d160b17a2cb2ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda0b15d77e4c1701d160b17a2cb2ea8">&#9670;&nbsp;</a></span>Vector0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#acda0b15d77e4c1701d160b17a2cb2ea8">Vector0</a> =  Eigen::Matrix&lt;Scalar, 0, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The empty column vector (zero rows, one column), templated on scalar type. </p>

</div>
</div>
<a id="af359dfdb84d6c13b606bb3ed7b821e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359dfdb84d6c13b606bb3ed7b821e23">&#9670;&nbsp;</a></span>Vector1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#af359dfdb84d6c13b606bb3ed7b821e23">Vector1</a> =  Eigen::Matrix&lt;Scalar, 1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 1 (that is, a scalar), templated on scalar type. </p>

</div>
</div>
<a id="a6d923e79e6e92c2556edd86520145077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d923e79e6e92c2556edd86520145077">&#9670;&nbsp;</a></span>Vector1d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a6d923e79e6e92c2556edd86520145077">Vector1d</a> =  Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 1 of doubles. </p>

</div>
</div>
<a id="ab9f8b7dbd727440c2dd207bf43812f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f8b7dbd727440c2dd207bf43812f1e">&#9670;&nbsp;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a> =  Eigen::Matrix&lt;Scalar, 2, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 2, templated on scalar type. </p>

</div>
</div>
<a id="a0ad29daab565ce347c4d1c5aae6a76c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad29daab565ce347c4d1c5aae6a76c2">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a> =  Eigen::Matrix&lt;Scalar, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 3, templated on scalar type. </p>

</div>
</div>
<a id="af7e96394aef85f13f3fc84d3c3c238b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e96394aef85f13f3fc84d3c3c238b3">&#9670;&nbsp;</a></span>Vector4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a> =  Eigen::Matrix&lt;Scalar, 4, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 4, templated on scalar type. </p>

</div>
</div>
<a id="a14aa433aedda321a15238f2d4074d4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14aa433aedda321a15238f2d4074d4c3">&#9670;&nbsp;</a></span>Vector6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a> =  Eigen::Matrix&lt;Scalar, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 6. </p>

</div>
</div>
<a id="a44f103cf5fdeb3f539ceeeb9cd3a0a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f103cf5fdeb3f539ceeeb9cd3a0a28">&#9670;&nbsp;</a></span>Vector6d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> =  Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 6 of doubles. </p>

</div>
</div>
<a id="adfbacdba0566fe8958cfafd659b4373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbacdba0566fe8958cfafd659b4373f">&#9670;&nbsp;</a></span>VectorUpTo6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#adfbacdba0566fe8958cfafd659b4373f">VectorUpTo6</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1, 0, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of dynamic size templated on scalar type, up to a maximum of 6 elements. </p>

</div>
</div>
<a id="a77dd228fb4dd66a2c17dd3f7f38ffd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">&#9670;&nbsp;</a></span>VectorX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of any size, templated on scalar type. </p>

</div>
</div>
<a id="a00cbebcd97766579bb36e35abcf44acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cbebcd97766579bb36e35abcf44acf">&#9670;&nbsp;</a></span>VectorXPoly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a>, Eigen::Dynamic, 1&gt; <a class="el" href="namespacemaliput_1_1drake.html#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of polynomials; used in several optimization classes. </p>

</div>
</div>
<a id="af98fed5f98c376f4d45fff56bb96c8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98fed5f98c376f4d45fff56bb96c8e1">&#9670;&nbsp;</a></span>WrenchVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1drake.html#af98fed5f98c376f4d45fff56bb96c8e1">WrenchVector</a> =  Eigen::Matrix&lt;Scalar, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector consisting of one wrench (spatial force) = <code>[r X f; f]</code>, where f is a force (translational force) applied at a point <code>P</code> and <code>r</code> is the position vector from a point <code>O</code> (called the "moment center") to point <code>P</code>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a72383be4710d27584d0821effc6506a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72383be4710d27584d0821effc6506a5">&#9670;&nbsp;</a></span>RandomDistribution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drake supports explicit reasoning about a few carefully chosen random distributions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50"></a>kUniform&#160;</td><td class="fielddoc"><p>Vector elements are independent and uniformly distributed ∈ [0.0, 1.0). </p>
</td></tr>
<tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0"></a>kGaussian&#160;</td><td class="fielddoc"><p>Vector elements are independent and drawn from a mean-zero, unit-variance normal (Gaussian) distribution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6"></a>kExponential&#160;</td><td class="fielddoc"><p>Vector elements are independent and drawn from an exponential distribution with λ=1.0. </p>
</td></tr>
</table>

</div>
</div>
<a id="af8777bc10296f9d39d52753861110e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8777bc10296f9d39d52753861110e26">&#9670;&nbsp;</a></span>ToleranceType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a"></a>kAbsolute&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384"></a>kRelative&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a18197d6999dda546d996d5b8dfccd53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18197d6999dda546d996d5b8dfccd53a">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar maliput::drake::all </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks truth for all elements in matrix <code>m</code>. </p>
<p>This is identical to <code><a class="el" href="namespacemaliput_1_1drake.html#a18197d6999dda546d996d5b8dfccd53a" title="Checks truth for all elements in matrix m.">Eigen::DenseBase::all()</a></code>, except this function allows for lazy evaluation, so works even when <a class="el" href="structmaliput_1_1drake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">scalar_predicate&lt;&gt;::is_bool</a> does not hold. An empty matrix returns true. </p>

</div>
</div>
<a id="aea88dde6d4dd05c07a631ac8b94ef5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea88dde6d4dd05c07a631ac8b94ef5e7">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;typename Derived::Scalar&gt; maliput::drake::all_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code>pred</code> holds for all elements in the matrix <code>m</code>. </p>
<p>An empty matrix returns true. </p>

</div>
</div>
<a id="a87f661d87ca8519af1494a8c045aef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f661d87ca8519af1494a8c045aef91">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar maliput::drake::any </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks truth for at least one element in matrix <code>m</code>. </p>
<p>This is identical to <code><a class="el" href="namespacemaliput_1_1drake.html#a87f661d87ca8519af1494a8c045aef91" title="Checks truth for at least one element in matrix m.">Eigen::DenseBase::any()</a></code>, except this function allows for lazy evaluation, so works even when <a class="el" href="structmaliput_1_1drake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">scalar_predicate&lt;&gt;::is_bool</a> does not hold. An empty matrix returns false. </p>

</div>
</div>
<a id="a581bce854832eed48d47ead042014dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581bce854832eed48d47ead042014dd0">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;typename Derived::Scalar&gt; maliput::drake::any_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code>pred</code> holds for at least one element in the matrix <code>m</code>. </p>
<p>An empty matrix returns false. </p>

</div>
</div>
<a id="a7459c4a03d4b4f77eea119df933489da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7459c4a03d4b4f77eea119df933489da">&#9670;&nbsp;</a></span>CalcProbabilityDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T CalcProbabilityDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a>&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the density (probability density function) of the multivariate distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distribution</td><td>The distribution type. </td></tr>
    <tr><td class="paramname">x</td><td>The value of the sampled vector. @tparam_nonsymbolic_scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When instantiating this function, the user needs to explicitly pass in the scalar type, for example CalcProbabilityDensity&lt;double&gt;(...), the compiler might have problem to deduce the scalar type automatically. </dd></dl>

</div>
</div>
<a id="a10bce133654002443b7d69eec8835b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bce133654002443b7d69eec8835b39">&#9670;&nbsp;</a></span>CalcProbabilityDensity&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classdouble.html">double</a> <a class="el" href="namespacemaliput_1_1drake.html#a7459c4a03d4b4f77eea119df933489da">maliput::drake::CalcProbabilityDensity</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef84e5a8cff869d8a840d52578ae89db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef84e5a8cff869d8a840d52578ae89db">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maliput::drake::DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;2020-08-01&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Provide a specific overload of <a class="el" href="namespacemaliput_1_1drake.html#ab4b4b76d02b97e432f12b85f16d06a83">ExtractDoubleOrThrow</a> for <a class="el" href="namespacemaliput_1_1drake.html#a87f661d87ca8519af1494a8c045aef91">any</a> &quot; &quot;type that really is sensible at compile time and should &quot; &quot;defer failure to runtime; this version was too generic.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a ScalarType value to a double, failing at runtime (not compile time) if the type cannot be converted to a double. </p>
<p>This function is useful for writing ScalarType-generic code that (1) can reasonably discard any supplemental scalar data, e.g., the derivatives of an AutoDiffScalar, and (2) is reasonable to fail at runtime if the extraction fails.</p>
<p>The default implementation throws an exception. ScalarTypes that can hold a numeric value must overload this method to provide an appropriate extraction. An overload for <code>double</code> is already provided.</p>
<p>See autodiff_overloads.h to use this with Eigen's AutoDiffScalar. See symbolic_expression.h to use this with symbolic::Expression. </p>

</div>
</div>
<a id="a44c423659476de5c504384a34a7a48de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c423659476de5c504384a34a7a48de">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; maliput::drake::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if the cast fails, returns nullptr. </p>
<p>Casting is performed using <code>dynamic_cast</code> on the managed value (i.e., the result of <code>other.get()</code>). On success, <code>other</code>'s managed value is transferred to the result and <code>other</code> is empty; on failure, <code>other</code> will retain its original managed value and the result is empty. As with <code>dynamic_cast</code>, casting nullptr to anything always succeeds, so a nullptr result could indicate either that the argument was nullptr or that the cast failed.</p>
<p>This method is analogous to the built-in std::dynamic_pointer_cast that operates on a std::shared_ptr.</p>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="afdc8d19ae3df0e6cb635460680f4335d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc8d19ae3df0e6cb635460680f4335d">&#9670;&nbsp;</a></span>dynamic_pointer_cast_or_throw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; maliput::drake::dynamic_pointer_cast_or_throw </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if <code>other</code> is nullptr or the cast fails, throws a std::exception. </p>
<p>Casting is performed using <code>dynamic_cast</code> on the managed value (i.e., the result of <code>other.get()</code>). On success, <code>other</code>'s managed value is transferred to the result and <code>other</code> is empty; on failure, <code>other</code> will retain its original managed value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the cast fails.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="acbb565e9a203554c64228bfea2808935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb565e9a203554c64228bfea2808935">&#9670;&nbsp;</a></span>ExtractDoubleOrThrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdouble.html">double</a>&gt;, Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, Derived::Options, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt; maliput::drake::ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code>matrix</code>. </p>
<p>Calls ExtractDoubleOrThrow on each element of the matrix, and therefore throws if any one of the extractions fail. </p>

</div>
</div>
<a id="ab4b4b76d02b97e432f12b85f16d06a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b4b76d02b97e432f12b85f16d06a83">&#9670;&nbsp;</a></span>ExtractDoubleOrThrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> maliput::drake::ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>scalar</code> as a double. Never throws. </p>

</div>
</div>
<a id="ad0a837d489bcc6395a68518f05f84171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a837d489bcc6395a68518f05f84171">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; char, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::string. </p>
<p>(Technically, any string based on <code>CharT = char</code>.) </p>

</div>
</div>
<a id="a7f49ebd9ac9892798c67660d47780bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f49ebd9ac9892798c67660d47780bb6">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T1, T2, Compare, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::map. </p>
<p>Note that there is no <code>hash_append</code> overload for <code>std::unordered_map</code>, and such an overload must never appear. See n3980.html::unordered for details. </p>

</div>
</div>
<a id="a135056b56b4b74592a8bb99e661e3824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135056b56b4b74592a8bb99e661e3824">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::optional. </p>
<p>Note that <code>std::hash&lt;std::optional&lt;T&gt;&gt;</code> provides the peculiar invariant that the hash of an <code>optional</code> bearing a value <code>v</code> shall evaluate to the same hash as that of the value <code>v</code> itself. Hash operations implemented with this <code>hash_append</code> do <em>not</em> provide that invariant. </p>

</div>
</div>
<a id="afd3a753d7c4264b50a08d98ab24cd9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3a753d7c4264b50a08d98ab24cd9b5">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::pair. </p>

</div>
</div>
<a id="abc126047be01b9fcf50d66794419b2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc126047be01b9fcf50d66794419b2f5">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Key, Compare, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::set. </p>
<p>Note that there is no <code>hash_append</code> overload for <code>std::unordered_set</code>, and such an overload must never appear. See n3980.html::unordered for details. </p>

</div>
</div>
<a id="a0284bfa9d633e202f564338a6cf623b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0284bfa9d633e202f564338a6cf623b4">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;T&gt; &gt; maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for integral constants. </p>

</div>
</div>
<a id="a5c729e47e35c048046d463e042446b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c729e47e35c048046d463e042446b36">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_enum_v&lt;T&gt; &gt; maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for enumerations. </p>

</div>
</div>
<a id="acb07677aa04f0138bd05f7d361466e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb07677aa04f0138bd05f7d361466e93">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt; &gt; maliput::drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for floating point values. </p>

</div>
</div>
<a id="ad61c75c1d13adf6bab150b67a38b84d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61c75c1d13adf6bab150b67a38b84d3">&#9670;&nbsp;</a></span>hash_append_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::hash_append_range </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for a range, as given by two iterators. </p>

</div>
</div>
<a id="aa157c1d75c2e52df3370e5f458022ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa157c1d75c2e52df3370e5f458022ee9">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1logging.html#a9cae370466ffb304c10aebea42eca26b">logging::logger</a> * log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an instance of a logger to use for logging; for example: </p>
<pre>
  <a class="el" href="namespacemaliput_1_1drake.html#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example:">maliput::drake::log()</a>-&gt;info("potato!")
</pre><p>See the <a class="el" href="text__logging_8h.html">text_logging.h</a> documentation for a short tutorial. </p>

</div>
</div>
<a id="a78e78dcc4c899c0f86a05e8f8c5df78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e78dcc4c899c0f86a05e8f8c5df78f">&#9670;&nbsp;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar maliput::drake::none </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that no elements of <code>m</code> are true. An empty matrix returns true. </p>

</div>
</div>
<a id="acfc3e8670f86d1c69eaf29ad072865cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc3e8670f86d1c69eaf29ad072865cc">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;typename Derived::Scalar&gt; maliput::drake::none_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code>pred</code> holds for no elements in the matrix <code>m</code>. </p>
<p>An empty matrix returns true. </p>

</div>
</div>
<a id="a689b232e965c2a9cb7b98e702eb8502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689b232e965c2a9cb7b98e702eb8502f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;U&gt; &amp;&amp; std::is_unsigned_v&lt;U&gt;, bool&gt; maliput::drake::operator!= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67239655b7c6173aa85ba63103d62382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67239655b7c6173aa85ba63103d62382">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;U&gt; &amp;&amp; std::is_unsigned_v&lt;U&gt;, bool&gt; maliput::drake::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b9bb65194582cce374b2a7d01a09610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9bb65194582cce374b2a7d01a09610">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; maliput::drake::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc287d6eb32ff6e9287c29d414a2e046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc287d6eb32ff6e9287c29d414a2e046">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;U&gt; &amp;&amp; std::is_unsigned_v&lt;U&gt;, bool&gt; maliput::drake::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6f5d094c05d975c3fb1eb735d7e0428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f5d094c05d975c3fb1eb735d7e0428">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;U&gt; &amp;&amp; std::is_unsigned_v&lt;U&gt;, bool&gt; maliput::drake::operator== </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8073dc48e59dfd721a71171a88763b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8073dc48e59dfd721a71171a88763b7e">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;U&gt; &amp;&amp; std::is_unsigned_v&lt;U&gt;, bool&gt; maliput::drake::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae8637931173103787c3afd15dbeb4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8637931173103787c3afd15dbeb4a1">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;U&gt; &amp;&amp; std::is_unsigned_v&lt;U&gt;, bool&gt; maliput::drake::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54e1a1d5235229e09f8af51fe653d896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e1a1d5235229e09f8af51fe653d896">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt;T&gt; maliput::drake::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;::PowerType&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides power function for <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a36150fcc9734997befa37c4c9c8ac80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36150fcc9734997befa37c4c9c8ac80b">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; maliput::drake::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; no runtime type checking is performed. </p>
<p>This method is analogous to the built-in std::static_pointer_cast that operates on a std::shared_ptr.</p>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="a04fe934638081d5266e1b191d2a3ae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fe934638081d5266e1b191d2a3ae7d">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string maliput::drake::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_identifier.html">maliput::drake::Identifier</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables use of identifiers with to_string. </p>
<p>It requires ADL to work. So, it should be invoked as: <code>to_string(id);</code> and should be preceded by <code>using std::to_string</code>. </p>

</div>
</div>
<a id="acbbd758ec364c16c9c4137651e771013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbd758ec364c16c9c4137651e771013">&#9670;&nbsp;</a></span>unused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::drake::unused </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning. </p>
<p>This can be called within function bodies to mark that certain parameters are unused.</p>
<p>When possible, removing the unused parameter is better than placating the warning. However, in some cases the parameter is part of a virtual API or template concept that is used elsewhere, so we can't remove it. In those cases, this function might be an appropriate work-around.</p>
<p>Here's rough advice on how to fix Wunused-parameter warnings:</p>
<p>(1) If the parameter can be removed entirely, prefer that as the first choice. (This may not be possible if, e.g., a method must match some virtual API or template concept.)</p>
<p>(2) Unless the parameter name has acute value, prefer to omit the name of the parameter, leaving only the type, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Print(<span class="keyword">const</span> State&amp; state)<span class="keyword"> override </span>{ <span class="comment">/* No state to print. */</span> }</div>
</div><!-- fragment --><p> changes to </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Print(<span class="keyword">const</span> State&amp;)<span class="keyword"> override </span>{ <span class="comment">/* No state to print. */</span>}</div>
</div><!-- fragment --><p> This no longer triggers the warning and further makes it clear that a parameter required by the API is definitively unused in the function.</p>
<p>This is an especially good solution in the context of method definitions (vs declarations); the parameter name used in a definition is entirely irrelevant to Doxygen and most readers.</p>
<p>(3) When leaving the parameter name intact has acute value, it is acceptable to keep the name and mark it <code>unused</code>. For example, when the name appears as part of a virtual method's base class declaration, the name is used by Doxygen to document the method, e.g., </p><div class="fragment"><div class="line"><span class="comment">   /** Sets the default State of a System.  This default implementation is to</span></div>
<div class="line"><span class="comment">*      set all zeros.  Subclasses may override to use non-zero defaults.  The</span></div>
<div class="line"><span class="comment">*      custom defaults may be based on the given @p context, when relevant.  */</span></div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> SetDefault(<span class="keyword">const</span> Context&lt;T&gt;&amp; context, State&lt;T&gt;* state)<span class="keyword"> const </span>{</div>
<div class="line">     <a class="code" href="namespacemaliput_1_1drake.html#acbbd758ec364c16c9c4137651e771013">unused</a>(context);</div>
<div class="line">     state-&gt;SetZero();</div>
<div class="line">   }</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae5ffa02b326b2dd39e7f6cbc4606b61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ffa02b326b2dd39e7f6cbc4606b61c">&#9670;&nbsp;</a></span>kDrakeAssertIsArmed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool kDrakeAssertIsArmed = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaef73489ed741143f9d712623e53b6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef73489ed741143f9d712623e53b6da">&#9670;&nbsp;</a></span>kDrakeAssertIsDisarmed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool kDrakeAssertIsDisarmed = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c55e4d8662e0986e79d11486334486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c55e4d8662e0986e79d11486334486">&#9670;&nbsp;</a></span>kHomogeneousTransformSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int kHomogeneousTransformSize = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/">http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/</a> </p>

</div>
</div>
<a id="affa3b7e9b38e1a49824ae3edfcca411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa3b7e9b38e1a49824ae3edfcca411f">&#9670;&nbsp;</a></span>kMaxNamePart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int kMaxNamePart = 923521</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4278037dcb693a8ee6b06709bf630e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4278037dcb693a8ee6b06709bf630e7c">&#9670;&nbsp;</a></span>kNameChars</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char kNameChars[] = &quot;@#_.abcdefghijklmnopqrstuvwxyz&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8beaa96b5dc7c903f4412e3f6ce95bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8beaa96b5dc7c903f4412e3f6ce95bf9">&#9670;&nbsp;</a></span>kNameLength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int kNameLength = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3eb8cf48cd1a44df66b82ec47978884b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb8cf48cd1a44df66b82ec47978884b">&#9670;&nbsp;</a></span>kNumNameChars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int kNumNameChars = sizeof(<a class="el" href="namespacemaliput_1_1drake.html#a4278037dcb693a8ee6b06709bf630e7c">kNameChars</a>) - 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07869e660ffe730425feca7595de2273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07869e660ffe730425feca7595de2273">&#9670;&nbsp;</a></span>kQuaternionSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int kQuaternionSize = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace32fe90adc0d2100ad4fc9f4bc6f79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace32fe90adc0d2100ad4fc9f4bc6f79a">&#9670;&nbsp;</a></span>kRotmatSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int kRotmatSize = <a class="el" href="namespacemaliput_1_1drake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a> * <a class="el" href="namespacemaliput_1_1drake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeab5b0d99cafc2f6ae5812128cea27a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab5b0d99cafc2f6ae5812128cea27a3">&#9670;&nbsp;</a></span>kRpySize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int kRpySize = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af869092c52ed7cc9d2db40ce56050c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af869092c52ed7cc9d2db40ce56050c7c">&#9670;&nbsp;</a></span>kSpaceDimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int kSpaceDimension = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9ce1d9cce0ad61dd2f5a295c1a10fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">&#9670;&nbsp;</a></span>kTwistSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int kTwistSize = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="https://en.wikipedia.org/wiki/Screw_theory#Twist">https://en.wikipedia.org/wiki/Screw_theory#Twist</a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacemaliput_1_1drake_html_acbbd758ec364c16c9c4137651e771013"><div class="ttname"><a href="namespacemaliput_1_1drake.html#acbbd758ec364c16c9c4137651e771013">maliput::drake::unused</a></div><div class="ttdeci">void unused(const Args &amp;...)</div><div class="ttdoc">Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning.</div><div class="ttdef"><b>Definition:</b> unused.h:51</div></div>
<div class="ttc" id="anamespacemaliput_1_1drake_html_a158f68939b94f6c2c5ea353d652919da"><div class="ttname"><a href="namespacemaliput_1_1drake.html#a158f68939b94f6c2c5ea353d652919da">maliput::drake::is_cloneable</a></div><div class="ttdeci">is_cloneable_internal::is_cloneable_helper&lt; T, void &gt; is_cloneable</div><div class="ttdef"><b>Definition:</b> is_cloneable.h:80</div></div>
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemaliput.html">maliput</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1drake.html">drake</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

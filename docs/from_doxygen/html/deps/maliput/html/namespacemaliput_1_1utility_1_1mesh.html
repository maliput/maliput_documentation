<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput: maliput::utility::mesh Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemaliput_1_1utility_1_1mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">maliput::utility::mesh Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for a directed edge in a <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html" title="An Inertial-frame mesh: a collection of GeoFaces.">GeoMesh</a>.  <a href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for a face edge in a <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html" title="An Inertial-frame mesh: a collection of GeoFaces.">GeoMesh</a>.  <a href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a face vertex in a <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html" title="An Inertial-frame mesh: a collection of GeoFaces.">GeoMesh</a>.  <a href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html">GeoFace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>Inertial</code>-frame face: a sequence of vertices with corresponding normals.  <a href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>Inertial</code>-frame mesh: a collection of GeoFaces.  <a href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_normal.html">GeoNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>Inertial</code>-frame normal vector.  <a href="classmaliput_1_1utility_1_1mesh_1_1_geo_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_vertex.html">GeoVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>Inertial</code>-frame vertex.  <a href="classmaliput_1_1utility_1_1mesh_1_1_geo_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A face &mdash; a sequence of vertices with normals &mdash; in which the vertices and normals are represented by integer indices into some other container/dictionary.  <a href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_srh_face.html">SrhFace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>Lane</code>-frame face: a sequence of vertices expressed in the (s,r,h) coordinates of an <a class="el" href="classmaliput_1_1api_1_1_lane.html" title="A Lane represents a lane of travel in a road network.">api::Lane</a> (which is not referenced here).  <a href="classmaliput_1_1utility_1_1mesh_1_1_srh_face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_unique_indexer.html">UniqueIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for a set of unique objects which keeps track of the original insertion order.  <a href="classmaliput_1_1utility_1_1mesh_1_1_unique_indexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a83f3d8cd29f06d414cc5fcc8a8718a9f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a83f3d8cd29f06d414cc5fcc8a8718a9f">InverseFaceEdgeMap</a> = std::unordered_map&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a>, <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a>, <a class="el" href="namespacemaliput_1_1common.html#ae925cde990a915749d22776d5b22b6a4">maliput::common::DefaultHash</a> &gt;</td></tr>
<tr class="memdesc:a83f3d8cd29f06d414cc5fcc8a8718a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the mapping from face edges indices to their associated directed edge indices.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a83f3d8cd29f06d414cc5fcc8a8718a9f">More...</a><br /></td></tr>
<tr class="separator:a83f3d8cd29f06d414cc5fcc8a8718a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f052e0b8f2e37cd7b5bbf88aa3f3f68"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> = std::unordered_map&lt; int, std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &gt; &gt;</td></tr>
<tr class="memdesc:a1f052e0b8f2e37cd7b5bbf88aa3f3f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from each <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html" title="A face — a sequence of vertices with normals — in which the vertices and normals are represented by i...">IndexFace</a> index in a given <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html" title="An Inertial-frame mesh: a collection of GeoFaces.">GeoMesh</a> to each of its adjacent faces, along with the index of the edge these share.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">More...</a><br /></td></tr>
<tr class="separator:a1f052e0b8f2e37cd7b5bbf88aa3f3f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae6e6580251dde893b43a4ed26c108ad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#ae6e6580251dde893b43a4ed26c108ad6">DistanceToAPlane</a> (const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> n, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> p, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> q)</td></tr>
<tr class="memdesc:ae6e6580251dde893b43a4ed26c108ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let \(B\) be a plane in the 3D Inertial Frame defined by a point \(p\) and a normal non-zero vector \(n\), and let \(q\) be another point in the 3D Inertial Frame.  <a href="namespacemaliput_1_1utility_1_1mesh.html#ae6e6580251dde893b43a4ed26c108ad6">More...</a><br /></td></tr>
<tr class="separator:ae6e6580251dde893b43a4ed26c108ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23497997c2e46655d8f921074440f7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a23497997c2e46655d8f921074440f7e1">DistanceToALine</a> (const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;p, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;r, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;q)</td></tr>
<tr class="memdesc:a23497997c2e46655d8f921074440f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let \(F(t) = P + Rt\) be a parametric line in the 3D Inertial Frame defined by a point \(P\) and a vector \(R\), and let \(Q\) be another point in the 3D Inertial Frame.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a23497997c2e46655d8f921074440f7e1">More...</a><br /></td></tr>
<tr class="separator:a23497997c2e46655d8f921074440f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0705bc6329e73d0b7ee738ca2fd2d590"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a0705bc6329e73d0b7ee738ca2fd2d590">operator==</a> (const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;lhs, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;rhs)</td></tr>
<tr class="separator:a0705bc6329e73d0b7ee738ca2fd2d590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2ca0b552c66ea28ba0c9f83796048d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a3a2ca0b552c66ea28ba0c9f83796048d">operator!=</a> (const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;lhs, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;rhs)</td></tr>
<tr class="separator:a3a2ca0b552c66ea28ba0c9f83796048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382fd642950e26e3cae0cc2c52723e8a"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm &gt; </td></tr>
<tr class="memitem:a382fd642950e26e3cae0cc2c52723e8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a382fd642950e26e3cae0cc2c52723e8a">hash_append</a> (HashAlgorithm &amp;hasher, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;item) noexcept</td></tr>
<tr class="memdesc:a382fd642950e26e3cae0cc2c52723e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the <a class="el" href="group__hash__append.html">hash_append generic hashing</a> concept.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a382fd642950e26e3cae0cc2c52723e8a">More...</a><br /></td></tr>
<tr class="separator:a382fd642950e26e3cae0cc2c52723e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8962fcc82c75e1f6a7406773e97752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a9a8962fcc82c75e1f6a7406773e97752">operator==</a> (const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;lhs, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;rhs)</td></tr>
<tr class="separator:a9a8962fcc82c75e1f6a7406773e97752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2265f079a1b89a718188e8a67765595f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a2265f079a1b89a718188e8a67765595f">operator!=</a> (const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;lhs, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;rhs)</td></tr>
<tr class="separator:a2265f079a1b89a718188e8a67765595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec9c63109996e947e543024bbe97a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a83f3d8cd29f06d414cc5fcc8a8718a9f">InverseFaceEdgeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a4ec9c63109996e947e543024bbe97a66">ComputeInverseFaceEdgeMap</a> (const std::vector&lt; <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &gt; &amp;faces)</td></tr>
<tr class="memdesc:a4ec9c63109996e947e543024bbe97a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the mapping from face edges indices to their associated directed edge indices for the given <code>faces</code> collection.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a4ec9c63109996e947e543024bbe97a66">More...</a><br /></td></tr>
<tr class="separator:a4ec9c63109996e947e543024bbe97a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c154886288f7baff88baaa6db62187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a78c154886288f7baff88baaa6db62187">ComputeFaceAdjacencyMap</a> (const std::vector&lt; <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &gt; &amp;faces)</td></tr>
<tr class="memdesc:a78c154886288f7baff88baaa6db62187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a mapping from each <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html" title="A face — a sequence of vertices with normals — in which the vertices and normals are represented by i...">IndexFace</a> index in <code>faces</code> to each of its adjacent faces, along with the index of the edge these share.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a78c154886288f7baff88baaa6db62187">More...</a><br /></td></tr>
<tr class="separator:a78c154886288f7baff88baaa6db62187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29781b271fd07c9369805d9d3d6b37f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#af29781b271fd07c9369805d9d3d6b37f">GetMeshFaceVertexPosition</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> &amp;vertex)</td></tr>
<tr class="memdesc:af29781b271fd07c9369805d9d3d6b37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets global position of the <code>vertex</code> in the given <code>mesh</code>.  <a href="namespacemaliput_1_1utility_1_1mesh.html#af29781b271fd07c9369805d9d3d6b37f">More...</a><br /></td></tr>
<tr class="separator:af29781b271fd07c9369805d9d3d6b37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9a0114f0084b27234129f41a38b822"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a7f9a0114f0084b27234129f41a38b822">GetMeshFaceVertexNormal</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> &amp;vertex)</td></tr>
<tr class="memdesc:a7f9a0114f0084b27234129f41a38b822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets normal vector of the <code>vertex</code> in the given <code>mesh</code>.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a7f9a0114f0084b27234129f41a38b822">More...</a><br /></td></tr>
<tr class="separator:a7f9a0114f0084b27234129f41a38b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5db97c41ee4de1d66e82a36aabd606"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a6c5db97c41ee4de1d66e82a36aabd606"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a6c5db97c41ee4de1d66e82a36aabd606">DoMeshVerticesLieOnPlane</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, InputIt first, InputIt last, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;n, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;p, <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:a6c5db97c41ee4de1d66e82a36aabd606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> instances, from <code>first</code> to <code>last</code>, in the given <code>mesh</code> lie on the provided plane defined by a normal non-zero vector <code>n</code> and a point <code>p</code> by verifying all of them are within one <code>tolerance</code> distance, in meters, away from it along the line subtended by its normal.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a6c5db97c41ee4de1d66e82a36aabd606">More...</a><br /></td></tr>
<tr class="separator:a6c5db97c41ee4de1d66e82a36aabd606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8c31be76386a45724fb375e38a890b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#aaf8c31be76386a45724fb375e38a890b">IsMeshFaceCoplanarWithPlane</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &amp;face, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;n, const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;p, <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:aaf8c31be76386a45724fb375e38a890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the <code>face</code> in the given <code>mesh</code> is coplanar with the given plane defined by a normal non-zero vector <code>n</code> and a point <code>p</code>, by verifying if all <code>face</code> vertices are within one <code>tolerance</code> distance, in meters, from it.  <a href="namespacemaliput_1_1utility_1_1mesh.html#aaf8c31be76386a45724fb375e38a890b">More...</a><br /></td></tr>
<tr class="separator:aaf8c31be76386a45724fb375e38a890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9b3b4c9e5c0a0679b51b2a6c752f88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a3c9b3b4c9e5c0a0679b51b2a6c752f88">IsMeshFacePlanar</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &amp;face, <a class="el" href="classdouble.html">double</a> tolerance, <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> *n, <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> *p)</td></tr>
<tr class="memdesc:a3c9b3b4c9e5c0a0679b51b2a6c752f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the <code>face</code> in the given <code>mesh</code> is planar, by verifying all <code>face</code> vertices lie on a plane using the given <code>tolerance</code> (see <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a6c5db97c41ee4de1d66e82a36aabd606" title="Checks if all the IndexFace::Vertex instances, from first to last, in the given mesh lie on the provi...">DoMeshVerticesLieOnPlane()</a>).  <a href="namespacemaliput_1_1utility_1_1mesh.html#a3c9b3b4c9e5c0a0679b51b2a6c752f88">More...</a><br /></td></tr>
<tr class="separator:a3c9b3b4c9e5c0a0679b51b2a6c752f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f7866b6c3ed71ee6882c943b63c869"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a85f7866b6c3ed71ee6882c943b63c869">AggregateAdjacentCoplanarMeshFaces</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, int start_face_index, const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;adjacent_faces_map, <a class="el" href="classdouble.html">double</a> tolerance, std::set&lt; int &gt; *visited_faces_indices)</td></tr>
<tr class="memdesc:a85f7866b6c3ed71ee6882c943b63c869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates all coplanar faces adjacent to the referred face in the <code>mesh</code>.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a85f7866b6c3ed71ee6882c943b63c869">More...</a><br /></td></tr>
<tr class="separator:a85f7866b6c3ed71ee6882c943b63c869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4941b76cb69d136a39d4ef014d6e74e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a4941b76cb69d136a39d4ef014d6e74e2">FindOuterFaceEdgeIndex</a> (const std::set&lt; int &gt; &amp;simply_connected_faces_indices, const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;adjacent_faces_map)</td></tr>
<tr class="memdesc:a4941b76cb69d136a39d4ef014d6e74e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index to the first outer face edge in the given <code>simply_connected_faces_indices</code>.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a4941b76cb69d136a39d4ef014d6e74e2">More...</a><br /></td></tr>
<tr class="separator:a4941b76cb69d136a39d4ef014d6e74e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2e80aea3e5eb6ba14352362220d658"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1b2e80aea3e5eb6ba14352362220d658">ComputeMeshFacesContour</a> (const std::set&lt; int &gt; &amp;simply_connected_faces_indices, const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;adjacent_faces_map)</td></tr>
<tr class="memdesc:a1b2e80aea3e5eb6ba14352362220d658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the contour of the simply connected region that all the faces referred by the given <code>simply_connected_faces_indices</code> yield.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a1b2e80aea3e5eb6ba14352362220d658">More...</a><br /></td></tr>
<tr class="separator:a1b2e80aea3e5eb6ba14352362220d658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68da2fa1cf69840d3ab532a2eaca6ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#af68da2fa1cf69840d3ab532a2eaca6ab">MeshFaceVertexAt</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &amp;face_vertex_index)</td></tr>
<tr class="memdesc:af68da2fa1cf69840d3ab532a2eaca6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face vertex in the <code>mesh</code> referred by the given <code>face_vertex_index</code>.  <a href="namespacemaliput_1_1utility_1_1mesh.html#af68da2fa1cf69840d3ab532a2eaca6ab">More...</a><br /></td></tr>
<tr class="separator:af68da2fa1cf69840d3ab532a2eaca6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997a1a822ff6cc86c61826a852f688b8"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename VertexFn , typename EdgeFn , typename OutputIt &gt; </td></tr>
<tr class="memitem:a997a1a822ff6cc86c61826a852f688b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a997a1a822ff6cc86c61826a852f688b8">ApplyDouglasPeuckerSimplification</a> (InputIt first, InputIt last, VertexFn to_vertex, EdgeFn to_edge, <a class="el" href="classdouble.html">double</a> tolerance, OutputIt output)</td></tr>
<tr class="memdesc:a997a1a822ff6cc86c61826a852f688b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Douglas-Peucker simplification algorithm [1] over the given collection of vertices.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a997a1a822ff6cc86c61826a852f688b8">More...</a><br /></td></tr>
<tr class="separator:a997a1a822ff6cc86c61826a852f688b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa02ac8a38e63f82760f2bb81113cdc5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#aaa02ac8a38e63f82760f2bb81113cdc5">SimplifyMeshFacesContour</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &gt; &amp;contour_indices, <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:aaa02ac8a38e63f82760f2bb81113cdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the <code>mesh</code> faces' contour referred by the given <code>contour_indices</code> by elimination of redundant vertices, i.e.  <a href="namespacemaliput_1_1utility_1_1mesh.html#aaa02ac8a38e63f82760f2bb81113cdc5">More...</a><br /></td></tr>
<tr class="separator:aaa02ac8a38e63f82760f2bb81113cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4597a0b90338ac00cd3da265c0cd852a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html">GeoFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a4597a0b90338ac00cd3da265c0cd852a">MergeMeshFaces</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;mesh, const std::set&lt; int &gt; &amp;mergeable_faces_indices, const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;adjacent_faces_map, <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:a4597a0b90338ac00cd3da265c0cd852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all the faces in the given <code>mesh</code> referred by <code>mergeable_faces_indices</code> into a single <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html" title="An Inertial-frame face: a sequence of vertices with corresponding normals.">GeoFace</a>.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a4597a0b90338ac00cd3da265c0cd852a">More...</a><br /></td></tr>
<tr class="separator:a4597a0b90338ac00cd3da265c0cd852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a072cc288bb47405029aed3f5e95134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1a072cc288bb47405029aed3f5e95134">SimplifyMeshFaces</a> (const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;input_mesh, <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="memdesc:a1a072cc288bb47405029aed3f5e95134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies a mesh by merging adjacent coplanar faces.  <a href="namespacemaliput_1_1utility_1_1mesh.html#a1a072cc288bb47405029aed3f5e95134">More...</a><br /></td></tr>
<tr class="separator:a1a072cc288bb47405029aed3f5e95134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1f052e0b8f2e37cd7b5bbf88aa3f3f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">&#9670;&nbsp;</a></span>FaceAdjacencyMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> =  std::unordered_map&lt;int, std::vector&lt;<a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mapping from each <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html" title="A face — a sequence of vertices with normals — in which the vertices and normals are represented by i...">IndexFace</a> index in a given <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html" title="An Inertial-frame mesh: a collection of GeoFaces.">GeoMesh</a> to each of its adjacent faces, along with the index of the edge these share. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html" title="Index for a face edge in a GeoMesh.">FaceEdgeIndex</a> </dd></dl>

</div>
</div>
<a id="a83f3d8cd29f06d414cc5fcc8a8718a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f3d8cd29f06d414cc5fcc8a8718a9f">&#9670;&nbsp;</a></span>InverseFaceEdgeMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a83f3d8cd29f06d414cc5fcc8a8718a9f">InverseFaceEdgeMap</a> =  std::unordered_map&lt;<a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a>, <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a>, <a class="el" href="namespacemaliput_1_1common.html#ae925cde990a915749d22776d5b22b6a4">maliput::common::DefaultHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inverse of the mapping from face edges indices to their associated directed edge indices. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a4ec9c63109996e947e543024bbe97a66" title="Computes the inverse of the mapping from face edges indices to their associated directed edge indices...">ComputeInverseFaceEdgeMap</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a85f7866b6c3ed71ee6882c943b63c869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f7866b6c3ed71ee6882c943b63c869">&#9670;&nbsp;</a></span>AggregateAdjacentCoplanarMeshFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; int &gt; AggregateAdjacentCoplanarMeshFaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacent_faces_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>visited_faces_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates all coplanar faces adjacent to the referred face in the <code>mesh</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Mesh where faces are to be found. </td></tr>
    <tr><td class="paramname">start_face_index</td><td>Index of the face to start aggregation with. </td></tr>
    <tr><td class="paramname">adjacent_faces_map</td><td>Map of adjacent faces associated with the given <code>mesh</code>. </td></tr>
    <tr><td class="paramname">tolerance</td><td>For coplanarity checks, in meters. See <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a3c9b3b4c9e5c0a0679b51b2a6c752f88" title="Checks if the face in the given mesh is planar, by verifying all face vertices lie on a plane using t...">IsMeshFacePlanar()</a> and <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#aaf8c31be76386a45724fb375e38a890b" title="Checks if the face in the given mesh is coplanar with the given plane defined by a normal non-zero ve...">IsMeshFaceCoplanarWithPlane()</a> functions for further details. </td></tr>
    <tr><td class="paramname">visited_faces_indices</td><td>The indices of the faces visited so far. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices of the adjacent coplanar faces found. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>start_face_index</code> is valid for the given <code>mesh</code>. </dd>
<dd>
Given <code>tolerance</code> is a positive real number. </dd>
<dd>
Given <code>visited_faces_indices</code> collection is not nullptr. </dd>
<dd>
Given <code>start_face_index</code> has not been visited yet (i.e. visited_faces_indices.count(start_face_index) == 0). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All adjacent coplanar faces found are marked as visited. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a997a1a822ff6cc86c61826a852f688b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997a1a822ff6cc86c61826a852f688b8">&#9670;&nbsp;</a></span>ApplyDouglasPeuckerSimplification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::utility::mesh::ApplyDouglasPeuckerSimplification </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexFn&#160;</td>
          <td class="paramname"><em>to_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeFn&#160;</td>
          <td class="paramname"><em>to_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Douglas-Peucker simplification algorithm [1] over the given collection of vertices. </p>
<ul>
<li>[1] Douglas, D. H., &amp; Peucker, T. K. (1973). Algorithms for the reduction of the number of points required to represent a digitized line or its caricature. Cartographica: The International Journal for Geographic Information and Geovisualization, 10(2), 112–122. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to first element of the collection. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the collection. </td></tr>
    <tr><td class="paramname">to_vertex</td><td>A function to retrieve the vertex associated with an element of the collection (may be a pass-through). </td></tr>
    <tr><td class="paramname">to_edge</td><td>A function to construct an edge out of a pair of vertices. This function must return a std::pair containing the origin vertex and the unit direction vector of the parametric line. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Simplification tolerance, in distance units. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator for the simplification result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Input iterators type. </td></tr>
    <tr><td class="paramname">VertexFn</td><td>Vertex getter function type. </td></tr>
    <tr><td class="paramname">EdgeFn</td><td>Edge building function type. </td></tr>
    <tr><td class="paramname">OutputIt</td><td>Output iterator type. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a78c154886288f7baff88baaa6db62187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c154886288f7baff88baaa6db62187">&#9670;&nbsp;</a></span>ComputeFaceAdjacencyMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> ComputeFaceAdjacencyMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a mapping from each <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html" title="A face — a sequence of vertices with normals — in which the vertices and normals are represented by i...">IndexFace</a> index in <code>faces</code> to each of its adjacent faces, along with the index of the edge these share. </p>
<p>For each face at index <code>i</code> in <code>faces</code>, a sequence to map each edge <code>j</code> to its adjacent face and edge index is added to the map at <code>i</code>. If a given edge is not adjacent to any face, an invalid face and edge index (both set to -1, see <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html" title="Index for a face edge in a GeoMesh.">FaceEdgeIndex</a>) is put in its place. </p><dl class="section pre"><dt>Precondition</dt><dd>Any given pair of vertices is shared by two faces at most. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a4ec9c63109996e947e543024bbe97a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec9c63109996e947e543024bbe97a66">&#9670;&nbsp;</a></span>ComputeInverseFaceEdgeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a83f3d8cd29f06d414cc5fcc8a8718a9f">InverseFaceEdgeMap</a> ComputeInverseFaceEdgeMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of the mapping from face edges indices to their associated directed edge indices for the given <code>faces</code> collection. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Mapping from directed edges to face edges is 1-to-1. In other words, any given pair of vertices can be shared by two faces at most. This implies that the mesh is well-oriented, such that any adjacent have the common edge in opposite directions. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a1b2e80aea3e5eb6ba14352362220d658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2e80aea3e5eb6ba14352362220d658">&#9670;&nbsp;</a></span>ComputeMeshFacesContour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &gt; ComputeMeshFacesContour </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>simply_connected_faces_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacent_faces_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the contour of the simply connected region that all the faces referred by the given <code>simply_connected_faces_indices</code> yield. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simply_connected_faces_indices</td><td>Indices of the faces whose outer face edge is to be found. </td></tr>
    <tr><td class="paramname">adjacent_faces_map</td><td>Mapping of adjacent faces for the faces referred in <code>simply_connected_faces_indices</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Face vertices as a counter-clockwise contour. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The union of the all the faces referred by the given <code>simply_connected_faces_indices</code> yield a simply connected region (i.e. with no holes). </dd></dl>

</div>
</div>
<a id="a23497997c2e46655d8f921074440f7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23497997c2e46655d8f921074440f7e1">&#9670;&nbsp;</a></span>DistanceToALine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> DistanceToALine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let \(F(t) = P + Rt\) be a parametric line in the 3D Inertial Frame defined by a point \(P\) and a vector \(R\), and let \(Q\) be another point in the 3D Inertial Frame. </p>
<p>This function returns the Euclidean distance of \(Q\) to \(F(t)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Is the origin of the parametric line. </td></tr>
    <tr><td class="paramname">r</td><td>Is the direction of the parametric line. </td></tr>
    <tr><td class="paramname">q</td><td>Is a coordinate out of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance of <code>q</code> point to the line \(F(t)\). </dd></dl>

</div>
</div>
<a id="ae6e6580251dde893b43a4ed26c108ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e6580251dde893b43a4ed26c108ad6">&#9670;&nbsp;</a></span>DistanceToAPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> DistanceToAPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let \(B\) be a plane in the 3D Inertial Frame defined by a point \(p\) and a normal non-zero vector \(n\), and let \(q\) be another point in the 3D Inertial Frame. </p>
<p>This method returns the Euclidean distance of \(q\) to \(B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Is a vector normal to the plane. </td></tr>
    <tr><td class="paramname">p</td><td>Is a coordinate in the plane. </td></tr>
    <tr><td class="paramname">q</td><td>Is a coordinate out of the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance of <code>q</code> point to the plane \(B\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The norm of <code>n</code> is different from zero. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a6c5db97c41ee4de1d66e82a36aabd606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5db97c41ee4de1d66e82a36aabd606">&#9670;&nbsp;</a></span>DoMeshVerticesLieOnPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maliput::utility::mesh::DoMeshVerticesLieOnPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all the <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> instances, from <code>first</code> to <code>last</code>, in the given <code>mesh</code> lie on the provided plane defined by a normal non-zero vector <code>n</code> and a point <code>p</code> by verifying all of them are within one <code>tolerance</code> distance, in meters, away from it along the line subtended by its normal. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>vertices</code> belong to the <code>mesh</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>An <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> container iterator type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4941b76cb69d136a39d4ef014d6e74e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4941b76cb69d136a39d4ef014d6e74e2">&#9670;&nbsp;</a></span>FindOuterFaceEdgeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> FindOuterFaceEdgeIndex </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>simply_connected_faces_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacent_faces_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index to the first outer face edge in the given <code>simply_connected_faces_indices</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simply_connected_faces_indices</td><td>Indices of the faces whose outer face edge is to be found. </td></tr>
    <tr><td class="paramname">adjacent_faces_map</td><td>Mapping of adjacent faces for the faces referred by <code>simply_connected_faces_indices</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of first outer face edge found or an invalid index if it failed to find any due to unmet preconditions. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The union of the all the faces referred by the given <code>simply_connected_faces_indices</code> yields a simply connected region (i.e. with no holes). </dd></dl>

</div>
</div>
<a id="a7f9a0114f0084b27234129f41a38b822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9a0114f0084b27234129f41a38b822">&#9670;&nbsp;</a></span>GetMeshFaceVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp; GetMeshFaceVertexNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets normal vector of the <code>vertex</code> in the given <code>mesh</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>vertex</code> belongs to the <code>mesh</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="af29781b271fd07c9369805d9d3d6b37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29781b271fd07c9369805d9d3d6b37f">&#9670;&nbsp;</a></span>GetMeshFaceVertexPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp; GetMeshFaceVertexPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets global position of the <code>vertex</code> in the given <code>mesh</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>vertex</code> belongs to the <code>mesh</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a382fd642950e26e3cae0cc2c52723e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382fd642950e26e3cae0cc2c52723e8a">&#9670;&nbsp;</a></span>hash_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maliput::utility::mesh::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the <a class="el" href="group__hash__append.html">hash_append generic hashing</a> concept. </p>

</div>
</div>
<a id="aaf8c31be76386a45724fb375e38a890b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8c31be76386a45724fb375e38a890b">&#9670;&nbsp;</a></span>IsMeshFaceCoplanarWithPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsMeshFaceCoplanarWithPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the <code>face</code> in the given <code>mesh</code> is coplanar with the given plane defined by a normal non-zero vector <code>n</code> and a point <code>p</code>, by verifying if all <code>face</code> vertices are within one <code>tolerance</code> distance, in meters, from it. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>face</code> belongs to the <code>mesh</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a3c9b3b4c9e5c0a0679b51b2a6c752f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9b3b4c9e5c0a0679b51b2a6c752f88">&#9670;&nbsp;</a></span>IsMeshFacePlanar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsMeshFacePlanar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_index_face.html">IndexFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1math_1_1_vector3.html">math::Vector3</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the <code>face</code> in the given <code>mesh</code> is planar, by verifying all <code>face</code> vertices lie on a plane using the given <code>tolerance</code> (see <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a6c5db97c41ee4de1d66e82a36aabd606" title="Checks if all the IndexFace::Vertex instances, from first to last, in the given mesh lie on the provi...">DoMeshVerticesLieOnPlane()</a>). </p>
<p>Said plane, built out of the first vertex position and normal in the <code>face</code>, is returned as a plane defined by a point <code>p</code> and a normal non-zero vector <code>n</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Is a <code>Inertial</code>-frame mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Is a sequence of vertices with normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Is the tolerance to compute face planarity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>Is a vector that with <code>p</code> define a plane that should contain all the face vertices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Is a point that with <code>n</code> define a plane that should contain all the face vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>n</code> is not nullptr. </dd>
<dd>
Given <code>p</code> is not nullptr. </dd>
<dd>
Given <code>face</code> belongs to the <code>mesh</code>. </dd>
<dd>
Given <code>face</code> has at least three (3) vertices. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a4597a0b90338ac00cd3da265c0cd852a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4597a0b90338ac00cd3da265c0cd852a">&#9670;&nbsp;</a></span>MergeMeshFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html">GeoFace</a> MergeMeshFaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mergeable_faces_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a1f052e0b8f2e37cd7b5bbf88aa3f3f68">FaceAdjacencyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacent_faces_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges all the faces in the given <code>mesh</code> referred by <code>mergeable_faces_indices</code> into a single <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html" title="An Inertial-frame face: a sequence of vertices with corresponding normals.">GeoFace</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Mesh the faces to be merged belong to. </td></tr>
    <tr><td class="paramname">mergeable_faces_indices</td><td>Indices of the faces in <code>mesh</code> to be merged. </td></tr>
    <tr><td class="paramname">adjacent_faces_map</td><td>Mapping of adjacent faces for the faces referred in <code>mergeable_faces_indices</code>. </td></tr>
    <tr><td class="paramname">tolerance</td><td>For contour simplification, in meters. See <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#aaa02ac8a38e63f82760f2bb81113cdc5" title="Simplifies the mesh faces&#39; contour referred by the given contour_indices by elimination of redundant ...">SimplifyMeshFacesContour()</a> function for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Merged mesh faces as a single <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_face.html" title="An Inertial-frame face: a sequence of vertices with corresponding normals.">GeoFace</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The union of the all the faces referred by the given <code>mergeable_faces_indices</code> yields a simply connected region (i.e. with no holes). </dd></dl>

</div>
</div>
<a id="af68da2fa1cf69840d3ab532a2eaca6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68da2fa1cf69840d3ab532a2eaca6ab">&#9670;&nbsp;</a></span>MeshFaceVertexAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_index_face_1_1_vertex.html">IndexFace::Vertex</a> &amp; MeshFaceVertexAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the face vertex in the <code>mesh</code> referred by the given <code>face_vertex_index</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>face_vertex_index</code> refers to a valid vertex in the <code>mesh</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any of the preconditions is not met, this function will abort execution. </dd></dl>

</div>
</div>
<a id="a3a2ca0b552c66ea28ba0c9f83796048d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2ca0b552c66ea28ba0c9f83796048d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maliput::utility::mesh::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2265f079a1b89a718188e8a67765595f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2265f079a1b89a718188e8a67765595f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maliput::utility::mesh::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0705bc6329e73d0b7ee738ca2fd2d590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0705bc6329e73d0b7ee738ca2fd2d590">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maliput::utility::mesh::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_directed_edge_index.html">DirectedEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a8962fcc82c75e1f6a7406773e97752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8962fcc82c75e1f6a7406773e97752">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maliput::utility::mesh::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_edge_index.html">FaceEdgeIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a072cc288bb47405029aed3f5e95134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a072cc288bb47405029aed3f5e95134">&#9670;&nbsp;</a></span>SimplifyMeshFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> SimplifyMeshFaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies a mesh by merging adjacent coplanar faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_mesh</td><td>Mesh to be simplified. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for simplification, in meters. See <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a4597a0b90338ac00cd3da265c0cd852a" title="Merges all the faces in the given mesh referred by mergeable_faces_indices into a single GeoFace.">MergeMeshFaces()</a> and <a class="el" href="namespacemaliput_1_1utility_1_1mesh.html#a85f7866b6c3ed71ee6882c943b63c869" title="Aggregates all coplanar faces adjacent to the referred face in the mesh.">AggregateAdjacentCoplanarMeshFaces()</a> functions for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output, simplified mesh. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The union of the all the faces in the given <code>input_mesh</code> yields a simply connected region (i.e. with no holes). </dd></dl>

</div>
</div>
<a id="aaa02ac8a38e63f82760f2bb81113cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa02ac8a38e63f82760f2bb81113cdc5">&#9670;&nbsp;</a></span>SimplifyMeshFacesContour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &gt; SimplifyMeshFacesContour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1utility_1_1mesh_1_1_geo_mesh.html">GeoMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmaliput_1_1utility_1_1mesh_1_1_face_vertex_index.html">FaceVertexIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contour_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the <code>mesh</code> faces' contour referred by the given <code>contour_indices</code> by elimination of redundant vertices, i.e. </p>
<p>vertices that lie within one <code>tolerance</code> distance, in meters, from the line that the their following and preceding vertices subtend. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemaliput.html">maliput</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1utility.html">utility</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1utility_1_1mesh.html">mesh</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

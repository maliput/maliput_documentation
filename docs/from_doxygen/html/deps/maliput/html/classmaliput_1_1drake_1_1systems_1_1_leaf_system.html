<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput: LeafSystem&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmaliput_1_1drake_1_1systems_1_1_leaf_system.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LeafSystem&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class maliput::drake::systems::LeafSystem&lt; T &gt;</h3>

<p>A superclass template that extends <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> with some convenience utilities that are not applicable to Diagrams. </p>
<p>@tparam_default_scalar </p>
</div>
<p><code>#include &lt;include/maliput/drake/systems/framework/leaf_system.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LeafSystem&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmaliput_1_1drake_1_1systems_1_1_leaf_system__inherit__graph.svg" width="148" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5341fd0b682386ac7623a65a898b48a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5341fd0b682386ac7623a65a898b48a0">~LeafSystem</a> () override</td></tr>
<tr class="separator:a5341fd0b682386ac7623a65a898b48a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0339d1a60201dd7e42d5e8a80285152"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af0339d1a60201dd7e42d5e8a80285152">AllocateContext</a> () const</td></tr>
<tr class="memdesc:af0339d1a60201dd7e42d5e8a80285152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadows <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a78fda6d982dc968061c5d92e32173629" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;.">System&lt;T&gt;::AllocateContext</a> to provide a more concrete return type LeafContext&lt;T&gt;.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af0339d1a60201dd7e42d5e8a80285152">More...</a><br /></td></tr>
<tr class="separator:af0339d1a60201dd7e42d5e8a80285152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ed4a335c7077d3914f98f87f28c117"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a54ed4a335c7077d3914f98f87f28c117">AllocateForcedPublishEventCollection</a> () const override</td></tr>
<tr class="separator:a54ed4a335c7077d3914f98f87f28c117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cd71b380ce6914a46085c83dc31b77"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a09cd71b380ce6914a46085c83dc31b77">AllocateForcedDiscreteUpdateEventCollection</a> () const override</td></tr>
<tr class="separator:a09cd71b380ce6914a46085c83dc31b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314a748049fdd21c0ea7b99713eea4df"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a314a748049fdd21c0ea7b99713eea4df">AllocateForcedUnrestrictedUpdateEventCollection</a> () const override</td></tr>
<tr class="separator:a314a748049fdd21c0ea7b99713eea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f172b2dafc6d0530bef143c4574d6e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a07f172b2dafc6d0530bef143c4574d6e">DoAllocateContext</a> () const final</td></tr>
<tr class="separator:a07f172b2dafc6d0530bef143c4574d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920e22e905b83dbc0abaaa57d2c0251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">SetDefaultState</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const override</td></tr>
<tr class="memdesc:ac920e22e905b83dbc0abaaa57d2c0251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation: sets all continuous state to the model vector given in DeclareContinuousState (or zero if no model vector was given) and discrete states to zero.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">More...</a><br /></td></tr>
<tr class="separator:ac920e22e905b83dbc0abaaa57d2c0251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a5a76172d2c18e3ac495b44c866c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">SetDefaultParameters</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters) const override</td></tr>
<tr class="memdesc:a48a5a76172d2c18e3ac495b44c866c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation: sets all numeric parameters to the model vector given to DeclareNumericParameter, or else if no model was provided sets the numeric parameter to one.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">More...</a><br /></td></tr>
<tr class="separator:a48a5a76172d2c18e3ac495b44c866c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad305239ecbafb0545520bb5b2898312d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad305239ecbafb0545520bb5b2898312d">AllocateTimeDerivatives</a> () const final</td></tr>
<tr class="memdesc:ad305239ecbafb0545520bb5b2898312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> of the same size as the continuous_state allocated in CreateDefaultContext.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad305239ecbafb0545520bb5b2898312d">More...</a><br /></td></tr>
<tr class="separator:ad305239ecbafb0545520bb5b2898312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a46315bf6c86eefd7e4cf0f600c7ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a75a46315bf6c86eefd7e4cf0f600c7ae">AllocateDiscreteVariables</a> () const final</td></tr>
<tr class="memdesc:a75a46315bf6c86eefd7e4cf0f600c7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html" title="DiscreteValues is a container for numerical but non-continuous state and parameters.">DiscreteValues</a> of the same dimensions as the discrete_state allocated in CreateDefaultContext.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a75a46315bf6c86eefd7e4cf0f600c7ae">More...</a><br /></td></tr>
<tr class="separator:a75a46315bf6c86eefd7e4cf0f600c7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3594555c30be66710766bb18169da6b"><td class="memItemLeft" align="right" valign="top">std::multimap&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab3594555c30be66710766bb18169da6b">GetDirectFeedthroughs</a> () const final</td></tr>
<tr class="separator:ab3594555c30be66710766bb18169da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmaliput_1_1drake_1_1systems_1_1_system')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System&lt; T &gt;</a></td></tr>
<tr class="memitem:abfc527f890d8846b751645ab81a67bb1 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#abfc527f890d8846b751645ab81a67bb1">~System</a> () override</td></tr>
<tr class="separator:abfc527f890d8846b751645ab81a67bb1 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac204d99f901bdec9ffb0a12e7fe2973a inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac204d99f901bdec9ffb0a12e7fe2973a">Accept</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_visitor.html">SystemVisitor</a>&lt; T &gt; *v) const</td></tr>
<tr class="memdesc:ac204d99f901bdec9ffb0a12e7fe2973a inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a visitor pattern.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac204d99f901bdec9ffb0a12e7fe2973a">More...</a><br /></td></tr>
<tr class="separator:ac204d99f901bdec9ffb0a12e7fe2973a inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fda6d982dc968061c5d92e32173629 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a78fda6d982dc968061c5d92e32173629">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a78fda6d982dc968061c5d92e32173629 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a78fda6d982dc968061c5d92e32173629">More...</a><br /></td></tr>
<tr class="separator:a78fda6d982dc968061c5d92e32173629 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc7dd6cf032c4b3137de55349d8e99b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6cc7dd6cf032c4b3137de55349d8e99b">AllocateCompositeEventCollection</a> () const</td></tr>
<tr class="memdesc:a6cc7dd6cf032c4b3137de55349d8e99b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> for this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6cc7dd6cf032c4b3137de55349d8e99b">More...</a><br /></td></tr>
<tr class="separator:a6cc7dd6cf032c4b3137de55349d8e99b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ce7f3c3ed819de001d4ab977ee65bf inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab7ce7f3c3ed819de001d4ab977ee65bf">AllocateInputVector</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:ab7ce7f3c3ed819de001d4ab977ee65bf inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the vector storage.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab7ce7f3c3ed819de001d4ab977ee65bf">More...</a><br /></td></tr>
<tr class="separator:ab7ce7f3c3ed819de001d4ab977ee65bf inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69db7d7d92345c74487bc38c5d136a07 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a69db7d7d92345c74487bc38c5d136a07">AllocateInputAbstract</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:a69db7d7d92345c74487bc38c5d136a07 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the abstract storage.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a69db7d7d92345c74487bc38c5d136a07">More...</a><br /></td></tr>
<tr class="separator:a69db7d7d92345c74487bc38c5d136a07 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c35210719be2e1035e14ea9a11299 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af46c35210719be2e1035e14ea9a11299">AllocateOutput</a> () const</td></tr>
<tr class="memdesc:af46c35210719be2e1035e14ea9a11299 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container that can hold the values of all of this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s output ports.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af46c35210719be2e1035e14ea9a11299">More...</a><br /></td></tr>
<tr class="separator:af46c35210719be2e1035e14ea9a11299 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb947655d5d8156013bfdfd6ec90521 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#acdb947655d5d8156013bfdfd6ec90521">AllocateImplicitTimeDerivativesResidual</a> () const</td></tr>
<tr class="memdesc:acdb947655d5d8156013bfdfd6ec90521 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen VectorX suitable for use as the output argument to the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2bb4c1e3572a8009863b5a342fcb5c49" title="Evaluates the implicit form of the System equations and returns the residual.">CalcImplicitTimeDerivativesResidual()</a> method.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#acdb947655d5d8156013bfdfd6ec90521">More...</a><br /></td></tr>
<tr class="separator:acdb947655d5d8156013bfdfd6ec90521 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa036f873464a74c03fab943bbace8942 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa036f873464a74c03fab943bbace8942">CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:aa036f873464a74c03fab943bbace8942 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This convenience method allocates a context using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a78fda6d982dc968061c5d92e32173629" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;.">AllocateContext()</a> and sets its default values using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88" title="Sets Context fields to their default values.">SetDefaultContext()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa036f873464a74c03fab943bbace8942">More...</a><br /></td></tr>
<tr class="separator:aa036f873464a74c03fab943bbace8942 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e6ee413f4f47a20f6dcc2cbd831b88 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:ab4e6ee413f4f47a20f6dcc2cbd831b88 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> fields to their default values.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">More...</a><br /></td></tr>
<tr class="separator:ab4e6ee413f4f47a20f6dcc2cbd831b88 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3516fe581eeed54e8718b52410a310dd inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3516fe581eeed54e8718b52410a310dd">SetRandomState</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="classmaliput_1_1drake_1_1_random_generator.html">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a3516fe581eeed54e8718b52410a310dd inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all elements of the state.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3516fe581eeed54e8718b52410a310dd">More...</a><br /></td></tr>
<tr class="separator:a3516fe581eeed54e8718b52410a310dd inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c64234f6d3d49e4648a1b5b6e3eae inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a082c64234f6d3d49e4648a1b5b6e3eae">SetRandomParameters</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters, <a class="el" href="classmaliput_1_1drake_1_1_random_generator.html">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a082c64234f6d3d49e4648a1b5b6e3eae inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all parameters.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a082c64234f6d3d49e4648a1b5b6e3eae">More...</a><br /></td></tr>
<tr class="separator:a082c64234f6d3d49e4648a1b5b6e3eae inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a403983483dda39f8196a241225f2 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6a5a403983483dda39f8196a241225f2">SetRandomContext</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, <a class="el" href="classmaliput_1_1drake_1_1_random_generator.html">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a6a5a403983483dda39f8196a241225f2 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> fields to random values.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6a5a403983483dda39f8196a241225f2">More...</a><br /></td></tr>
<tr class="separator:a6a5a403983483dda39f8196a241225f2 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec86445724fd77391af7874bfc4848 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a47ec86445724fd77391af7874bfc4848">AllocateFixedInputs</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a47ec86445724fd77391af7874bfc4848 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each input port, allocates a fixed input of the concrete type that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> requires, and binds it to the port, disconnecting any prior input.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a47ec86445724fd77391af7874bfc4848">More...</a><br /></td></tr>
<tr class="separator:a47ec86445724fd77391af7874bfc4848 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037dd9c0afe6e059e67edb4c9c01eeb3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a037dd9c0afe6e059e67edb4c9c01eeb3">HasAnyDirectFeedthrough</a> () const</td></tr>
<tr class="memdesc:a037dd9c0afe6e059e67edb4c9c01eeb3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the inputs to the system might be directly fed through to any of its outputs and <code>false</code> otherwise.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a037dd9c0afe6e059e67edb4c9c01eeb3">More...</a><br /></td></tr>
<tr class="separator:a037dd9c0afe6e059e67edb4c9c01eeb3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acfa17df1bc87ce8eaa0e1556f6d46 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a51acfa17df1bc87ce8eaa0e1556f6d46">HasDirectFeedthrough</a> (int output_port) const</td></tr>
<tr class="memdesc:a51acfa17df1bc87ce8eaa0e1556f6d46 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from any input port to the given <code>output_port</code>, and false otherwise.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a51acfa17df1bc87ce8eaa0e1556f6d46">More...</a><br /></td></tr>
<tr class="separator:a51acfa17df1bc87ce8eaa0e1556f6d46 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd5092dc2aa2c8f38e0d6336437012d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a8dd5092dc2aa2c8f38e0d6336437012d">HasDirectFeedthrough</a> (int input_port, int output_port) const</td></tr>
<tr class="memdesc:a8dd5092dc2aa2c8f38e0d6336437012d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from the given <code>input_port</code> to the given <code>output_port</code>, and false otherwise.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a8dd5092dc2aa2c8f38e0d6336437012d">More...</a><br /></td></tr>
<tr class="separator:a8dd5092dc2aa2c8f38e0d6336437012d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f0ac4b8f2b65f013e88c56ccccd9e6 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad7f0ac4b8f2b65f013e88c56ccccd9e6">GetDirectFeedthroughs</a> () const=0</td></tr>
<tr class="memdesc:ad7f0ac4b8f2b65f013e88c56ccccd9e6 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all direct feedthroughs from input ports to output ports.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad7f0ac4b8f2b65f013e88c56ccccd9e6">More...</a><br /></td></tr>
<tr class="separator:ad7f0ac4b8f2b65f013e88c56ccccd9e6 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31898e0276f6bbc4edf7111f809afb01 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01">Publish</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt; &amp;events) const</td></tr>
<tr class="memdesc:a31898e0276f6bbc4edf7111f809afb01 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all publish event handlers.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01">More...</a><br /></td></tr>
<tr class="separator:a31898e0276f6bbc4edf7111f809afb01 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa5fa6fa51aaa8f987abb101e341739 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aafa5fa6fa51aaa8f987abb101e341739">Publish</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aafa5fa6fa51aaa8f987abb101e341739 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a publish on the system, given a <code>context</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aafa5fa6fa51aaa8f987abb101e341739">More...</a><br /></td></tr>
<tr class="separator:aafa5fa6fa51aaa8f987abb101e341739 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38625e953699a0433249142972eef52 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52">EvalTimeDerivatives</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ae38625e953699a0433249142972eef52 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.">CalcTimeDerivatives()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52">More...</a><br /></td></tr>
<tr class="separator:ae38625e953699a0433249142972eef52 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e42d4ecb1d2902ed839a8a9d2afaa inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a028e42d4ecb1d2902ed839a8a9d2afaa">get_time_derivatives_cache_entry</a> () const</td></tr>
<tr class="memdesc:a028e42d4ecb1d2902ed839a8a9d2afaa inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> used to cache time derivatives for <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52" title="Returns a reference to the cached value of the continuous state variable time derivatives,...">EvalTimeDerivatives()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a028e42d4ecb1d2902ed839a8a9d2afaa">More...</a><br /></td></tr>
<tr class="separator:a028e42d4ecb1d2902ed839a8a9d2afaa inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c1ac3506af8f2c386ba74b5fbc1e48 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a97c1ac3506af8f2c386ba74b5fbc1e48">EvalPotentialEnergy</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a97c1ac3506af8f2c386ba74b5fbc1e48 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a97c1ac3506af8f2c386ba74b5fbc1e48">More...</a><br /></td></tr>
<tr class="separator:a97c1ac3506af8f2c386ba74b5fbc1e48 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc345ff50df77ad2ae727e6d3a9b939 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#abfc345ff50df77ad2ae727e6d3a9b939">EvalKineticEnergy</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:abfc345ff50df77ad2ae727e6d3a9b939 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#abfc345ff50df77ad2ae727e6d3a9b939">More...</a><br /></td></tr>
<tr class="separator:abfc345ff50df77ad2ae727e6d3a9b939 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf4d9472a96aad5d65e47375cf035f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a94bf4d9472a96aad5d65e47375cf035f">EvalConservativePower</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a94bf4d9472a96aad5d65e47375cf035f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a94bf4d9472a96aad5d65e47375cf035f">More...</a><br /></td></tr>
<tr class="separator:a94bf4d9472a96aad5d65e47375cf035f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ed6bf23e134cbc50d073e81ffc247f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a08ed6bf23e134cbc50d073e81ffc247f">EvalNonConservativePower</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a08ed6bf23e134cbc50d073e81ffc247f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if necessary using <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a08ed6bf23e134cbc50d073e81ffc247f">More...</a><br /></td></tr>
<tr class="separator:a08ed6bf23e134cbc50d073e81ffc247f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class Vec = BasicVector&gt; </td></tr>
<tr class="memitem:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">const Vec&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa184508e6a0494c1b8214dab77e34ce3">EvalVectorInput</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, int port_index) const</td></tr>
<tr class="memdesc:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <code>port_index</code> as a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> or a specific subclass <code>Vec</code> derived from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa184508e6a0494c1b8214dab77e34ce3">More...</a><br /></td></tr>
<tr class="separator:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd99b363ba22035de7689f48702e89b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a4cd99b363ba22035de7689f48702e89b">EvalEigenVectorInput</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, int port_index) const</td></tr>
<tr class="memdesc:a4cd99b363ba22035de7689f48702e89b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <code>port_index</code> as an Eigen vector.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a4cd99b363ba22035de7689f48702e89b">More...</a><br /></td></tr>
<tr class="separator:a4cd99b363ba22035de7689f48702e89b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97e05bf6c16c4bbf058d3cd4978f696 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad97e05bf6c16c4bbf058d3cd4978f696">AddExternalConstraint</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_external_system_constraint.html">ExternalSystemConstraint</a> constraint)</td></tr>
<tr class="memdesc:ad97e05bf6c16c4bbf058d3cd4978f696 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an "external" constraint to this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad97e05bf6c16c4bbf058d3cd4978f696">More...</a><br /></td></tr>
<tr class="separator:ad97e05bf6c16c4bbf058d3cd4978f696 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2677f8773e90a538483eedd80a81a9f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f">CalcTimeDerivatives</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:af2677f8773e90a538483eedd80a81a9f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f">More...</a><br /></td></tr>
<tr class="separator:af2677f8773e90a538483eedd80a81a9f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb4c1e3572a8009863b5a342fcb5c49 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2bb4c1e3572a8009863b5a342fcb5c49">CalcImplicitTimeDerivativesResidual</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;proposed_derivatives, <a class="el" href="classmaliput_1_1drake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; residual) const</td></tr>
<tr class="memdesc:a2bb4c1e3572a8009863b5a342fcb5c49 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the implicit form of the System equations and returns the residual.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2bb4c1e3572a8009863b5a342fcb5c49">More...</a><br /></td></tr>
<tr class="separator:a2bb4c1e3572a8009863b5a342fcb5c49 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b5edfcccb98a87f958bc9b6b626bd inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd">CalcDiscreteVariableUpdates</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:a2b4b5edfcccb98a87f958bc9b6b626bd inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all discrete variable update event handlers.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd">More...</a><br /></td></tr>
<tr class="separator:a2b4b5edfcccb98a87f958bc9b6b626bd inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3873890578a88001255c795f20f01e3f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3873890578a88001255c795f20f01e3f">ApplyDiscreteVariableUpdate</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a3873890578a88001255c795f20f01e3f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code>discrete_state</code> results of a previous call to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdates()</a> that dispatched the given collection of events, modifies the <code>context</code> to reflect the updated <code>discrete_state</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3873890578a88001255c795f20f01e3f">More...</a><br /></td></tr>
<tr class="separator:a3873890578a88001255c795f20f01e3f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054ef0e9e578c5abc57fd4dc8b12bd84 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a054ef0e9e578c5abc57fd4dc8b12bd84">CalcDiscreteVariableUpdates</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:a054ef0e9e578c5abc57fd4dc8b12bd84 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces a discrete update on the system given a <code>context</code>, and the updated discrete state is stored in <code>discrete_state</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a054ef0e9e578c5abc57fd4dc8b12bd84">More...</a><br /></td></tr>
<tr class="separator:a054ef0e9e578c5abc57fd4dc8b12bd84 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad195518c9c6d2c9421e6e2b222514d89 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89">CalcUnrestrictedUpdate</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:ad195518c9c6d2c9421e6e2b222514d89 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all unrestricted update event handlers.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89">More...</a><br /></td></tr>
<tr class="separator:ad195518c9c6d2c9421e6e2b222514d89 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3701622107a616b3e45f9f0735233 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1bc3701622107a616b3e45f9f0735233">ApplyUnrestrictedUpdate</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a1bc3701622107a616b3e45f9f0735233 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code>state</code> results of a previous call to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a> that dispatched the given collection of events, modifies the <code>context</code> to reflect the updated <code>state</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1bc3701622107a616b3e45f9f0735233">More...</a><br /></td></tr>
<tr class="separator:a1bc3701622107a616b3e45f9f0735233 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f04e429745ae7a16600c4dfda0f931 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a25f04e429745ae7a16600c4dfda0f931">CalcUnrestrictedUpdate</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a25f04e429745ae7a16600c4dfda0f931 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces an unrestricted update on the system given a <code>context</code>, and the updated state is stored in <code>state</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a25f04e429745ae7a16600c4dfda0f931">More...</a><br /></td></tr>
<tr class="separator:a25f04e429745ae7a16600c4dfda0f931 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164afe3c1db737b93696b8808bb2c942 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942">CalcNextUpdateTime</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:a164afe3c1db737b93696b8808bb2c942 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by a Simulator during its calculation of the size of the next continuous step to attempt.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942">More...</a><br /></td></tr>
<tr class="separator:a164afe3c1db737b93696b8808bb2c942 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a24b8f910f9d990db8e59bf2bae6d0 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0">GetPerStepEvents</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ad8a24b8f910f9d990db8e59bf2bae6d0 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by Simulator::Initialize() to gather all update and publish events that are to be handled in AdvanceTo() at the point before Simulator integrates continuous state.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0">More...</a><br /></td></tr>
<tr class="separator:ad8a24b8f910f9d990db8e59bf2bae6d0 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f84e649d76754f38ea7420a21a1a04 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04">GetInitializationEvents</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ae6f84e649d76754f38ea7420a21a1a04 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by Simulator::Initialize() to gather all update and publish events that need to be handled at initialization before the simulator starts integration.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04">More...</a><br /></td></tr>
<tr class="separator:ae6f84e649d76754f38ea7420a21a1a04 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7bc22bdd95c7c611e859c12dfef3e1 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0e7bc22bdd95c7c611e859c12dfef3e1">GetUniquePeriodicDiscreteUpdateAttribute</a> () const</td></tr>
<tr class="memdesc:a0e7bc22bdd95c7c611e859c12dfef3e1 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether there exists a unique periodic attribute that triggers one or more discrete update events (and, if so, returns that unique periodic attribute).  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0e7bc22bdd95c7c611e859c12dfef3e1">More...</a><br /></td></tr>
<tr class="separator:a0e7bc22bdd95c7c611e859c12dfef3e1 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5016cfee3ccd384e0a0ba62b4da5bc inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aeb5016cfee3ccd384e0a0ba62b4da5bc">IsDifferenceEquationSystem</a> (<a class="el" href="classdouble.html">double</a> *time_period=nullptr) const</td></tr>
<tr class="memdesc:aeb5016cfee3ccd384e0a0ba62b4da5bc inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the state dynamics of this system are governed exclusively by a difference equation on a single discrete state group and with a unique periodic update (having zero offset).  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aeb5016cfee3ccd384e0a0ba62b4da5bc">More...</a><br /></td></tr>
<tr class="separator:aeb5016cfee3ccd384e0a0ba62b4da5bc inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ec8dd139ab0f99c1fe908e4098a974 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a68ec8dd139ab0f99c1fe908e4098a974">GetPeriodicEvents</a> () const</td></tr>
<tr class="memdesc:a68ec8dd139ab0f99c1fe908e4098a974 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all periodic triggered events for a system.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a68ec8dd139ab0f99c1fe908e4098a974">More...</a><br /></td></tr>
<tr class="separator:a68ec8dd139ab0f99c1fe908e4098a974 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574467e50cf5c242f665557daca33111 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a574467e50cf5c242f665557daca33111">CalcOutput</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *outputs) const</td></tr>
<tr class="memdesc:a574467e50cf5c242f665557daca33111 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method that computes for <em>every</em> output port i the value y(i) that should result from the current contents of the given <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a574467e50cf5c242f665557daca33111">More...</a><br /></td></tr>
<tr class="separator:a574467e50cf5c242f665557daca33111 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5eb1d2630aab1938230257554d1f43 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43">CalcPotentialEnergy</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3d5eb1d2630aab1938230257554d1f43 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the potential energy represented by the current configuration provided in <code>context</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43">More...</a><br /></td></tr>
<tr class="separator:a3d5eb1d2630aab1938230257554d1f43 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad01402fef0de79310989d7d22dfde92 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92">CalcKineticEnergy</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aad01402fef0de79310989d7d22dfde92 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the kinetic energy represented by the current configuration and velocity provided in <code>context</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92">More...</a><br /></td></tr>
<tr class="separator:aad01402fef0de79310989d7d22dfde92 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674ae416c2808c939dffc117b209f23 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23">CalcConservativePower</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a5674ae416c2808c939dffc117b209f23 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the conservative power represented by the current contents of the given <code>context</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23">More...</a><br /></td></tr>
<tr class="separator:a5674ae416c2808c939dffc117b209f23 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fe133b70153e382d7f50c38b96bf1f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f">CalcNonConservativePower</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a23fe133b70153e382d7f50c38b96bf1f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the non-conservative power represented by the current contents of the given <code>context</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f">More...</a><br /></td></tr>
<tr class="separator:a23fe133b70153e382d7f50c38b96bf1f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc5df6d0d0fe4ea54b522ae776ca39 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39">MapVelocityToQDot</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;generalized_velocity, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a05cc5df6d0d0fe4ea54b522ae776ca39 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a given generalized velocity <code>v</code> to the time derivative <code>qdot</code> of the generalized configuration <code>q</code> taken from the supplied <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39">More...</a><br /></td></tr>
<tr class="separator:a05cc5df6d0d0fe4ea54b522ae776ca39 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d05cfdce7f2dbae7c9f18babfc827e8 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3d05cfdce7f2dbae7c9f18babfc827e8">MapVelocityToQDot</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;generalized_velocity, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a3d05cfdce7f2dbae7c9f18babfc827e8 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given generalized velocity to the time derivative of generalized configuration.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3d05cfdce7f2dbae7c9f18babfc827e8">More...</a><br /></td></tr>
<tr class="separator:a3d05cfdce7f2dbae7c9f18babfc827e8 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eba167739bfe8e7e419b5c8ae41537 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537">MapQDotToVelocity</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;qdot, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a10eba167739bfe8e7e419b5c8ae41537 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <code>qdot</code> of the generalized configuration <code>q</code> to generalized velocities <code>v</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537">More...</a><br /></td></tr>
<tr class="separator:a10eba167739bfe8e7e419b5c8ae41537 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914457357091af1a9932863f2b396a4 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9914457357091af1a9932863f2b396a4">MapQDotToVelocity</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a9914457357091af1a9932863f2b396a4 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given time derivative <code>qdot</code> of generalized configuration <code>q</code> to generalized velocity <code>v</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9914457357091af1a9932863f2b396a4">More...</a><br /></td></tr>
<tr class="separator:a9914457357091af1a9932863f2b396a4 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa7a04bd169a920b4ae90d4e1db4fe5 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aaaa7a04bd169a920b4ae90d4e1db4fe5">GetSubsystemContext</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;subsystem, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aaaa7a04bd169a920b4ae90d4e1db4fe5 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the subcontext that corresponds to the contained System <code>subsystem</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aaaa7a04bd169a920b4ae90d4e1db4fe5">More...</a><br /></td></tr>
<tr class="separator:aaaa7a04bd169a920b4ae90d4e1db4fe5 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ce57e23ae030c0ef224b0d0b7cc70c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a95ce57e23ae030c0ef224b0d0b7cc70c">GetMutableSubsystemContext</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;subsystem, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a95ce57e23ae030c0ef224b0d0b7cc70c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the subcontext that corresponds to the contained System <code>subsystem</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a95ce57e23ae030c0ef224b0d0b7cc70c">More...</a><br /></td></tr>
<tr class="separator:a95ce57e23ae030c0ef224b0d0b7cc70c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf801fb0529fd09f9a2c3e9ae941147 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#accf801fb0529fd09f9a2c3e9ae941147">GetMyContextFromRoot</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;root_context) const</td></tr>
<tr class="memdesc:accf801fb0529fd09f9a2c3e9ae941147 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> for <code>this</code> subsystem, given a root context.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#accf801fb0529fd09f9a2c3e9ae941147">More...</a><br /></td></tr>
<tr class="separator:accf801fb0529fd09f9a2c3e9ae941147 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f679178e8c8864dfb7d65a3198ee3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#abb6f679178e8c8864dfb7d65a3198ee3">GetMyMutableContextFromRoot</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *root_context) const</td></tr>
<tr class="memdesc:abb6f679178e8c8864dfb7d65a3198ee3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutable subsystem context for <code>this</code> system, given a root context.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#abb6f679178e8c8864dfb7d65a3198ee3">More...</a><br /></td></tr>
<tr class="separator:abb6f679178e8c8864dfb7d65a3198ee3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9714aaf76aca9169da6de7fbcb8339fb">GetMemoryObjectName</a> () const</td></tr>
<tr class="memdesc:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a name for this System based on a stringification of its type name and memory address.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9714aaf76aca9169da6de7fbcb8339fb">More...</a><br /></td></tr>
<tr class="separator:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b7b9f7723ad69fca8766e6590ef681 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a39b7b9f7723ad69fca8766e6590ef681">get_input_port</a> (int port_index) const</td></tr>
<tr class="memdesc:a39b7b9f7723ad69fca8766e6590ef681 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port at index <code>port_index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a39b7b9f7723ad69fca8766e6590ef681">More...</a><br /></td></tr>
<tr class="separator:a39b7b9f7723ad69fca8766e6590ef681 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc22af164f8b6ee671b0d598fd2466 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#abcfc22af164f8b6ee671b0d598fd2466">get_input_port</a> () const</td></tr>
<tr class="memdesc:abcfc22af164f8b6ee671b0d598fd2466 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for the case of exactly one input port.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#abcfc22af164f8b6ee671b0d598fd2466">More...</a><br /></td></tr>
<tr class="separator:abcfc22af164f8b6ee671b0d598fd2466 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada70a32e95cd84cd4fe02c1d25be437d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ada70a32e95cd84cd4fe02c1d25be437d">get_input_port_selection</a> (std::variant&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a5484375bdbfb17f525cd2ed396d747f9">InputPortSelection</a>, <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> &gt; port_index) const</td></tr>
<tr class="memdesc:ada70a32e95cd84cd4fe02c1d25be437d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port specified by the InputPortSelection or by the InputPortIndex.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ada70a32e95cd84cd4fe02c1d25be437d">More...</a><br /></td></tr>
<tr class="separator:ada70a32e95cd84cd4fe02c1d25be437d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b235f5342408f469d02b5b5d2dfb555 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b235f5342408f469d02b5b5d2dfb555">GetInputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a0b235f5342408f469d02b5b5d2dfb555 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port with the unique name <code>port_name</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b235f5342408f469d02b5b5d2dfb555">More...</a><br /></td></tr>
<tr class="separator:a0b235f5342408f469d02b5b5d2dfb555 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de14ac72441c44be8dec6cc6719dd1e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2de14ac72441c44be8dec6cc6719dd1e">HasInputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a2de14ac72441c44be8dec6cc6719dd1e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the system has an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html" title="An InputPort is a System resource that describes the kind of input a System accepts,...">InputPort</a> of the given <code>port_name</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2de14ac72441c44be8dec6cc6719dd1e">More...</a><br /></td></tr>
<tr class="separator:a2de14ac72441c44be8dec6cc6719dd1e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32474ac975155d1289d564016a8a13 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9d32474ac975155d1289d564016a8a13">get_output_port</a> (int port_index) const</td></tr>
<tr class="memdesc:a9d32474ac975155d1289d564016a8a13 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port at index <code>port_index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9d32474ac975155d1289d564016a8a13">More...</a><br /></td></tr>
<tr class="separator:a9d32474ac975155d1289d564016a8a13 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2c5bab385f7c5e1069d61c45600c3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a08e2c5bab385f7c5e1069d61c45600c3">get_output_port</a> () const</td></tr>
<tr class="memdesc:a08e2c5bab385f7c5e1069d61c45600c3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for the case of exactly one output port.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a08e2c5bab385f7c5e1069d61c45600c3">More...</a><br /></td></tr>
<tr class="separator:a08e2c5bab385f7c5e1069d61c45600c3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e02715eef0ca58a3ee6dda24a3395 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a991e02715eef0ca58a3ee6dda24a3395">get_output_port_selection</a> (std::variant&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a00432489001229d1f63cb6d373403a6e">OutputPortSelection</a>, <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> &gt; port_index) const</td></tr>
<tr class="memdesc:a991e02715eef0ca58a3ee6dda24a3395 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port specified by the OutputPortSelection or by the OutputPortIndex.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a991e02715eef0ca58a3ee6dda24a3395">More...</a><br /></td></tr>
<tr class="separator:a991e02715eef0ca58a3ee6dda24a3395 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af900e8c1b8e91219a8771c54f1d130ab inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af900e8c1b8e91219a8771c54f1d130ab">GetOutputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:af900e8c1b8e91219a8771c54f1d130ab inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port with the unique name <code>port_name</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af900e8c1b8e91219a8771c54f1d130ab">More...</a><br /></td></tr>
<tr class="separator:af900e8c1b8e91219a8771c54f1d130ab inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70946c955bb9100cc8e9dc1f5df5c8bc inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a70946c955bb9100cc8e9dc1f5df5c8bc">HasOutputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a70946c955bb9100cc8e9dc1f5df5c8bc inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the system has an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports.">OutputPort</a> of the given <code>port_name</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a70946c955bb9100cc8e9dc1f5df5c8bc">More...</a><br /></td></tr>
<tr class="separator:a70946c955bb9100cc8e9dc1f5df5c8bc inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f1475b0c301d9d78814fce265fd6ea inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a23f1475b0c301d9d78814fce265fd6ea">num_constraints</a> () const</td></tr>
<tr class="memdesc:a23f1475b0c301d9d78814fce265fd6ea inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints specified for the system.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a23f1475b0c301d9d78814fce265fd6ea">More...</a><br /></td></tr>
<tr class="separator:a23f1475b0c301d9d78814fce265fd6ea inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72d50dd5540d7a303b1bb8135df5a80 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac72d50dd5540d7a303b1bb8135df5a80">get_constraint</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> constraint_index) const</td></tr>
<tr class="memdesc:ac72d50dd5540d7a303b1bb8135df5a80 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint at index <code>constraint_index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac72d50dd5540d7a303b1bb8135df5a80">More...</a><br /></td></tr>
<tr class="separator:ac72d50dd5540d7a303b1bb8135df5a80 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fef66587073b52e0e69c84a736bd72 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a75fef66587073b52e0e69c84a736bd72">CheckSystemConstraintsSatisfied</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdouble.html">double</a> tol) const</td></tr>
<tr class="memdesc:a75fef66587073b52e0e69c84a736bd72 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>context</code> satisfies all of the registered SystemConstraints with tolerance <code>tol</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a75fef66587073b52e0e69c84a736bd72">More...</a><br /></td></tr>
<tr class="separator:a75fef66587073b52e0e69c84a736bd72 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b662b8346e6250f8c4340c18658084 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a46b662b8346e6250f8c4340c18658084">CopyContinuousStateVector</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a46b662b8346e6250f8c4340c18658084 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the continuous state vector x꜀ into an Eigen vector.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a46b662b8346e6250f8c4340c18658084">More...</a><br /></td></tr>
<tr class="separator:a46b662b8346e6250f8c4340c18658084 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a6d73c74c7268734792b3703e8600d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a94a6d73c74c7268734792b3703e8600d">num_input_ports</a> () const</td></tr>
<tr class="memdesc:a94a6d73c74c7268734792b3703e8600d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of input ports currently allocated in this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a94a6d73c74c7268734792b3703e8600d">More...</a><br /></td></tr>
<tr class="separator:a94a6d73c74c7268734792b3703e8600d inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceec1b22b6b1b25fc675234e78e71be inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a7ceec1b22b6b1b25fc675234e78e71be">num_output_ports</a> () const</td></tr>
<tr class="memdesc:a7ceec1b22b6b1b25fc675234e78e71be inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of output ports currently allocated in this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a7ceec1b22b6b1b25fc675234e78e71be">More...</a><br /></td></tr>
<tr class="separator:a7ceec1b22b6b1b25fc675234e78e71be inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e4f7454694f04b4b654d154f170f3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a588e4f7454694f04b4b654d154f170f3">GetGraphvizString</a> (int max_depth=std::numeric_limits&lt; int &gt;::max()) const</td></tr>
<tr class="memdesc:a588e4f7454694f04b4b654d154f170f3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a588e4f7454694f04b4b654d154f170f3">More...</a><br /></td></tr>
<tr class="separator:a588e4f7454694f04b4b654d154f170f3 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fac664a1c120c425bc522d7ecb435c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa1fac664a1c120c425bc522d7ecb435c">GetGraphvizId</a> () const</td></tr>
<tr class="memdesc:aa1fac664a1c120c425bc522d7ecb435c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque integer that uniquely identifies this system in the Graphviz output.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa1fac664a1c120c425bc522d7ecb435c">More...</a><br /></td></tr>
<tr class="separator:aa1fac664a1c120c425bc522d7ecb435c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601fb2c6cf565d954253d25725ae9d6b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a601fb2c6cf565d954253d25725ae9d6b">FixInputPortsFrom</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;other_system, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;other_context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *target_context) const</td></tr>
<tr class="memdesc:a601fb2c6cf565d954253d25725ae9d6b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes all of the input ports in <code>target_context</code> to their current values in <code>other_context</code>, as evaluated by <code>other_system</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a601fb2c6cf565d954253d25725ae9d6b">More...</a><br /></td></tr>
<tr class="separator:a601fb2c6cf565d954253d25725ae9d6b inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f520e00ddac3d41f7e2df922de46da4 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a4f520e00ddac3d41f7e2df922de46da4">get_system_scalar_converter</a> () const</td></tr>
<tr class="memdesc:a4f520e00ddac3d41f7e2df922de46da4 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> for this object.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a4f520e00ddac3d41f7e2df922de46da4">More...</a><br /></td></tr>
<tr class="separator:a4f520e00ddac3d41f7e2df922de46da4 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b43a0d81534db447de5166505716df inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a30b43a0d81534db447de5166505716df inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System</a>&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a30b43a0d81534db447de5166505716df">ToScalarType</a> () const</td></tr>
<tr class="memdesc:a30b43a0d81534db447de5166505716df inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the scalar type selected by a template parameter.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a30b43a0d81534db447de5166505716df">More...</a><br /></td></tr>
<tr class="separator:a30b43a0d81534db447de5166505716df inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e275d69ab53de1f9fe3b91c43236d30 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7e275d69ab53de1f9fe3b91c43236d30 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System</a>&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a7e275d69ab53de1f9fe3b91c43236d30">ToScalarTypeMaybe</a> () const</td></tr>
<tr class="memdesc:a7e275d69ab53de1f9fe3b91c43236d30 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a30b43a0d81534db447de5166505716df" title="Creates a deep copy of this System, transmogrified to use the scalar type selected by a template para...">ToScalarType()</a>, but returns nullptr if this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support the destination type, instead of throwing an exception.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a7e275d69ab53de1f9fe3b91c43236d30">More...</a><br /></td></tr>
<tr class="separator:a7e275d69ab53de1f9fe3b91c43236d30 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f777bd94a7d9188a905ac6ecfff577 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab9f777bd94a7d9188a905ac6ecfff577">GetWitnessFunctions</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; * &gt; *w) const</td></tr>
<tr class="memdesc:ab9f777bd94a7d9188a905ac6ecfff577 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the witness functions active for the given state.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab9f777bd94a7d9188a905ac6ecfff577">More...</a><br /></td></tr>
<tr class="separator:ab9f777bd94a7d9188a905ac6ecfff577 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2949deb61db7903dae4c0b7cb9633fac inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2949deb61db7903dae4c0b7cb9633fac">CalcWitnessValue</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const</td></tr>
<tr class="memdesc:a2949deb61db7903dae4c0b7cb9633fac inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a witness function at the given context.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2949deb61db7903dae4c0b7cb9633fac">More...</a><br /></td></tr>
<tr class="separator:a2949deb61db7903dae4c0b7cb9633fac inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58ff2c0e75003f66e5c196c61538f1f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af58ff2c0e75003f66e5c196c61538f1f">DeclareCacheEntry</a> (std::string description, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_value_producer.html">ValueProducer</a> value_producer, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="memdesc:af58ff2c0e75003f66e5c196c61538f1f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a new CacheEntry in this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> using the most generic form of the calculation function.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af58ff2c0e75003f66e5c196c61538f1f">More...</a><br /></td></tr>
<tr class="separator:af58ff2c0e75003f66e5c196c61538f1f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8522153f26cb7620bd669b288b91c26 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af8522153f26cb7620bd669b288b91c26">DeclareCacheEntry</a> (std::string description, std::function&lt; std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &gt;()&gt; alloc_function, std::function&lt; void(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;, <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> *)&gt; calc_function, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="separator:af8522153f26cb7620bd669b288b91c26 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376502958f63c619086e6cd89f091fdb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a376502958f63c619086e6cd89f091fdb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a376502958f63c619086e6cd89f091fdb">DeclareCacheEntry</a> (std::string description, const ValueType &amp;model_value, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="memdesc:a376502958f63c619086e6cd89f091fdb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying a model value of concrete type <code>ValueType</code> and a calculator function that is a class member function (method) with signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a376502958f63c619086e6cd89f091fdb">More...</a><br /></td></tr>
<tr class="separator:a376502958f63c619086e6cd89f091fdb inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d2a9a7af14845f76fbfa627020887e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:ad5d2a9a7af14845f76fbfa627020887e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad5d2a9a7af14845f76fbfa627020887e">DeclareCacheEntry</a> (std::string description, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="memdesc:ad5d2a9a7af14845f76fbfa627020887e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying only a calculator function that is a class member function (method) with signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad5d2a9a7af14845f76fbfa627020887e">More...</a><br /></td></tr>
<tr class="separator:ad5d2a9a7af14845f76fbfa627020887e inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6169e37fb10a5b25a6fe347ff161e9 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a9d6169e37fb10a5b25a6fe347ff161e9 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9d6169e37fb10a5b25a6fe347ff161e9">DeclareCacheEntry</a> (std::string description, ValueType(MySystem::*make)() const, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc)</td></tr>
<tr class="separator:a9d6169e37fb10a5b25a6fe347ff161e9 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae547d10ddbc3b5c837e0ae70520f5c4c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:ae547d10ddbc3b5c837e0ae70520f5c4c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ae547d10ddbc3b5c837e0ae70520f5c4c">DeclareCacheEntry</a> (std::string description, const ValueType &amp;model_value, ValueType(MySystem::*calc)(const MyContext &amp;) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc)</td></tr>
<tr class="separator:ae547d10ddbc3b5c837e0ae70520f5c4c inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eb6c61e9ced41f9b46296327f5db47 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a42eb6c61e9ced41f9b46296327f5db47 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a42eb6c61e9ced41f9b46296327f5db47">DeclareCacheEntry</a> (std::string description, ValueType(MySystem::*calc)(const MyContext &amp;) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc)</td></tr>
<tr class="separator:a42eb6c61e9ced41f9b46296327f5db47 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1a4ef0e0e633c6f722ee518308d7cb5a">abstract_parameter_ticket</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract parameter paᵢ.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1a4ef0e0e633c6f722ee518308d7cb5a">More...</a><br /></td></tr>
<tr class="separator:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a4a8d4f32034a610ea30a283699040708">abstract_state_ticket</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index) const</td></tr>
<tr class="memdesc:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract state variable xaᵢ.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a4a8d4f32034a610ea30a283699040708">More...</a><br /></td></tr>
<tr class="separator:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e92c6f01c04b3591d642d27a467b093 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a7e92c6f01c04b3591d642d27a467b093">cache_entry_ticket</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index) const</td></tr>
<tr class="memdesc:a7e92c6f01c04b3591d642d27a467b093 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the cache entry indicated by <code>index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a7e92c6f01c04b3591d642d27a467b093">More...</a><br /></td></tr>
<tr class="separator:a7e92c6f01c04b3591d642d27a467b093 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#adf86073429b07d388b0157956bfdbac6">discrete_state_ticket</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index) const</td></tr>
<tr class="memdesc:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector).  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#adf86073429b07d388b0157956bfdbac6">More...</a><br /></td></tr>
<tr class="separator:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191b7cb5dcbfee51a62fa042ec14561f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a191b7cb5dcbfee51a62fa042ec14561f">input_port_ticket</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> index) const</td></tr>
<tr class="memdesc:a191b7cb5dcbfee51a62fa042ec14561f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on input port uᵢ indicated by <code>index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a191b7cb5dcbfee51a62fa042ec14561f">More...</a><br /></td></tr>
<tr class="separator:a191b7cb5dcbfee51a62fa042ec14561f inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a45e0bf1fd3096bff3df2587ec4f02285">numeric_parameter_ticket</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector).  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a45e0bf1fd3096bff3df2587ec4f02285">More...</a><br /></td></tr>
<tr class="separator:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a01c2b703c560ad090b9601b743356c90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a01c2b703c560ad090b9601b743356c90">LeafSystem</a> ()</td></tr>
<tr class="memdesc:a01c2b703c560ad090b9601b743356c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that declares no inputs, outputs, state, parameters, events, nor scalar-type conversion support (AutoDiff, etc.).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a01c2b703c560ad090b9601b743356c90">More...</a><br /></td></tr>
<tr class="separator:a01c2b703c560ad090b9601b743356c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7077d1af5bd9153ae403fe32969eba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8d7077d1af5bd9153ae403fe32969eba">LeafSystem</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> converter)</td></tr>
<tr class="memdesc:a8d7077d1af5bd9153ae403fe32969eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that declares no inputs, outputs, state, parameters, or events, but allows subclasses to declare scalar-type conversion support (AutoDiff, etc.).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8d7077d1af5bd9153ae403fe32969eba">More...</a><br /></td></tr>
<tr class="separator:a8d7077d1af5bd9153ae403fe32969eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15031238be1c5b2985578d1e63bab2d7"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a15031238be1c5b2985578d1e63bab2d7">DoMakeLeafContext</a> () const</td></tr>
<tr class="memdesc:a15031238be1c5b2985578d1e63bab2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a new instance of the leaf context for this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a15031238be1c5b2985578d1e63bab2d7">More...</a><br /></td></tr>
<tr class="separator:a15031238be1c5b2985578d1e63bab2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd6ca8a128bb2663ebaa27d6851c68d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8bd6ca8a128bb2663ebaa27d6851c68d">DoValidateAllocatedLeafContext</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8bd6ca8a128bb2663ebaa27d6851c68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes that impose restrictions on what resources are permitted should check those restrictions by implementing this.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8bd6ca8a128bb2663ebaa27d6851c68d">More...</a><br /></td></tr>
<tr class="separator:a8bd6ca8a128bb2663ebaa27d6851c68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f1eff5e4fd7f55d152a1b3b9d4bcd1"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">DoCalcWitnessValue</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const final</td></tr>
<tr class="memdesc:ae1f1eff5e4fd7f55d152a1b3b9d4bcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes will implement this method to evaluate a witness function at the given context.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">More...</a><br /></td></tr>
<tr class="separator:ae1f1eff5e4fd7f55d152a1b3b9d4bcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3167bd30bfa014aa61d55fb50ed36f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">AddTriggeredWitnessFunctionToCompositeEventCollection</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *event, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const final</td></tr>
<tr class="memdesc:af3167bd30bfa014aa61d55fb50ed36f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>event</code> to <code>events</code> due to a witness function triggering.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">More...</a><br /></td></tr>
<tr class="separator:af3167bd30bfa014aa61d55fb50ed36f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c883b4b0aa7a507e29dee582d9ed0fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">DoCalcNextUpdateTime</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events, T *time) const override</td></tr>
<tr class="memdesc:a5c883b4b0aa7a507e29dee582d9ed0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the next update time based on the configured periodic events, for scalar types that are arithmetic, or aborts for scalar types that are not arithmetic.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">More...</a><br /></td></tr>
<tr class="separator:a5c883b4b0aa7a507e29dee582d9ed0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac370e74eb508e94b3eee667977d7185a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">GetGraphvizFragment</a> (int max_depth, std::stringstream *dot) const override</td></tr>
<tr class="memdesc:ac370e74eb508e94b3eee667977d7185a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a graphviz fragment for this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">More...</a><br /></td></tr>
<tr class="separator:ac370e74eb508e94b3eee667977d7185a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd6d412aafdf2814ced8e8fe460fc23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">GetGraphvizInputPortToken</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a71f36e6a47a3d2af2fd2f848771edf7d">port</a>, int max_depth, std::stringstream *dot) const final</td></tr>
<tr class="memdesc:acfd6d412aafdf2814ced8e8fe460fc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">More...</a><br /></td></tr>
<tr class="separator:acfd6d412aafdf2814ced8e8fe460fc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37060c889e34319f11652b5ad21cfbb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">GetGraphvizOutputPortToken</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a71f36e6a47a3d2af2fd2f848771edf7d">port</a>, int max_depth, std::stringstream *dot) const final</td></tr>
<tr class="memdesc:a37060c889e34319f11652b5ad21cfbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">More...</a><br /></td></tr>
<tr class="separator:a37060c889e34319f11652b5ad21cfbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac964670fe031a2b4ea84dda682b953cd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac964670fe031a2b4ea84dda682b953cd">AllocateContinuousState</a> () const</td></tr>
<tr class="memdesc:ac964670fe031a2b4ea84dda682b953cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the state declared in the most recent <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a52a8bc29fc2fdead9b757e06c5c8a5c0" title="Declares that this System should reserve continuous state with num_state_variables state variables,...">DeclareContinuousState()</a> call, or else a zero-sized state if that method has never been called.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac964670fe031a2b4ea84dda682b953cd">More...</a><br /></td></tr>
<tr class="separator:ac964670fe031a2b4ea84dda682b953cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5bee14a5df344e745f70b84388cbe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a74c5bee14a5df344e745f70b84388cbe">AllocateDiscreteState</a> () const</td></tr>
<tr class="memdesc:a74c5bee14a5df344e745f70b84388cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the states declared in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2" title="Declares a discrete state group with model_vector.size() state variables, stored in a vector cloned f...">DeclareDiscreteState()</a> calls.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a74c5bee14a5df344e745f70b84388cbe">More...</a><br /></td></tr>
<tr class="separator:a74c5bee14a5df344e745f70b84388cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e7d622e6bb31031ed0c9d7662333cd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_abstract_values.html">AbstractValues</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7e7d622e6bb31031ed0c9d7662333cd">AllocateAbstractState</a> () const</td></tr>
<tr class="memdesc:ad7e7d622e6bb31031ed0c9d7662333cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the states declared in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a471cc890e1d5fb20b9b257853d88cac4" title="Declares an abstract state.">DeclareAbstractState()</a> calls.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7e7d622e6bb31031ed0c9d7662333cd">More...</a><br /></td></tr>
<tr class="separator:ad7e7d622e6bb31031ed0c9d7662333cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4183810e51d405f7b9ad94a1e9c4a7ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4183810e51d405f7b9ad94a1e9c4a7ae">AllocateParameters</a> () const</td></tr>
<tr class="memdesc:a4183810e51d405f7b9ad94a1e9c4a7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the parameters declared in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a6516c166d4aedeab3ae31544bbaecbba" title="Declares a numeric parameter using the given model_vector.">DeclareNumericParameter()</a> and <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7f954e701d1bfba3f8aad91dd4d89ca" title="Declares an abstract parameter using the given model_value.">DeclareAbstractParameter()</a> calls.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4183810e51d405f7b9ad94a1e9c4a7ae">More...</a><br /></td></tr>
<tr class="separator:a4183810e51d405f7b9ad94a1e9c4a7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516c166d4aedeab3ae31544bbaecbba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a6516c166d4aedeab3ae31544bbaecbba">DeclareNumericParameter</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a6516c166d4aedeab3ae31544bbaecbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a numeric parameter using the given <code>model_vector</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a6516c166d4aedeab3ae31544bbaecbba">More...</a><br /></td></tr>
<tr class="separator:a6516c166d4aedeab3ae31544bbaecbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a60af942a6a568694334837d19931"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class U = BasicVector&gt; </td></tr>
<tr class="memitem:a4e4a60af942a6a568694334837d19931"><td class="memTemplItemLeft" align="right" valign="top">const U&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4e4a60af942a6a568694334837d19931">GetNumericParameter</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, int index) const</td></tr>
<tr class="memdesc:a4e4a60af942a6a568694334837d19931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the numeric parameters of type U from the <code>context</code> at <code>index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4e4a60af942a6a568694334837d19931">More...</a><br /></td></tr>
<tr class="separator:a4e4a60af942a6a568694334837d19931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab003f82ede0c6e8e6f1f1862ea54b31d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class U = BasicVector&gt; </td></tr>
<tr class="memitem:ab003f82ede0c6e8e6f1f1862ea54b31d"><td class="memTemplItemLeft" align="right" valign="top">U&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab003f82ede0c6e8e6f1f1862ea54b31d">GetMutableNumericParameter</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, int index) const</td></tr>
<tr class="memdesc:ab003f82ede0c6e8e6f1f1862ea54b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the numeric parameters of type U from the <code>context</code> at <code>index</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab003f82ede0c6e8e6f1f1862ea54b31d">More...</a><br /></td></tr>
<tr class="separator:ab003f82ede0c6e8e6f1f1862ea54b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f954e701d1bfba3f8aad91dd4d89ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7f954e701d1bfba3f8aad91dd4d89ca">DeclareAbstractParameter</a> (const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="memdesc:ad7f954e701d1bfba3f8aad91dd4d89ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract parameter using the given <code>model_value</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7f954e701d1bfba3f8aad91dd4d89ca">More...</a><br /></td></tr>
<tr class="separator:ad7f954e701d1bfba3f8aad91dd4d89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare periodic events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="declare_periodic_events"></a> Methods in this group declare that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> has an event that is triggered periodically. The first periodic trigger will occur at t = <code>offset_sec</code>, and it will recur at every <code>period_sec</code> thereafter. Several signatures are provided to allow for a general <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object to be triggered or for simpler class member functions to be invoked instead.</p>
<p>Reaching a designated time causes a periodic event to be dispatched to one of the three available types of event dispatcher: publish (read only), discrete update, and unrestricted update.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to handle timed events that are <em>not</em> periodic (timers, alarms, etc.), overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb" title="Computes the next update time based on the configured periodic events, for scalar types that are arit...">DoCalcNextUpdateTime()</a> rather than using the methods in this section.</dd></dl>
<p>Template arguments to these methods are inferred from the argument lists and need not be specified explicitly. </p><dl class="section pre"><dt>Precondition</dt><dd><code>period_sec</code> &gt; 0 and <code>offset_sec</code> ≥ 0. </dd></dl>
</div></td></tr>
<tr class="memitem:ad7786537a2832acd0d4f0d80827c1291"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:ad7786537a2832acd0d4f0d80827c1291"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7786537a2832acd0d4f0d80827c1291">DeclarePeriodicPublishEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*publish)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const)</td></tr>
<tr class="memdesc:ad7786537a2832acd0d4f0d80827c1291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that a Publish event should occur periodically and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7786537a2832acd0d4f0d80827c1291">More...</a><br /></td></tr>
<tr class="separator:ad7786537a2832acd0d4f0d80827c1291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8c9a5a1c5b17e10fdef61456ce228"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:acdd8c9a5a1c5b17e10fdef61456ce228"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#acdd8c9a5a1c5b17e10fdef61456ce228">DeclarePeriodicPublishEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, void(MySystem::*publish)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const)</td></tr>
<tr class="memdesc:acdd8c9a5a1c5b17e10fdef61456ce228"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variant accepts a handler that is assumed to succeed rather than one that returns an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> result.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#acdd8c9a5a1c5b17e10fdef61456ce228">More...</a><br /></td></tr>
<tr class="separator:acdd8c9a5a1c5b17e10fdef61456ce228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e4b4a7f8de8106e56bc49e36c07dec"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a30e4b4a7f8de8106e56bc49e36c07dec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a30e4b4a7f8de8106e56bc49e36c07dec">DeclarePeriodicDiscreteUpdateEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a30e4b4a7f8de8106e56bc49e36c07dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that a DiscreteUpdate event should occur periodically and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a30e4b4a7f8de8106e56bc49e36c07dec">More...</a><br /></td></tr>
<tr class="separator:a30e4b4a7f8de8106e56bc49e36c07dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678e6682500a1f0bb71bbd1fd454324"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a5678e6682500a1f0bb71bbd1fd454324"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5678e6682500a1f0bb71bbd1fd454324">DeclarePeriodicDiscreteUpdateEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, void(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a5678e6682500a1f0bb71bbd1fd454324"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variant accepts a handler that is assumed to succeed rather than one that returns an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> result.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5678e6682500a1f0bb71bbd1fd454324">More...</a><br /></td></tr>
<tr class="separator:a5678e6682500a1f0bb71bbd1fd454324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb4770f2d9a82d9012da69ed102ffe5"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a7fb4770f2d9a82d9012da69ed102ffe5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7fb4770f2d9a82d9012da69ed102ffe5">DeclarePeriodicUnrestrictedUpdateEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a7fb4770f2d9a82d9012da69ed102ffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that an UnrestrictedUpdate event should occur periodically and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7fb4770f2d9a82d9012da69ed102ffe5">More...</a><br /></td></tr>
<tr class="separator:a7fb4770f2d9a82d9012da69ed102ffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269f10abf498f5b956d9d916f217b0f3"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a269f10abf498f5b956d9d916f217b0f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a269f10abf498f5b956d9d916f217b0f3">DeclarePeriodicUnrestrictedUpdateEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, void(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a269f10abf498f5b956d9d916f217b0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variant accepts a handler that is assumed to succeed rather than one that returns an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> result.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a269f10abf498f5b956d9d916f217b0f3">More...</a><br /></td></tr>
<tr class="separator:a269f10abf498f5b956d9d916f217b0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e5397a57ec949d737f0a7aafd361c1"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a50e5397a57ec949d737f0a7aafd361c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1">DeclarePeriodicEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, const EventType &amp;event)</td></tr>
<tr class="memdesc:a50e5397a57ec949d737f0a7aafd361c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares that a particular <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object should be dispatched periodically.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1">More...</a><br /></td></tr>
<tr class="separator:a50e5397a57ec949d737f0a7aafd361c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adf7020dee795fd1b34b023c447eb6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a1adf7020dee795fd1b34b023c447eb6f">DeclarePeriodicPublish</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec=0)</td></tr>
<tr class="memdesc:a1adf7020dee795fd1b34b023c447eb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(To be deprecated) Declares a periodic publish event that invokes the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01" title="This method is the public entry point for dispatching all publish event handlers.">Publish()</a> dispatcher but does not provide a handler function.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a1adf7020dee795fd1b34b023c447eb6f">More...</a><br /></td></tr>
<tr class="separator:a1adf7020dee795fd1b34b023c447eb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262f71637a37127840acefca3bda8897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a262f71637a37127840acefca3bda8897">DeclarePeriodicDiscreteUpdate</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec=0)</td></tr>
<tr class="memdesc:a262f71637a37127840acefca3bda8897"><td class="mdescLeft">&#160;</td><td class="mdescRight">(To be deprecated) Declares a periodic discrete update event that invokes the DiscreteUpdate() dispatcher but does not provide a handler function.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a262f71637a37127840acefca3bda8897">More...</a><br /></td></tr>
<tr class="separator:a262f71637a37127840acefca3bda8897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d2dbe47bcb217706226101ed7218bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a17d2dbe47bcb217706226101ed7218bc">DeclarePeriodicUnrestrictedUpdate</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec=0)</td></tr>
<tr class="memdesc:a17d2dbe47bcb217706226101ed7218bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(To be deprecated) Declares a periodic unrestricted update event that invokes the UnrestrictedUpdate() dispatcher but does not provide a handler function.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a17d2dbe47bcb217706226101ed7218bc">More...</a><br /></td></tr>
<tr class="separator:a17d2dbe47bcb217706226101ed7218bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare per-step events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="declare_per-step_events"></a> These methods are used to declare events that are triggered whenever the Drake Simulator advances the simulated trajectory. Note that each call to Simulator::AdvanceTo() typically generates many trajectory-advancing steps of varying time intervals; per-step events are triggered for each of those steps.</p>
<p>Per-step events are useful for taking discrete action at every point of a simulated trajectory (generally spaced irregularly in time) without missing anything. For example, per-step events can be used to implement a high-accuracy signal delay by maintaining a buffer of past signal values, updated at each step. Because the steps are smaller in regions of rapid change, the interpolated signal retains the accuracy provided by the denser sampling. A periodic sampling would produce less-accurate interpolations.</p>
<p>As with any Drake event trigger type, a per-step event is dispatched to one of the three available types of event dispatcher: publish (read only), discrete state update, and unrestricted state update. Several signatures are provided below to allow for a general <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object to be triggered, or simpler class member functions to be invoked instead.</p>
<p>Per-step events are issued as follows: First, the Simulator::Initialize() method queries and records the set of declared per-step events. That set does not change during a simulation. Any per-step publish events are dispatched at the end of Initialize() to publish the initial value of the trajectory. Then every AdvanceTo() internal step dispatches unrestricted and discrete update events at the start of the step, and dispatches publish events at the end of the step (that is, after time advances). This means that a per-step event at fixed step size h behaves identically to a periodic event of period h, offset 0.</p>
<p>Template arguments to these methods are inferred from the argument lists and need not be specified explicitly. </p>
</div></td></tr>
<tr class="memitem:a49a07c6bbccc4464d5d6192889c3d2e6"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a49a07c6bbccc4464d5d6192889c3d2e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a49a07c6bbccc4464d5d6192889c3d2e6">DeclarePerStepPublishEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*publish)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const)</td></tr>
<tr class="memdesc:a49a07c6bbccc4464d5d6192889c3d2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that a Publish event should occur at initialization and at the end of every trajectory-advancing step and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a49a07c6bbccc4464d5d6192889c3d2e6">More...</a><br /></td></tr>
<tr class="separator:a49a07c6bbccc4464d5d6192889c3d2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045f31a25ecb0c57baede1abd70182a8"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a045f31a25ecb0c57baede1abd70182a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a045f31a25ecb0c57baede1abd70182a8">DeclarePerStepDiscreteUpdateEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a045f31a25ecb0c57baede1abd70182a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that a DiscreteUpdate event should occur at the start of every trajectory-advancing step and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a045f31a25ecb0c57baede1abd70182a8">More...</a><br /></td></tr>
<tr class="separator:a045f31a25ecb0c57baede1abd70182a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d51151d69bb455091dc4c2f4c42729a"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a0d51151d69bb455091dc4c2f4c42729a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0d51151d69bb455091dc4c2f4c42729a">DeclarePerStepUnrestrictedUpdateEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a0d51151d69bb455091dc4c2f4c42729a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that an UnrestrictedUpdate event should occur at the start of every trajectory-advancing step and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0d51151d69bb455091dc4c2f4c42729a">More...</a><br /></td></tr>
<tr class="separator:a0d51151d69bb455091dc4c2f4c42729a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901aafa8a436a6988c5cd35527392700"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a901aafa8a436a6988c5cd35527392700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700">DeclarePerStepEvent</a> (const EventType &amp;event)</td></tr>
<tr class="memdesc:a901aafa8a436a6988c5cd35527392700"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares that a particular <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object should be dispatched at every trajectory-advancing step.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700">More...</a><br /></td></tr>
<tr class="separator:a901aafa8a436a6988c5cd35527392700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare initialization events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="declare_initialization_events"></a> These methods are used to declare events that occur when the Drake Simulator::Initialize() method is invoked.</p>
<p>During Initialize(), initialization-triggered unrestricted update events are dispatched first for the whole <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_diagram.html">Diagram</a>, then initialization-triggered discrete update events are dispatched for the whole <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_diagram.html">Diagram</a>. No other <em>update</em> events occur during initialization. On the other hand, any <em>publish</em> events, including initialization-triggered, per-step, and time-triggered publish events that trigger at the initial time, are dispatched together during initialization.</p>
<p>Template arguments to these methods are inferred from the argument lists and need not be specified explicitly. </p>
</div></td></tr>
<tr class="memitem:aab3136bba7eb6480a84309d019b28d83"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:aab3136bba7eb6480a84309d019b28d83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aab3136bba7eb6480a84309d019b28d83">DeclareInitializationPublishEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*publish)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const)</td></tr>
<tr class="memdesc:aab3136bba7eb6480a84309d019b28d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that a Publish event should occur at initialization and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aab3136bba7eb6480a84309d019b28d83">More...</a><br /></td></tr>
<tr class="separator:aab3136bba7eb6480a84309d019b28d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7028e25a5d6e402a156a0115019a4"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:ab4e7028e25a5d6e402a156a0115019a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab4e7028e25a5d6e402a156a0115019a4">DeclareInitializationDiscreteUpdateEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:ab4e7028e25a5d6e402a156a0115019a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that a DiscreteUpdate event should occur at initialization and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab4e7028e25a5d6e402a156a0115019a4">More...</a><br /></td></tr>
<tr class="separator:ab4e7028e25a5d6e402a156a0115019a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04f150e6036b0cbbf9808cc0f71a9a6"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:ae04f150e6036b0cbbf9808cc0f71a9a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae04f150e6036b0cbbf9808cc0f71a9a6">DeclareInitializationUnrestrictedUpdateEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:ae04f150e6036b0cbbf9808cc0f71a9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that an UnrestrictedUpdate event should occur at initialization and that it should invoke the given event handler method.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae04f150e6036b0cbbf9808cc0f71a9a6">More...</a><br /></td></tr>
<tr class="separator:ae04f150e6036b0cbbf9808cc0f71a9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048bf857e2856f50fc08211a18348563"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a048bf857e2856f50fc08211a18348563"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563">DeclareInitializationEvent</a> (const EventType &amp;event)</td></tr>
<tr class="memdesc:a048bf857e2856f50fc08211a18348563"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares that a particular <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object should be dispatched at initialization.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563">More...</a><br /></td></tr>
<tr class="separator:a048bf857e2856f50fc08211a18348563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare forced events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="declare_forced_events"></a> Forced events are those that are triggered through invocation of System::Publish(const Context&amp;), System::CalcDiscreteVariableUpdates(const Context&amp;, DiscreteValues&lt;T&gt;*), or System::CalcUnrestrictedUpdate(const Context&amp;, State&lt;T&gt;*), rather than as a response to some computation-related event (e.g., the beginning of a period of time was reached, a trajectory advancing step was performed, etc.) One useful application of a forced publish: a process receives a network message and wants to trigger message emissions in various systems embedded within a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_diagram.html">Diagram</a> in response.</p>
<p>Template arguments to these methods are inferred from the argument lists. and need not be specified explicitly.</p>
<dl class="section note"><dt>Note</dt><dd>It's rare that an event needs to be triggered by force. Please consider per-step and periodic triggered events first.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Simulator handles forced publish events at initialization and on a per-step basis when its "publish at initialization" and "publish every time step" options are set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Simulator::set_publish_at_initialization() </dd>
<dd>
Simulator::set_publish_every_time_step() </dd></dl>
</div></td></tr>
<tr class="memitem:a79bf931890fb3c7e9e4fd0f2696ca994"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a79bf931890fb3c7e9e4fd0f2696ca994"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a79bf931890fb3c7e9e4fd0f2696ca994">DeclareForcedPublishEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*publish)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const)</td></tr>
<tr class="memdesc:a79bf931890fb3c7e9e4fd0f2696ca994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a function that is called whenever a user directly calls Publish(const Context&amp;).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a79bf931890fb3c7e9e4fd0f2696ca994">More...</a><br /></td></tr>
<tr class="separator:a79bf931890fb3c7e9e4fd0f2696ca994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b5bee56aa04d7853ba456b85775f7e"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:ad3b5bee56aa04d7853ba456b85775f7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad3b5bee56aa04d7853ba456b85775f7e">DeclareForcedDiscreteUpdateEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:ad3b5bee56aa04d7853ba456b85775f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a function that is called whenever a user directly calls CalcDiscreteVariableUpdates(const Context&amp;, DiscreteValues&lt;T&gt;*).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad3b5bee56aa04d7853ba456b85775f7e">More...</a><br /></td></tr>
<tr class="separator:ad3b5bee56aa04d7853ba456b85775f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68430eb8f9451787a183c48fca2c81"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a7d68430eb8f9451787a183c48fca2c81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7d68430eb8f9451787a183c48fca2c81">DeclareForcedUnrestrictedUpdateEvent</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*update)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const)</td></tr>
<tr class="memdesc:a7d68430eb8f9451787a183c48fca2c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a function that is called whenever a user directly calls CalcUnrestrictedUpdate(const Context&amp;, State&lt;T&gt;*).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7d68430eb8f9451787a183c48fca2c81">More...</a><br /></td></tr>
<tr class="separator:a7d68430eb8f9451787a183c48fca2c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare continuous state variables</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Continuous state consists of up to three kinds of variables: generalized coordinates q, generalized velocities v, and miscellaneous continuous variables z.</p>
<p>Methods in this section provide different ways to declare these, and offer the ability to provide a <code>model_vector</code> to specify the initial values for these variables. Model values are useful when you want the values of these variables in a default <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to be something other than zero.</p>
<p>If multiple calls are made to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a52a8bc29fc2fdead9b757e06c5c8a5c0" title="Declares that this System should reserve continuous state with num_state_variables state variables,...">DeclareContinuousState()</a> methods, only the last call has any effect. </p>
</div></td></tr>
<tr class="memitem:a52a8bc29fc2fdead9b757e06c5c8a5c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a52a8bc29fc2fdead9b757e06c5c8a5c0">DeclareContinuousState</a> (int num_state_variables)</td></tr>
<tr class="memdesc:a52a8bc29fc2fdead9b757e06c5c8a5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>num_state_variables</code> state variables, which have no second-order structure.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a52a8bc29fc2fdead9b757e06c5c8a5c0">More...</a><br /></td></tr>
<tr class="separator:a52a8bc29fc2fdead9b757e06c5c8a5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ad7afd2779aef7414c26220440403e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a59ad7afd2779aef7414c26220440403e">DeclareContinuousState</a> (int num_q, int num_v, int num_z)</td></tr>
<tr class="memdesc:a59ad7afd2779aef7414c26220440403e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>num_q</code> generalized positions, <code>num_v</code> generalized velocities, and <code>num_z</code> miscellaneous state variables.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a59ad7afd2779aef7414c26220440403e">More...</a><br /></td></tr>
<tr class="separator:a59ad7afd2779aef7414c26220440403e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992aa647fda36ce82828bd49381299e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab992aa647fda36ce82828bd49381299e">DeclareContinuousState</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:ab992aa647fda36ce82828bd49381299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>model_vector.size()</code> miscellaneous state variables, stored in a vector cloned from <code>model_vector</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab992aa647fda36ce82828bd49381299e">More...</a><br /></td></tr>
<tr class="separator:ab992aa647fda36ce82828bd49381299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6110544a3a4fd4a9085c2db10972c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a02c6110544a3a4fd4a9085c2db10972c">DeclareContinuousState</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, int num_q, int num_v, int num_z)</td></tr>
<tr class="memdesc:a02c6110544a3a4fd4a9085c2db10972c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>num_q</code> generalized positions, <code>num_v</code> generalized velocities, and <code>num_z</code> miscellaneous state variables, stored in a vector cloned from <code>model_vector</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a02c6110544a3a4fd4a9085c2db10972c">More...</a><br /></td></tr>
<tr class="separator:a02c6110544a3a4fd4a9085c2db10972c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare discrete state variables</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Discrete state consists of any number of discrete state "groups", each of which is a vector of discrete state variables.</p>
<p>Methods in this section provide different ways to declare these, and offer the ability to provide a <code>model_vector</code> to specify the initial values for each group of variables. Model values are useful when you want the values of these variables in a default <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to be something other than zero.</p>
<p>Each call to a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2" title="Declares a discrete state group with model_vector.size() state variables, stored in a vector cloned f...">DeclareDiscreteState()</a> method produces another discrete state group, and the group index is returned. </p>
</div></td></tr>
<tr class="memitem:a47ef984b4d9b8313d1239b76388882d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2">DeclareDiscreteState</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a47ef984b4d9b8313d1239b76388882d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a discrete state group with <code>model_vector.size()</code> state variables, stored in a vector cloned from <code>model_vector</code> (preserving the concrete type and value).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2">More...</a><br /></td></tr>
<tr class="separator:a47ef984b4d9b8313d1239b76388882d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdee5c47f728c1c50b84fc54c26374e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#afcdee5c47f728c1c50b84fc54c26374e">DeclareDiscreteState</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;vector)</td></tr>
<tr class="memdesc:afcdee5c47f728c1c50b84fc54c26374e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a discrete state group with <code>vector.size()</code> state variables, stored in a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> initialized with the contents of <code>vector</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#afcdee5c47f728c1c50b84fc54c26374e">More...</a><br /></td></tr>
<tr class="separator:afcdee5c47f728c1c50b84fc54c26374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02cadb14746ff469fa338d2351a5e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad02cadb14746ff469fa338d2351a5e68">DeclareDiscreteState</a> (int num_state_variables)</td></tr>
<tr class="memdesc:ad02cadb14746ff469fa338d2351a5e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a discrete state group with <code>num_state_variables</code> state variables, stored in a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> initialized to be all-zero.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad02cadb14746ff469fa338d2351a5e68">More...</a><br /></td></tr>
<tr class="separator:ad02cadb14746ff469fa338d2351a5e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare abstract state variables</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Abstract state consists of any number of arbitrarily-typed variables, each represented by an <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html" title="A fully type-erased container class.">AbstractValue</a>.</p>
<p>Each call to the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a471cc890e1d5fb20b9b257853d88cac4" title="Declares an abstract state.">DeclareAbstractState()</a> method produces another abstract state variable, and the abstract state variable index is returned. </p>
</div></td></tr>
<tr class="memitem:a471cc890e1d5fb20b9b257853d88cac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a471cc890e1d5fb20b9b257853d88cac4">DeclareAbstractState</a> (const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;abstract_state)</td></tr>
<tr class="memdesc:a471cc890e1d5fb20b9b257853d88cac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract state.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a471cc890e1d5fb20b9b257853d88cac4">More...</a><br /></td></tr>
<tr class="separator:a471cc890e1d5fb20b9b257853d88cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">(Advanced) Declare size of implicit time derivatives residual</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>for use with System::CalcImplicitTimeDerivativeResidual().</p>
<p>Most commonly the default value, same as num_continuous_states(), will be the correct size for the residual. </p>
</div></td></tr>
<tr class="memitem:af35335637b5cf1c763d5e9112864fe09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af35335637b5cf1c763d5e9112864fe09">DeclareImplicitTimeDerivativesResidualSize</a> (int n)</td></tr>
<tr class="memdesc:af35335637b5cf1c763d5e9112864fe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Overrides the default size for the implicit time derivatives residual.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af35335637b5cf1c763d5e9112864fe09">More...</a><br /></td></tr>
<tr class="separator:af35335637b5cf1c763d5e9112864fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Declare input ports</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section are used by derived classes to declare their input ports, which may be vector valued or abstract valued.</p>
<p>You should normally provide a meaningful name for any input port you create. Names must be unique for this system (passing in a duplicate name will throw std::exception). However, if you specify kUseDefaultName as the name, then a default name of e.g. "u2", where 2 is the input port number will be provided. An empty name is not permitted. </p>
</div></td></tr>
<tr class="memitem:a5917e1a570b31a5737aec9b49f4c190a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5917e1a570b31a5737aec9b49f4c190a">DeclareVectorInputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=std::nullopt)</td></tr>
<tr class="memdesc:a5917e1a570b31a5737aec9b49f4c190a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued input port using the given <code>model_vector</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5917e1a570b31a5737aec9b49f4c190a">More...</a><br /></td></tr>
<tr class="separator:a5917e1a570b31a5737aec9b49f4c190a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4185d2244cddf8fce953f1c7ffbc514a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4185d2244cddf8fce953f1c7ffbc514a">DeclareVectorInputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, int size, std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=std::nullopt)</td></tr>
<tr class="memdesc:a4185d2244cddf8fce953f1c7ffbc514a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued input port with type <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> and size <code>size</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4185d2244cddf8fce953f1c7ffbc514a">More...</a><br /></td></tr>
<tr class="separator:a4185d2244cddf8fce953f1c7ffbc514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565c340c958e56d0d1967034fc42c906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a565c340c958e56d0d1967034fc42c906">DeclareAbstractInputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="memdesc:a565c340c958e56d0d1967034fc42c906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued input port using the given <code>model_value</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a565c340c958e56d0d1967034fc42c906">More...</a><br /></td></tr>
<tr class="separator:a565c340c958e56d0d1967034fc42c906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated input port declarations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section leave out the name parameter and are the same as invoking the corresponding method with <code>kUseDefaultName</code> as the name. </p>
</div></td></tr>
<tr class="memitem:aff6f3ee5d89fd1810639e04056768eba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aff6f3ee5d89fd1810639e04056768eba">DeclareVectorInputPort</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=std::nullopt)</td></tr>
<tr class="separator:aff6f3ee5d89fd1810639e04056768eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ad089c407e501a3ec99106ef06d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aaa2ad089c407e501a3ec99106ef06d0a">DeclareAbstractInputPort</a> (const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="separator:aaa2ad089c407e501a3ec99106ef06d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated output port declarations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section leave out the name parameter and are the same as invoking the corresponding method with <code>kUseDefaultName</code> as the name. </p>
</div></td></tr>
<tr class="memitem:ab80f86f8f54344373ce6597afd8fd55f"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:ab80f86f8f54344373ce6597afd8fd55f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab80f86f8f54344373ce6597afd8fd55f">DeclareVectorOutputPort</a> (const BasicVectorSubtype &amp;model_vector, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="separator:ab80f86f8f54344373ce6597afd8fd55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae593893666b820d3c725e1570967bd"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:afae593893666b820d3c725e1570967bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#afae593893666b820d3c725e1570967bd">DeclareVectorOutputPort</a> (void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="separator:afae593893666b820d3c725e1570967bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8555d0744eb060d4c9dc32506539197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aa8555d0744eb060d4c9dc32506539197">DeclareVectorOutputPort</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback vector_calc_function, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="separator:aa8555d0744eb060d4c9dc32506539197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0331978ee2acc1638874464addf8269b"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:a0331978ee2acc1638874464addf8269b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same_v&lt; OutputType, std::string &gt;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0331978ee2acc1638874464addf8269b">DeclareAbstractOutputPort</a> (const OutputType &amp;model_value, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="separator:a0331978ee2acc1638874464addf8269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5399d5518ba8953095e797b9ec9e3aa8"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:a5399d5518ba8953095e797b9ec9e3aa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a5399d5518ba8953095e797b9ec9e3aa8">DeclareAbstractOutputPort</a> (void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="separator:a5399d5518ba8953095e797b9ec9e3aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93557fbbbe84af162a8e15941a8d68a"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:ae93557fbbbe84af162a8e15941a8d68a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae93557fbbbe84af162a8e15941a8d68a">DeclareAbstractOutputPort</a> (OutputType(MySystem::*make)() const, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="separator:ae93557fbbbe84af162a8e15941a8d68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c9ed5dd1428fac9cb34dbdc4b0fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#acb2c9ed5dd1428fac9cb34dbdc4b0fe0">DeclareAbstractOutputPort</a> (typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::AllocCallback alloc_function, typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcCallback calc_function, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="separator:acb2c9ed5dd1428fac9cb34dbdc4b0fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmaliput_1_1drake_1_1systems_1_1_system')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System&lt; T &gt;</a></td></tr>
<tr class="memitem:aa1b849c60d9ec6bbfeac42dc3c075a02 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa1b849c60d9ec6bbfeac42dc3c075a02">System</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> converter)</td></tr>
<tr class="memdesc:aa1b849c60d9ec6bbfeac42dc3c075a02 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty System base class object and allocates base class resources, possibly supporting scalar-type conversion support (AutoDiff, etc.) using <code>converter</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa1b849c60d9ec6bbfeac42dc3c075a02">More...</a><br /></td></tr>
<tr class="separator:aa1b849c60d9ec6bbfeac42dc3c075a02 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b57e4cacf2beba4ef87c87f824aba8 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b57e4cacf2beba4ef87c87f824aba8">DeclareInputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> type, int size, std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=std::nullopt)</td></tr>
<tr class="memdesc:af0b57e4cacf2beba4ef87c87f824aba8 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a port with the specified <code>type</code> and <code>size</code> to the input topology.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b57e4cacf2beba4ef87c87f824aba8">More...</a><br /></td></tr>
<tr class="separator:af0b57e4cacf2beba4ef87c87f824aba8 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe346b9e2e3014575fcb225e80d97a65 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#abe346b9e2e3014575fcb225e80d97a65">DeclareInputPort</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> type, int size, std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=std::nullopt)</td></tr>
<tr class="separator:abe346b9e2e3014575fcb225e80d97a65 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fbf92ac77db4d805a5a5cf980de130 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac9fbf92ac77db4d805a5a5cf980de130">AddConstraint</a> (std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt;&gt; constraint)</td></tr>
<tr class="memdesc:ac9fbf92ac77db4d805a5a5cf980de130 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an already-created constraint to the list of constraints for this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac9fbf92ac77db4d805a5a5cf980de130">More...</a><br /></td></tr>
<tr class="separator:ac9fbf92ac77db4d805a5a5cf980de130 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8b3a6c3f9d024e15d98cb808dbbc17 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aed8b3a6c3f9d024e15d98cb808dbbc17">DoCalcTimeDerivatives</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:aed8b3a6c3f9d024e15d98cb808dbbc17 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this if you have any continuous state variables x꜀ in your concrete System to calculate their time derivatives.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aed8b3a6c3f9d024e15d98cb808dbbc17">More...</a><br /></td></tr>
<tr class="separator:aed8b3a6c3f9d024e15d98cb808dbbc17 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbe5f9cc83f774ffcaa87a5c1278446 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aacbe5f9cc83f774ffcaa87a5c1278446">DoCalcImplicitTimeDerivativesResidual</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;proposed_derivatives, <a class="el" href="classmaliput_1_1drake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; residual) const</td></tr>
<tr class="memdesc:aacbe5f9cc83f774ffcaa87a5c1278446 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this if you have an efficient way to evaluate the implicit time derivatives residual for this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aacbe5f9cc83f774ffcaa87a5c1278446">More...</a><br /></td></tr>
<tr class="separator:aacbe5f9cc83f774ffcaa87a5c1278446 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c349e8e8aed5454a6293c356a29a92 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a57c349e8e8aed5454a6293c356a29a92">DoCalcPotentialEnergy</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a57c349e8e8aed5454a6293c356a29a92 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the potential energy PE currently stored in the configuration provided in the given <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a57c349e8e8aed5454a6293c356a29a92">More...</a><br /></td></tr>
<tr class="separator:a57c349e8e8aed5454a6293c356a29a92 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c7b978ca681f773dcc13cc82bd834b inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a94c7b978ca681f773dcc13cc82bd834b">DoCalcKineticEnergy</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a94c7b978ca681f773dcc13cc82bd834b inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the kinetic energy KE currently present in the motion provided in the given <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a94c7b978ca681f773dcc13cc82bd834b">More...</a><br /></td></tr>
<tr class="separator:a94c7b978ca681f773dcc13cc82bd834b inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb639ec6f0b87551136907abbe377cb0 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#adb639ec6f0b87551136907abbe377cb0">DoCalcConservativePower</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:adb639ec6f0b87551136907abbe377cb0 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pc at which mechanical energy is being converted <em>from</em> potential energy <em>to</em> kinetic energy by this system in the given <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#adb639ec6f0b87551136907abbe377cb0">More...</a><br /></td></tr>
<tr class="separator:adb639ec6f0b87551136907abbe377cb0 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb9bf04beb39962554f61b99862da0 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0fbb9bf04beb39962554f61b99862da0">DoCalcNonConservativePower</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a0fbb9bf04beb39962554f61b99862da0 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pnc at which work W is done on the system by non-conservative forces.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0fbb9bf04beb39962554f61b99862da0">More...</a><br /></td></tr>
<tr class="separator:a0fbb9bf04beb39962554f61b99862da0 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433601e16c81b891db313d5356b46de5 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a433601e16c81b891db313d5356b46de5">DoMapQDotToVelocity</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a433601e16c81b891db313d5356b46de5 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v.">MapQDotToVelocity()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a433601e16c81b891db313d5356b46de5">More...</a><br /></td></tr>
<tr class="separator:a433601e16c81b891db313d5356b46de5 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0910a65b46512bbe7a2657a593d35c4c inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0910a65b46512bbe7a2657a593d35c4c">DoMapVelocityToQDot</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;generalized_velocity, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a0910a65b46512bbe7a2657a593d35c4c inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0910a65b46512bbe7a2657a593d35c4c">More...</a><br /></td></tr>
<tr class="separator:a0910a65b46512bbe7a2657a593d35c4c inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6278437ceb2dce5a6c8f70f19285319a inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6278437ceb2dce5a6c8f70f19285319a">GetMutableOutputVector</a> (<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *output, int port_index) const</td></tr>
<tr class="memdesc:a6278437ceb2dce5a6c8f70f19285319a inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable Eigen expression for a vector valued output port with index <code>port_index</code> in this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6278437ceb2dce5a6c8f70f19285319a">More...</a><br /></td></tr>
<tr class="separator:a6278437ceb2dce5a6c8f70f19285319a inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8812e3795d6c187c6f21fb441a717db inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad8812e3795d6c187c6f21fb441a717db">forced_publish_events_exist</a> () const</td></tr>
<tr class="separator:ad8812e3795d6c187c6f21fb441a717db inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582cbe45eeaf9fe74b7143a1b71ff958 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a582cbe45eeaf9fe74b7143a1b71ff958">forced_discrete_update_events_exist</a> () const</td></tr>
<tr class="separator:a582cbe45eeaf9fe74b7143a1b71ff958 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f70983cdba078821ed784fcf2f775f inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a06f70983cdba078821ed784fcf2f775f">forced_unrestricted_update_events_exist</a> () const</td></tr>
<tr class="separator:a06f70983cdba078821ed784fcf2f775f inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7af4df5b72b50d255dc99cddb67e4a6 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac7af4df5b72b50d255dc99cddb67e4a6">get_mutable_forced_publish_events</a> ()</td></tr>
<tr class="separator:ac7af4df5b72b50d255dc99cddb67e4a6 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed229e14777bd82382dc3ed6e715bd3 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#afed229e14777bd82382dc3ed6e715bd3">get_mutable_forced_discrete_update_events</a> ()</td></tr>
<tr class="separator:afed229e14777bd82382dc3ed6e715bd3 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856b6c5b4d66151f1f28d8645bf215c inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad856b6c5b4d66151f1f28d8645bf215c">get_mutable_forced_unrestricted_update_events</a> ()</td></tr>
<tr class="separator:ad856b6c5b4d66151f1f28d8645bf215c inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa532bcdc29e8be25c20b40968bb95b66 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aa532bcdc29e8be25c20b40968bb95b66">get_forced_publish_events</a> () const</td></tr>
<tr class="separator:aa532bcdc29e8be25c20b40968bb95b66 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3137d050d040e4beb9ef60cd004ac112 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a3137d050d040e4beb9ef60cd004ac112">get_forced_discrete_update_events</a> () const</td></tr>
<tr class="separator:a3137d050d040e4beb9ef60cd004ac112 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac53f82a39ea0c5e3240a9bab52b1415 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aac53f82a39ea0c5e3240a9bab52b1415">get_forced_unrestricted_update_events</a> () const</td></tr>
<tr class="separator:aac53f82a39ea0c5e3240a9bab52b1415 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7240490688324a9f15132fee98e52ce inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ac7240490688324a9f15132fee98e52ce">set_forced_publish_events</a> (std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:ac7240490688324a9f15132fee98e52ce inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0aacb96a01eb38099ac6cd4d12037b inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#afd0aacb96a01eb38099ac6cd4d12037b">set_forced_discrete_update_events</a> (std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:afd0aacb96a01eb38099ac6cd4d12037b inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5ab861b2f08ff5a29066458747b9a inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a75c5ab861b2f08ff5a29066458747b9a">set_forced_unrestricted_update_events</a> (std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:a75c5ab861b2f08ff5a29066458747b9a inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86649644cbbb5db1a63f2ef6dde59edd inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a86649644cbbb5db1a63f2ef6dde59edd">get_mutable_system_scalar_converter</a> ()</td></tr>
<tr class="memdesc:a86649644cbbb5db1a63f2ef6dde59edd inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> for <code>this</code> system.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a86649644cbbb5db1a63f2ef6dde59edd">More...</a><br /></td></tr>
<tr class="separator:a86649644cbbb5db1a63f2ef6dde59edd inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d780ac96e83eadd765f5c2fd1abbb4 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class Clazz&gt; </td></tr>
<tr class="memitem:a88d780ac96e83eadd765f5c2fd1abbb4 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a88d780ac96e83eadd765f5c2fd1abbb4">ValidateChildOfContext</a> (const Clazz&lt; T &gt; *object) const</td></tr>
<tr class="separator:a88d780ac96e83eadd765f5c2fd1abbb4 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9d6f71af96840edfe44f5d242156a8 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8">DoGetWitnessFunctions</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; * &gt; *) const</td></tr>
<tr class="memdesc:a0b9d6f71af96840edfe44f5d242156a8 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to provide witness functions active for the given state.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8">More...</a><br /></td></tr>
<tr class="separator:a0b9d6f71af96840edfe44f5d242156a8 inherit pro_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af0b9bc9f93181e042bdb2c36f4dbea10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a> ()</td></tr>
<tr class="memdesc:af0b9bc9f93181e042bdb2c36f4dbea10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries).  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af0b9bc9f93181e042bdb2c36f4dbea10">More...</a><br /></td></tr>
<tr class="separator:af0b9bc9f93181e042bdb2c36f4dbea10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Declare output ports</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3045e07ba33f5424e4ef70792029acf4"></a><a class="anchor" id="DeclareLeafOutputPort_documentation"></a> Methods in this section are used by derived classes to declare their output ports, which may be vector valued or abstract valued. Every output port must have an <em>allocator</em> function and a <em>calculator</em> function. The allocator returns an object suitable for holding a value of the output port. The calculator uses the contents of a given <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to produce the output port's value, which is placed in an object of the type returned by the allocator.</p>
<p>Although the allocator and calculator functions ultimately satisfy generic function signatures defined in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html" title="(Advanced.) Implements an output port whose value is managed by a cache entry in the same LeafSystem ...">LeafOutputPort</a>, we provide a variety of <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0" title="Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype deri...">DeclareVectorOutputPort()</a></code> and <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af669e17632efa35e1dd28f5af9a96b9b" title="Declares an abstract-valued output port by specifying a model value of concrete type OutputType and a...">DeclareAbstractOutputPort()</a></code> signatures here for convenient specification, with mapping to the generic form handled invisibly. In particular, allocators are most easily defined by providing a model value that can be used to construct an allocator that copies the model when a new value object is needed. Alternatively a method can be provided that constructs a value object when invoked (those methods are conventionally, but not necessarily, named <code>MakeSomething()</code> where <code>Something</code> is replaced by the output port value type).</p>
<p>Because output port values are ultimately stored in <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html" title="A fully type-erased container class.">AbstractValue</a> objects, the underlying types must be suitable. For vector ports, that means the type must be <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> or a class derived from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>. For abstract ports, the type must be copy constructible or cloneable. For methods below that are not given an explicit model value or construction ("make") method, the underlying type must be default constructible. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">maliput::drake::Value</a> for more about abstract values.</dd></dl>
<p>A list of prerequisites may be provided for the calculator function to avoid unnecessary recomputation. If no prerequisites are provided, the default is to assume the output port value is dependent on all possible sources. See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_base.html#DeclareCacheEntry_documentation">DeclareCacheEntry</a> for more information about prerequisites.</p>
<p>Output ports must have a name that is unique within the owning subsystem. Users can provide meaningful names or specify the name as <code>kUseDefaultName</code> in which case a name like "y3" is automatically provided, where the number is the output port index. An empty name is not permitted.</p>
<p><a class="anchor" id="DeclareLeafOutputPort_feedthrough"></a><em><u>Direct feedthrough</u></em></p>
<p>By default, LeafSystem assumes there is direct feedthrough of values from every input to every output. This is a conservative assumption that ensures we detect and can prevent the formation of algebraic loops (implicit computations) in system Diagrams. Systems which do not have direct feedthrough may override that assumption in either of two ways:</p>
<p>(1) When declaring an output port (e.g., <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0" title="Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype deri...">DeclareVectorOutputPort()</a>), provide a non-default value for the <code>prerequisites_of_calc</code> argument. In that case the dependency path from each input port to that output port is probed via the fast cache invalidation mechanism to see if it has a direct or indirect dependence that input port. For example: </p><div class="fragment"><div class="line">PendulumPlant&lt;T&gt;::PendulumPlant() {</div>
<div class="line">  <span class="comment">// No feedthrough because the output port depends only on state,</span></div>
<div class="line">  <span class="comment">// and state has no dependencies.</span></div>
<div class="line">  this-&gt;<a class="code" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0">DeclareVectorOutputPort</a>(</div>
<div class="line">      <span class="stringliteral">&quot;state&quot;</span>, &amp;PendulumPlant::CopyStateOut,</div>
<div class="line">      {this-&gt;<a class="code" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2789768c5d75378c081683a8016f0784">all_state_ticket</a>()});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Has feedthrough from input port 0 but not from any others.</span></div>
<div class="line">  this-&gt;<a class="code" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0">DeclareVectorOutputPort</a>(</div>
<div class="line">      <span class="stringliteral">&quot;tau&quot;</span>, &amp;PendulumPlant::CopyTauOut,</div>
<div class="line">      {this-&gt;<a class="code" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a191b7cb5dcbfee51a62fa042ec14561f">input_port_ticket</a>(<a class="code" href="namespacemaliput_1_1drake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a>(0))});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Doesn&#39;t specify prerequisites. We&#39;ll assume feedthrough from all</span></div>
<div class="line">  <span class="comment">// inputs unless we can apply symbolic analysis (see below).</span></div>
<div class="line">  this-&gt;<a class="code" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0">DeclareVectorOutputPort</a>(</div>
<div class="line">      <span class="stringliteral">&quot;result&quot;</span>, &amp;PendulumPlant::CalcResult);</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_base.html#DependencyTicket_documentation">Dependency tickets</a> for more information about tickets, including a list of possible ticket options.</p>
<p>(2) Add support for the symbolic::Expression scalar type, per <a class="el" href="group__system__scalar__conversion.html#system_scalar_conversion_how_to_write_a_system">How to write a System that supports scalar conversion</a>. This allows the LeafSystem to infer the sparsity from the symbolic equations for any of the output ports that don't specify an explicit list of prerequisites.</p>
<p>Option 2 is a convenient default for simple systems that already support symbolic::Expression, but option 1 should be preferred as the most direct mechanism to control feedthrough reporting.</p>
<p>Normally the direct-feedthrough relations are checked automatically to detect algebraic loops. If you want to examine the computed feedthrough status for all ports or a particular port, see System::GetDirectFeedthroughs(), <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a51acfa17df1bc87ce8eaa0e1556f6d46" title="Returns true if there might be direct-feedthrough from any input port to the given output_port,...">System::HasDirectFeedthrough()</a>, and related methods. </p>
</td></tr>
<tr class="memitem:aaa3ede112d18c271986b415c5bef53e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_value_producer.html#a4df060317da95358cd76822bd802de72">ValueProducer::AllocateCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aaa3ede112d18c271986b415c5bef53e1">allocate</a></td></tr>
<tr class="separator:aaa3ede112d18c271986b415c5bef53e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f36e6a47a3d2af2fd2f848771edf7d"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a71f36e6a47a3d2af2fd2f848771edf7d">port</a></td></tr>
<tr class="separator:a71f36e6a47a3d2af2fd2f848771edf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59f61b7b6e4f7c1ecac7d8f47e6616f"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae59f61b7b6e4f7c1ecac7d8f47e6616f">port</a></td></tr>
<tr class="separator:ae59f61b7b6e4f7c1ecac7d8f47e6616f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11479a5cb19f65f35f1a7f5530fb42a0"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:a11479a5cb19f65f35f1a7f5530fb42a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0">DeclareVectorOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, const BasicVectorSubtype &amp;model_vector, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:a11479a5cb19f65f35f1a7f5530fb42a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype derived from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> and initialized to the correct size and desired initial value, and (2) a calculator function that is a class member function (method) with signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0">More...</a><br /></td></tr>
<tr class="separator:a11479a5cb19f65f35f1a7f5530fb42a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e6bf117c89b76c8893cf45f1ba652a"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:ac0e6bf117c89b76c8893cf45f1ba652a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac0e6bf117c89b76c8893cf45f1ba652a">DeclareVectorOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, int size, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:ac0e6bf117c89b76c8893cf45f1ba652a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port with type <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> and size <code>size</code>, using the maliput::drake::dummy_value&lt;T&gt;, which is NaN when T = double.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac0e6bf117c89b76c8893cf45f1ba652a">More...</a><br /></td></tr>
<tr class="separator:ac0e6bf117c89b76c8893cf45f1ba652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580e15b4d10db0b8c07762b3ac36e632"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:a580e15b4d10db0b8c07762b3ac36e632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a580e15b4d10db0b8c07762b3ac36e632">DeclareVectorOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:a580e15b4d10db0b8c07762b3ac36e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port by specifying <em>only</em> a calculator function that is a class member function (method) with signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a580e15b4d10db0b8c07762b3ac36e632">More...</a><br /></td></tr>
<tr class="separator:a580e15b4d10db0b8c07762b3ac36e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5d6f493e1a290ab4ae6c12d28905b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8b5d6f493e1a290ab4ae6c12d28905b1">DeclareVectorOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback vector_calc_function, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={all_sources_ticket()})</td></tr>
<tr class="memdesc:a8b5d6f493e1a290ab4ae6c12d28905b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares a vector-valued output port using the given <code>model_vector</code> and a function for calculating the port's value at runtime.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8b5d6f493e1a290ab4ae6c12d28905b1">More...</a><br /></td></tr>
<tr class="separator:a8b5d6f493e1a290ab4ae6c12d28905b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3da3722efc85a5f8ab121b8c21664c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af3da3722efc85a5f8ab121b8c21664c5">DeclareVectorOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, int size, typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback vector_calc_function, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:af3da3722efc85a5f8ab121b8c21664c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares a vector-valued output port with type BasicVector&lt;T&gt; and size <code>size</code>, using the maliput::drake::dummy_value&lt;T&gt;, which is NaN when T = double.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af3da3722efc85a5f8ab121b8c21664c5">More...</a><br /></td></tr>
<tr class="separator:af3da3722efc85a5f8ab121b8c21664c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af669e17632efa35e1dd28f5af9a96b9b"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:af669e17632efa35e1dd28f5af9a96b9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af669e17632efa35e1dd28f5af9a96b9b">DeclareAbstractOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, const OutputType &amp;model_value, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:af669e17632efa35e1dd28f5af9a96b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued output port by specifying a model value of concrete type <code>OutputType</code> and a calculator function that is a class member function (method) with signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af669e17632efa35e1dd28f5af9a96b9b">More...</a><br /></td></tr>
<tr class="separator:af669e17632efa35e1dd28f5af9a96b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52af0c8afa64504398a2c447f28fa0"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:aea52af0c8afa64504398a2c447f28fa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aea52af0c8afa64504398a2c447f28fa0">DeclareAbstractOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:aea52af0c8afa64504398a2c447f28fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued output port by specifying only a calculator function that is a class member function (method) with signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aea52af0c8afa64504398a2c447f28fa0">More...</a><br /></td></tr>
<tr class="separator:aea52af0c8afa64504398a2c447f28fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ef897fdededa85dc5b1cef29009cf5"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:ae8ef897fdededa85dc5b1cef29009cf5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae8ef897fdededa85dc5b1cef29009cf5">DRAKE_DEPRECATED</a> (&quot;2021-11-01&quot;, &quot;This overload for <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af669e17632efa35e1dd28f5af9a96b9b">DeclareAbstractOutputPort</a> is rarely the best choice;&quot; &quot; it is unusual for a boutique allocation to return an abstract type by&quot; &quot; value rather than provide a model_value. If the default constructor&quot; &quot; or a model value cannot be used, use the overload that accepts an&quot; &quot; AllocCallback alloc_function instead.&quot;) LeafOutputPort&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af669e17632efa35e1dd28f5af9a96b9b">DeclareAbstractOutputPort</a>(std</td></tr>
<tr class="separator:ae8ef897fdededa85dc5b1cef29009cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa4456210daa5f5db91308fcd1a59b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#afaa4456210daa5f5db91308fcd1a59b4">MALIPUT_DRAKE_DEMAND</a> (this_ptr !=nullptr)</td></tr>
<tr class="separator:afaa4456210daa5f5db91308fcd1a59b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f77588778c7353bbbcb0e1359a42ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aa2f77588778c7353bbbcb0e1359a42ac">DeclareAbstractOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::AllocCallback alloc_function, typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcCallback calc_function, std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ all_sources_ticket()})</td></tr>
<tr class="memdesc:aa2f77588778c7353bbbcb0e1359a42ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares an abstract-valued output port using the given allocator and calculator functions provided in their most generic forms.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aa2f77588778c7353bbbcb0e1359a42ac">More...</a><br /></td></tr>
<tr class="separator:aa2f77588778c7353bbbcb0e1359a42ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1ea2f7fdb9121ecc50705bb8ed2fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4f1ea2f7fdb9121ecc50705bb8ed2fb5">DeclareStateOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a> state_index)</td></tr>
<tr class="memdesc:a4f1ea2f7fdb9121ecc50705bb8ed2fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port whose value is the continuous state of this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4f1ea2f7fdb9121ecc50705bb8ed2fb5">More...</a><br /></td></tr>
<tr class="separator:a4f1ea2f7fdb9121ecc50705bb8ed2fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d533da6efa2843071c8d123c6e4800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a93d533da6efa2843071c8d123c6e4800">DeclareStateOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> state_index)</td></tr>
<tr class="memdesc:a93d533da6efa2843071c8d123c6e4800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port whose value is the given discrete state group of this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a93d533da6efa2843071c8d123c6e4800">More...</a><br /></td></tr>
<tr class="separator:a93d533da6efa2843071c8d123c6e4800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaf3f126c716c557ba620cb56caca18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#adcaf3f126c716c557ba620cb56caca18">DeclareStateOutputPort</a> (std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> state_index)</td></tr>
<tr class="memdesc:adcaf3f126c716c557ba620cb56caca18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued output port whose value is the given abstract state of this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#adcaf3f126c716c557ba620cb56caca18">More...</a><br /></td></tr>
<tr class="separator:adcaf3f126c716c557ba620cb56caca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Make witness functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe3de5325f0da828c53e0d77825bfd30d"></a>Methods in this section are used by derived classes to make any witness functions useful for ensuring that integration ends a step upon entering particular times or states.</p>
<p>In contrast to other declaration methods (e.g., <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0" title="Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype deri...">DeclareVectorOutputPort()</a>, for which the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> class creates and stores the objects and returns references to them, the witness function declaration functions return heap-allocated objects that the subclass of leaf system owns. This facilitates returning pointers to these objects in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. </p>
</td></tr>
<tr class="memitem:a8d09351dbeec49917149d6da5b701c12"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a8d09351dbeec49917149d6da5b701c12"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8d09351dbeec49917149d6da5b701c12">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const) const</td></tr>
<tr class="memdesc:a8d09351dbeec49917149d6da5b701c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function; and with no event object.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a8d09351dbeec49917149d6da5b701c12">More...</a><br /></td></tr>
<tr class="separator:a8d09351dbeec49917149d6da5b701c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab146f195a06073ce0987f6b531fa9ea3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab146f195a06073ce0987f6b531fa9ea3">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, std::function&lt; T(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt; calc) const</td></tr>
<tr class="memdesc:ab146f195a06073ce0987f6b531fa9ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function; and with no event object.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab146f195a06073ce0987f6b531fa9ea3">More...</a><br /></td></tr>
<tr class="separator:ab146f195a06073ce0987f6b531fa9ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1b41173a1b0149226c9d5b7c3601ce"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a6a1b41173a1b0149226c9d5b7c3601ce"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a6a1b41173a1b0149226c9d5b7c3601ce">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, void(MySystem::*publish_callback)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &amp;) const) const</td></tr>
<tr class="memdesc:a6a1b41173a1b0149226c9d5b7c3601ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and publish event callback function for when this triggers.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a6a1b41173a1b0149226c9d5b7c3601ce">More...</a><br /></td></tr>
<tr class="separator:a6a1b41173a1b0149226c9d5b7c3601ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78860f078c81981b9acc498186d5d94"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:ad78860f078c81981b9acc498186d5d94"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad78860f078c81981b9acc498186d5d94">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, void(MySystem::*du_callback)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const) const</td></tr>
<tr class="memdesc:ad78860f078c81981b9acc498186d5d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and discrete update event callback function for when this triggers.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad78860f078c81981b9acc498186d5d94">More...</a><br /></td></tr>
<tr class="separator:ad78860f078c81981b9acc498186d5d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521a1bd4eee88561b0e1a3b06b7fe1b7"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a521a1bd4eee88561b0e1a3b06b7fe1b7"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a521a1bd4eee88561b0e1a3b06b7fe1b7">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, void(MySystem::*uu_callback)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const) const</td></tr>
<tr class="memdesc:a521a1bd4eee88561b0e1a3b06b7fe1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and unrestricted update event callback function for when this triggers.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a521a1bd4eee88561b0e1a3b06b7fe1b7">More...</a><br /></td></tr>
<tr class="separator:a521a1bd4eee88561b0e1a3b06b7fe1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650d4bdc065de71ea29a608f9e5a1261"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a650d4bdc065de71ea29a608f9e5a1261"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a650d4bdc065de71ea29a608f9e5a1261">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; &amp;e) const</td></tr>
<tr class="memdesc:a650d4bdc065de71ea29a608f9e5a1261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function, and with an object corresponding to the event that is to be dispatched when this witness function triggers.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a650d4bdc065de71ea29a608f9e5a1261">More...</a><br /></td></tr>
<tr class="separator:a650d4bdc065de71ea29a608f9e5a1261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3134d4dd585005d1dc8687dc619a9e0c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3134d4dd585005d1dc8687dc619a9e0c">MakeWitnessFunction</a> (const std::string &amp;description, const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, std::function&lt; T(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt; calc, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; &amp;e) const</td></tr>
<tr class="memdesc:a3134d4dd585005d1dc8687dc619a9e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function, and with an object corresponding to the event that is to be dispatched when this witness function triggers.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3134d4dd585005d1dc8687dc619a9e0c">More...</a><br /></td></tr>
<tr class="separator:a3134d4dd585005d1dc8687dc619a9e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4948ad0241c67045b3c794874b2986a0"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a4948ad0241c67045b3c794874b2986a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4948ad0241c67045b3c794874b2986a0">DeclareEqualityConstraint</a> (void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *) const, int count, std::string description)</td></tr>
<tr class="memdesc:a4948ad0241c67045b3c794874b2986a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form f(context) = 0 by specifying a member function to use to calculate the (VectorX) constraint value with a signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a4948ad0241c67045b3c794874b2986a0">More...</a><br /></td></tr>
<tr class="separator:a4948ad0241c67045b3c794874b2986a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e764e61c17f1b7fbff611d8f69059b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0e764e61c17f1b7fbff611d8f69059b1">DeclareEqualityConstraint</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afb8f89bae1d60315dd16a46224febd21">ContextConstraintCalc</a>&lt; T &gt; calc, int count, std::string description)</td></tr>
<tr class="memdesc:a0e764e61c17f1b7fbff611d8f69059b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form f(context) = 0 by specifying a std::function to use to calculate the (Vector) constraint value with a signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0e764e61c17f1b7fbff611d8f69059b1">More...</a><br /></td></tr>
<tr class="separator:a0e764e61c17f1b7fbff611d8f69059b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bac306621c3f0839324649151c22af2"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a3bac306621c3f0839324649151c22af2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3bac306621c3f0839324649151c22af2">DeclareInequalityConstraint</a> (void(MySystem::*calc)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *) const, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_constraint_bounds.html">SystemConstraintBounds</a> bounds, std::string description)</td></tr>
<tr class="memdesc:a3bac306621c3f0839324649151c22af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds.upper() by specifying a member function to use to calculate the (VectorX) constraint value with a signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3bac306621c3f0839324649151c22af2">More...</a><br /></td></tr>
<tr class="separator:a3bac306621c3f0839324649151c22af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb77d986d0325c88d592609e35805428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#abb77d986d0325c88d592609e35805428">DeclareInequalityConstraint</a> (<a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afb8f89bae1d60315dd16a46224febd21">ContextConstraintCalc</a>&lt; T &gt; calc, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_constraint_bounds.html">SystemConstraintBounds</a> bounds, std::string description)</td></tr>
<tr class="memdesc:abb77d986d0325c88d592609e35805428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds.upper() by specifying a std::function to use to calculate the (Vector) constraint value with a signature:  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#abb77d986d0325c88d592609e35805428">More...</a><br /></td></tr>
<tr class="separator:abb77d986d0325c88d592609e35805428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06b0e87bccd80a2e69a8d84c655840a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac06b0e87bccd80a2e69a8d84c655840a">DoPublish</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; * &gt; &amp;events) const</td></tr>
<tr class="memdesc:ac06b0e87bccd80a2e69a8d84c655840a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived-class event dispatcher for all simultaneous publish events in <code>events</code>.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac06b0e87bccd80a2e69a8d84c655840a">More...</a><br /></td></tr>
<tr class="separator:ac06b0e87bccd80a2e69a8d84c655840a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3621fd468e9cfb692cec990a5a22c91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af3621fd468e9cfb692cec990a5a22c91">DoCalcDiscreteVariableUpdates</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; * &gt; &amp;events, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:af3621fd468e9cfb692cec990a5a22c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived-class event dispatcher for all simultaneous discrete update events.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af3621fd468e9cfb692cec990a5a22c91">More...</a><br /></td></tr>
<tr class="separator:af3621fd468e9cfb692cec990a5a22c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1632ac1a231d02181407dc5ad59041a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a1632ac1a231d02181407dc5ad59041a0">DoCalcUnrestrictedUpdate</a> (const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; * &gt; &amp;events, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a1632ac1a231d02181407dc5ad59041a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived-class event dispatcher for all simultaneous unrestricted update events.  <a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a1632ac1a231d02181407dc5ad59041a0">More...</a><br /></td></tr>
<tr class="separator:a1632ac1a231d02181407dc5ad59041a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html">System&lt; T &gt;</a></td></tr>
<tr class="memitem:a864d167dd193cc0e71b45db451beda38 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;typename U , template&lt; typename &gt; class S = ::maliput::drake::systems::System&gt; </td></tr>
<tr class="memitem:a864d167dd193cc0e71b45db451beda38 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a864d167dd193cc0e71b45db451beda38">ToScalarType</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a864d167dd193cc0e71b45db451beda38 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>from</code>, transmogrified to use the scalar type selected by a template parameter.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a864d167dd193cc0e71b45db451beda38">More...</a><br /></td></tr>
<tr class="separator:a864d167dd193cc0e71b45db451beda38 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad649083fc3bcb645671be3fad577d2ab">accuracy_ticket</a> ()</td></tr>
<tr class="memdesc:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the accuracy setting in the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad649083fc3bcb645671be3fad577d2ab">More...</a><br /></td></tr>
<tr class="separator:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6d7c526102c09a75195c57ebf5f54a11">all_input_ports_ticket</a> ()</td></tr>
<tr class="memdesc:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> input ports u of this system.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6d7c526102c09a75195c57ebf5f54a11">More...</a><br /></td></tr>
<tr class="separator:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad6b63a1cb8922051fb1a7fe4b56092bf">all_parameters_ticket</a> ()</td></tr>
<tr class="memdesc:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> parameters p in this system, including numeric parameters pn, and abstract parameters pa.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad6b63a1cb8922051fb1a7fe4b56092bf">More...</a><br /></td></tr>
<tr class="separator:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a> ()</td></tr>
<tr class="memdesc:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries).  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b9bc9f93181e042bdb2c36f4dbea10">More...</a><br /></td></tr>
<tr class="separator:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2789768c5d75378c081683a8016f0784">all_state_ticket</a> ()</td></tr>
<tr class="memdesc:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> state variables x in this system, including continuous variables xc, discrete (numeric) variables xd, and abstract state variables xa.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2789768c5d75378c081683a8016f0784">More...</a><br /></td></tr>
<tr class="separator:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a28830dced98dcdc1f498d8d250db0ae4">configuration_ticket</a> ()</td></tr>
<tr class="memdesc:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration-dependent computations.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a28830dced98dcdc1f498d8d250db0ae4">More...</a><br /></td></tr>
<tr class="separator:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a66e1d9af27119011a497b78df6907b1a">ke_ticket</a> ()</td></tr>
<tr class="memdesc:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the kinetic energy calculation.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a66e1d9af27119011a497b78df6907b1a">More...</a><br /></td></tr>
<tr class="separator:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1291b5091aa55dbd03c9b5944dbced09">kinematics_ticket</a> ()</td></tr>
<tr class="memdesc:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration- or velocity-dependent computations.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1291b5091aa55dbd03c9b5944dbced09">More...</a><br /></td></tr>
<tr class="separator:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6fe75ddbd79ab1d862df9a50b3c8a624">nothing_ticket</a> ()</td></tr>
<tr class="memdesc:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation does not depend on <em>any</em> source value; that is, it is a constant.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a6fe75ddbd79ab1d862df9a50b3c8a624">More...</a><br /></td></tr>
<tr class="separator:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af3c65473a41f73091c600eaead714fe2">pa_ticket</a> ()</td></tr>
<tr class="memdesc:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract parameters pa in the current <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#af3c65473a41f73091c600eaead714fe2">More...</a><br /></td></tr>
<tr class="separator:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#afdc60bc4c201f17bd35bf40c13a183b3">pc_ticket</a> ()</td></tr>
<tr class="memdesc:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the conservative power calculation.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#afdc60bc4c201f17bd35bf40c13a183b3">More...</a><br /></td></tr>
<tr class="separator:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a49f1689b1ae9f05b6e2f194db873927b">pe_ticket</a> ()</td></tr>
<tr class="memdesc:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the potential energy calculation.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a49f1689b1ae9f05b6e2f194db873927b">More...</a><br /></td></tr>
<tr class="separator:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#aaeae092662e78f50416eb6dc01ad3ddb">pn_ticket</a> ()</td></tr>
<tr class="memdesc:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical parameters in the current <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#aaeae092662e78f50416eb6dc01ad3ddb">More...</a><br /></td></tr>
<tr class="separator:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0afc9712c887706c12039e871476f30c">pnc_ticket</a> ()</td></tr>
<tr class="memdesc:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the non-conservative power calculation.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0afc9712c887706c12039e871476f30c">More...</a><br /></td></tr>
<tr class="separator:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a41d3cdadf7d6b62b055993148b82df19">q_ticket</a> ()</td></tr>
<tr class="memdesc:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation depends on configuration state variables q.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a41d3cdadf7d6b62b055993148b82df19">More...</a><br /></td></tr>
<tr class="separator:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a68516072b2dc51a601f2de699691f1c3">time_ticket</a> ()</td></tr>
<tr class="memdesc:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on time.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a68516072b2dc51a601f2de699691f1c3">More...</a><br /></td></tr>
<tr class="separator:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab858ddb6f259d65f760c2032b3bd5164">v_ticket</a> ()</td></tr>
<tr class="memdesc:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on velocity state variables v.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab858ddb6f259d65f760c2032b3bd5164">More...</a><br /></td></tr>
<tr class="separator:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a19842775d11b50e5ae56abcc6d38ccc4">xa_ticket</a> ()</td></tr>
<tr class="memdesc:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract state variables in the current <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a19842775d11b50e5ae56abcc6d38ccc4">More...</a><br /></td></tr>
<tr class="separator:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a385e0d5605b81db0fbfc6bdd57affb5e">xc_ticket</a> ()</td></tr>
<tr class="memdesc:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> of the continuous state variables q, v, or z.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a385e0d5605b81db0fbfc6bdd57affb5e">More...</a><br /></td></tr>
<tr class="separator:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab42cd3bff14253894eb0a29edf843b3f">xcdot_ticket</a> ()</td></tr>
<tr class="memdesc:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds time derivatives of the continuous variables.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab42cd3bff14253894eb0a29edf843b3f">More...</a><br /></td></tr>
<tr class="separator:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a64938d044107c8eedc97f89aaf0e4a32">xd_ticket</a> ()</td></tr>
<tr class="memdesc:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical discrete state variables, in any discrete variable group.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a64938d044107c8eedc97f89aaf0e4a32">More...</a><br /></td></tr>
<tr class="separator:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a340a9b088fc407f703a9e21ed9dee32e">z_ticket</a> ()</td></tr>
<tr class="memdesc:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on any or all of the miscellaneous continuous state variables z.  <a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a340a9b088fc407f703a9e21ed9dee32e">More...</a><br /></td></tr>
<tr class="separator:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classmaliput_1_1drake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5341fd0b682386ac7623a65a898b48a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5341fd0b682386ac7623a65a898b48a0">&#9670;&nbsp;</a></span>~LeafSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html">LeafSystem</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01c2b703c560ad090b9601b743356c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c2b703c560ad090b9601b743356c90">&#9670;&nbsp;</a></span>LeafSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html">LeafSystem</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that declares no inputs, outputs, state, parameters, events, nor scalar-type conversion support (AutoDiff, etc.). </p>
<p>To enable AutoDiff support, use the SystemScalarConverter-based constructor. </p>

</div>
</div>
<a id="a8d7077d1af5bd9153ae403fe32969eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7077d1af5bd9153ae403fe32969eba">&#9670;&nbsp;</a></span>LeafSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html">LeafSystem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a>&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that declares no inputs, outputs, state, parameters, or events, but allows subclasses to declare scalar-type conversion support (AutoDiff, etc.). </p>
<p>The scalar-type conversion support will use <code>converter</code>. To enable scalar-type conversion support, pass a <code><a class="el" href="structmaliput_1_1drake_1_1systems_1_1_system_type_tag.html" title="A tag object that denotes a System subclass S in function signatures.">SystemTypeTag</a>&lt;S&gt;{}</code> where <code>S</code> must be the exact class of <code>this</code> being constructed.</p>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3167bd30bfa014aa61d55fb50ed36f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3167bd30bfa014aa61d55fb50ed36f9">&#9670;&nbsp;</a></span>AddTriggeredWitnessFunctionToCompositeEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddTriggeredWitnessFunctionToCompositeEventCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>event</code> to <code>events</code> due to a witness function triggering. </p>
<p><code>events</code> should be allocated with this system's AllocateCompositeEventCollection. Neither <code>event</code> nor <code>events</code> can be nullptr. Additionally, <code>event</code> must contain event data (event-&gt;get_event_data() must not be nullptr) and the type of that data must be <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_triggered_event_data.html" title="Class for storing data from a witness function triggering to be passed to event handlers.">WitnessTriggeredEventData</a>. </p>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a838b32b3b596aae6c11fa9c19e655407">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="af0b9bc9f93181e042bdb2c36f4dbea10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b9bc9f93181e042bdb2c36f4dbea10">&#9670;&nbsp;</a></span>all_sources_ticket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> all_sources_ticket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries). </p>
<p>This is the default dependency for computations that have not specified anything more refined. It is equivalent to the set <code>{all_sources_except_input_ports_ticket(), all_input_ports_ticket()}</code>. </p><dl class="section see"><dt>See also</dt><dd>cache_entry_ticket() to obtain a ticket for a cache entry. </dd></dl>

</div>
</div>
<a id="ad7e7d622e6bb31031ed0c9d7662333cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e7d622e6bb31031ed0c9d7662333cd">&#9670;&nbsp;</a></span>AllocateAbstractState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_abstract_values.html">AbstractValues</a> &gt; AllocateAbstractState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the states declared in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a471cc890e1d5fb20b9b257853d88cac4" title="Declares an abstract state.">DeclareAbstractState()</a> calls. </p>

</div>
</div>
<a id="af0339d1a60201dd7e42d5e8a80285152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0339d1a60201dd7e42d5e8a80285152">&#9670;&nbsp;</a></span>AllocateContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &gt; AllocateContext</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadows <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a78fda6d982dc968061c5d92e32173629" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;.">System&lt;T&gt;::AllocateContext</a> to provide a more concrete return type LeafContext&lt;T&gt;. </p>

</div>
</div>
<a id="ac964670fe031a2b4ea84dda682b953cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac964670fe031a2b4ea84dda682b953cd">&#9670;&nbsp;</a></span>AllocateContinuousState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt; AllocateContinuousState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the state declared in the most recent <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a52a8bc29fc2fdead9b757e06c5c8a5c0" title="Declares that this System should reserve continuous state with num_state_variables state variables,...">DeclareContinuousState()</a> call, or else a zero-sized state if that method has never been called. </p>

</div>
</div>
<a id="a74c5bee14a5df344e745f70b84388cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c5bee14a5df344e745f70b84388cbe">&#9670;&nbsp;</a></span>AllocateDiscreteState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt; AllocateDiscreteState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the states declared in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2" title="Declares a discrete state group with model_vector.size() state variables, stored in a vector cloned f...">DeclareDiscreteState()</a> calls. </p>

</div>
</div>
<a id="a75a46315bf6c86eefd7e4cf0f600c7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a46315bf6c86eefd7e4cf0f600c7ae">&#9670;&nbsp;</a></span>AllocateDiscreteVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt; AllocateDiscreteVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html" title="DiscreteValues is a container for numerical but non-continuous state and parameters.">DiscreteValues</a> of the same dimensions as the discrete_state allocated in CreateDefaultContext. </p>
<p>The simulator will provide this state as the output argument to Update. </p>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a975677491aa00a7677181b12311d7c10">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a09cd71b380ce6914a46085c83dc31b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cd71b380ce6914a46085c83dc31b77">&#9670;&nbsp;</a></span>AllocateForcedDiscreteUpdateEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &gt; AllocateForcedDiscreteUpdateEventCollection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54ed4a335c7077d3914f98f87f28c117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ed4a335c7077d3914f98f87f28c117">&#9670;&nbsp;</a></span>AllocateForcedPublishEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &gt; AllocateForcedPublishEventCollection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a314a748049fdd21c0ea7b99713eea4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314a748049fdd21c0ea7b99713eea4df">&#9670;&nbsp;</a></span>AllocateForcedUnrestrictedUpdateEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &gt; AllocateForcedUnrestrictedUpdateEventCollection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4183810e51d405f7b9ad94a1e9c4a7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4183810e51d405f7b9ad94a1e9c4a7ae">&#9670;&nbsp;</a></span>AllocateParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; &gt; AllocateParameters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the parameters declared in <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a6516c166d4aedeab3ae31544bbaecbba" title="Declares a numeric parameter using the given model_vector.">DeclareNumericParameter()</a> and <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7f954e701d1bfba3f8aad91dd4d89ca" title="Declares an abstract parameter using the given model_value.">DeclareAbstractParameter()</a> calls. </p>

</div>
</div>
<a id="ad305239ecbafb0545520bb5b2898312d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad305239ecbafb0545520bb5b2898312d">&#9670;&nbsp;</a></span>AllocateTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt; AllocateTimeDerivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> of the same size as the continuous_state allocated in CreateDefaultContext. </p>
<p>The simulator will provide this state as the output argument to EvalTimeDerivatives. </p>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ab543fa724bbe93efd19a42f5e9e65c72">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aaa2ad089c407e501a3ec99106ef06d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2ad089c407e501a3ec99106ef06d0a">&#9670;&nbsp;</a></span>DeclareAbstractInputPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; DeclareAbstractInputPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>model_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a565c340c958e56d0d1967034fc42c906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565c340c958e56d0d1967034fc42c906">&#9670;&nbsp;</a></span>DeclareAbstractInputPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; DeclareAbstractInputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>model_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an abstract-valued input port using the given <code>model_value</code>. </p>
<p>This is the best way to declare <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> abstract input ports.</p>
<p>Any port connected to this input, and any call to FixValue for this input, must provide for values whose type matches this <code>model_value</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b57e4cacf2beba4ef87c87f824aba8" title="Adds a port with the specified type and size to the input topology.">System::DeclareInputPort()</a> for more information. </dd></dl>

</div>
</div>
<a id="a0331978ee2acc1638874464addf8269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0331978ee2acc1638874464addf8269b">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same_v&lt;OutputType, std::string&gt;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp;&gt; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">const OutputType &amp;&#160;</td>
          <td class="paramname"><em>model_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae93557fbbbe84af162a8e15941a8d68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93557fbbbe84af162a8e15941a8d68a">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">OutputType(MySystem::*)() const&#160;</td>
          <td class="paramname"><em>make</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af669e17632efa35e1dd28f5af9a96b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af669e17632efa35e1dd28f5af9a96b9b">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OutputType &amp;&#160;</td>
          <td class="paramname"><em>model_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an abstract-valued output port by specifying a model value of concrete type <code>OutputType</code> and a calculator function that is a class member function (method) with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcOutputValue(<span class="keyword">const</span> Context&lt;T&gt;&amp;, OutputType*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> must be a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code>. <code>OutputType</code> must be such that <code><a class="el" href="classmaliput_1_1drake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;OutputType&gt;</code> is permitted. Template arguments will be deduced and do not need to be specified. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">maliput::drake::Value</a> </dd></dl>

</div>
</div>
<a id="aa2f77588778c7353bbbcb0e1359a42ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f77588778c7353bbbcb0e1359a42ac">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::AllocCallback&#160;</td>
          <td class="paramname"><em>alloc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcCallback&#160;</td>
          <td class="paramname"><em>calc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Declares an abstract-valued output port using the given allocator and calculator functions provided in their most generic forms. </p>
<p>If you have a member function available use one of the other signatures. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html#aec5ccbce07472be60249987b19f02ee3" title="Signature of a function suitable for allocating an object that can hold a value of a particular outpu...">LeafOutputPort::AllocCallback</a>, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html#a1d5f163d1b760a1c54a9880762d26ece" title="Signature of a function suitable for calculating a value of a particular output port,...">LeafOutputPort::CalcCallback</a> </dd></dl>

</div>
</div>
<a id="aea52af0c8afa64504398a2c447f28fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea52af0c8afa64504398a2c447f28fa0">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an abstract-valued output port by specifying only a calculator function that is a class member function (method) with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcOutputValue(<span class="keyword">const</span> Context&lt;T&gt;&amp;, OutputType*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code>. <code>OutputType</code> is a concrete type such that <code><a class="el" href="classmaliput_1_1drake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;OutputType&gt;</code> is permitted, and must be default constructible, so that we can create a model value using <code><a class="el" href="classmaliput_1_1drake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;OutputType&gt;{}</code> (value initialized so numerical types will be zeroed in the model). Template arguments will be deduced and do not need to be specified.</p>
<dl class="section note"><dt>Note</dt><dd>The default constructor will be called once immediately, and subsequent allocations will just copy the model value without invoking the constructor again. If you want the constructor invoked again at each allocation (not common), use one of the other signatures to explicitly provide a method for the allocator to call; that method can then invoke the <code>OutputType</code> default constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">maliput::drake::Value</a> </dd></dl>

</div>
</div>
<a id="acb2c9ed5dd1428fac9cb34dbdc4b0fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2c9ed5dd1428fac9cb34dbdc4b0fe0">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::AllocCallback&#160;</td>
          <td class="paramname"><em>alloc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcCallback&#160;</td>
          <td class="paramname"><em>calc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5399d5518ba8953095e797b9ec9e3aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5399d5518ba8953095e797b9ec9e3aa8">&#9670;&nbsp;</a></span>DeclareAbstractOutputPort() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareAbstractOutputPort </td>
          <td>(</td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7f954e701d1bfba3f8aad91dd4d89ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f954e701d1bfba3f8aad91dd4d89ca">&#9670;&nbsp;</a></span>DeclareAbstractParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DeclareAbstractParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>model_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an abstract parameter using the given <code>model_value</code>. </p>
<p><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>'s default implementation of <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b" title="Default implementation: sets all numeric parameters to the model vector given to DeclareNumericParame...">SetDefaultParameters()</a> will reset parameters to their model values. Returns the index of the new parameter. </p>

</div>
</div>
<a id="a471cc890e1d5fb20b9b257853d88cac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471cc890e1d5fb20b9b257853d88cac4">&#9670;&nbsp;</a></span>DeclareAbstractState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> DeclareAbstractState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>abstract_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an abstract state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abstract_state</td><td>The abstract state model value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the declared abstract state. </dd></dl>

</div>
</div>
<a id="ab992aa647fda36ce82828bd49381299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab992aa647fda36ce82828bd49381299e">&#9670;&nbsp;</a></span>DeclareContinuousState() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a> DeclareContinuousState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>model_vector.size()</code> miscellaneous state variables, stored in a vector cloned from <code>model_vector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>index of the declared state (currently always zero). </dd></dl>

</div>
</div>
<a id="a02c6110544a3a4fd4a9085c2db10972c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c6110544a3a4fd4a9085c2db10972c">&#9670;&nbsp;</a></span>DeclareContinuousState() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a> DeclareContinuousState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>num_q</code> generalized positions, <code>num_v</code> generalized velocities, and <code>num_z</code> miscellaneous state variables, stored in a vector cloned from <code>model_vector</code>. </p>
<p>Aborts if <code>model_vector</code> has the wrong size. If the <code>model_vector</code> declares any <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html#afcd23700f1c0e51cb736750eb3fafa51" title="Get the bounds for the elements.">VectorBase::GetElementBounds()</a> constraints, they will be re-declared as inequality constraints on this system (see <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3bac306621c3f0839324649151c22af2" title="Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds....">DeclareInequalityConstraint()</a>). </p><dl class="section return"><dt>Returns</dt><dd>index of the declared state (currently always zero). </dd></dl>

</div>
</div>
<a id="a59ad7afd2779aef7414c26220440403e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ad7afd2779aef7414c26220440403e">&#9670;&nbsp;</a></span>DeclareContinuousState() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a> DeclareContinuousState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>num_q</code> generalized positions, <code>num_v</code> generalized velocities, and <code>num_z</code> miscellaneous state variables. </p>
<dl class="section return"><dt>Returns</dt><dd>index of the declared state (currently always zero). </dd></dl>

</div>
</div>
<a id="a52a8bc29fc2fdead9b757e06c5c8a5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a8bc29fc2fdead9b757e06c5c8a5c0">&#9670;&nbsp;</a></span>DeclareContinuousState() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a> DeclareContinuousState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_state_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> should reserve continuous state with <code>num_state_variables</code> state variables, which have no second-order structure. </p>
<dl class="section return"><dt>Returns</dt><dd>index of the declared state (currently always zero). </dd></dl>

</div>
</div>
<a id="a47ef984b4d9b8313d1239b76388882d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ef984b4d9b8313d1239b76388882d2">&#9670;&nbsp;</a></span>DeclareDiscreteState() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> DeclareDiscreteState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a discrete state group with <code>model_vector.size()</code> state variables, stored in a vector cloned from <code>model_vector</code> (preserving the concrete type and value). </p>

</div>
</div>
<a id="afcdee5c47f728c1c50b84fc54c26374e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdee5c47f728c1c50b84fc54c26374e">&#9670;&nbsp;</a></span>DeclareDiscreteState() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> DeclareDiscreteState </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a discrete state group with <code>vector.size()</code> state variables, stored in a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> initialized with the contents of <code>vector</code>. </p>

</div>
</div>
<a id="ad02cadb14746ff469fa338d2351a5e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02cadb14746ff469fa338d2351a5e68">&#9670;&nbsp;</a></span>DeclareDiscreteState() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> DeclareDiscreteState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_state_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a discrete state group with <code>num_state_variables</code> state variables, stored in a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> initialized to be all-zero. </p>
<p>If you want non-zero initial values, use an alternate <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2" title="Declares a discrete state group with model_vector.size() state variables, stored in a vector cloned f...">DeclareDiscreteState()</a> signature that accepts a <code>model_vector</code> parameter. </p><dl class="section pre"><dt>Precondition</dt><dd><code>num_state_variables</code> must be non-negative. </dd></dl>

</div>
</div>
<a id="a0e764e61c17f1b7fbff611d8f69059b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e764e61c17f1b7fbff611d8f69059b1">&#9670;&nbsp;</a></span>DeclareEqualityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> DeclareEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afb8f89bae1d60315dd16a46224febd21">ContextConstraintCalc</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a system constraint of the form f(context) = 0 by specifying a std::function to use to calculate the (Vector) constraint value with a signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CalcConstraint(<span class="keyword">const</span> Context&lt;T&gt;&amp;, VectorX&lt;T&gt;*);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>is the dimension of the VectorX output. </td></tr>
    <tr><td class="paramname">description</td><td>should be a human-readable phrase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the constraint.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SystemConstraint&lt;T&gt; for more information about the meaning of these constraints. </dd></dl>

</div>
</div>
<a id="a4948ad0241c67045b3c794874b2986a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4948ad0241c67045b3c794874b2986a0">&#9670;&nbsp;</a></span>DeclareEqualityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> DeclareEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a system constraint of the form f(context) = 0 by specifying a member function to use to calculate the (VectorX) constraint value with a signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcConstraint(<span class="keyword">const</span> Context&lt;T&gt;&amp;, VectorX&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>is the dimension of the VectorX output. </td></tr>
    <tr><td class="paramname">description</td><td>should be a human-readable phrase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the constraint. Template arguments will be deduced and do not need to be specified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SystemConstraint&lt;T&gt; for more information about the meaning of these constraints. </dd></dl>

</div>
</div>
<a id="ad3b5bee56aa04d7853ba456b85775f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b5bee56aa04d7853ba456b85775f7e">&#9670;&nbsp;</a></span>DeclareForcedDiscreteUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareForcedDiscreteUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a function that is called whenever a user directly calls CalcDiscreteVariableUpdates(const Context&amp;, DiscreteValues&lt;T&gt;*). </p>
<p>Multiple calls to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad3b5bee56aa04d7853ba456b85775f7e" title="Declares a function that is called whenever a user directly calls CalcDiscreteVariableUpdates(const C...">DeclareForcedDiscreteUpdateEvent()</a> will cause multiple handlers to be called upon a call to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdates()</a>; these handlers which will be called with the same const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> in arbitrary order. The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyDiscreteVariableUpdates(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">DiscreteValues&lt;T&gt;*);</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_forced_events">Declare forced events</a> for more information. </p><dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null. </dd></dl>

</div>
</div>
<a id="a79bf931890fb3c7e9e4fd0f2696ca994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bf931890fb3c7e9e4fd0f2696ca994">&#9670;&nbsp;</a></span>DeclareForcedPublishEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareForcedPublishEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>publish</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a function that is called whenever a user directly calls Publish(const Context&amp;). </p>
<p>Multiple calls to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a79bf931890fb3c7e9e4fd0f2696ca994" title="Declares a function that is called whenever a user directly calls Publish(const Context&amp;).">DeclareForcedPublishEvent()</a> will cause multiple handlers to be called upon a call to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01" title="This method is the public entry point for dispatching all publish event handlers.">Publish()</a>; these handlers which will be called with the same const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> in arbitrary order. The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyPublish(<span class="keyword">const</span> Context&lt;T&gt;&amp;) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_forced_events">Declare forced events</a> for more information. </p><dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>publish</code> must not be null. </dd></dl>

</div>
</div>
<a id="a7d68430eb8f9451787a183c48fca2c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d68430eb8f9451787a183c48fca2c81">&#9670;&nbsp;</a></span>DeclareForcedUnrestrictedUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareForcedUnrestrictedUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a function that is called whenever a user directly calls CalcUnrestrictedUpdate(const Context&amp;, State&lt;T&gt;*). </p>
<p>Multiple calls to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7d68430eb8f9451787a183c48fca2c81" title="Declares a function that is called whenever a user directly calls CalcUnrestrictedUpdate(const Contex...">DeclareForcedUnrestrictedUpdateEvent()</a> will cause multiple handlers to be called upon a call to <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a>; these handlers which will be called with the same const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> in arbitrary order.The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUnrestrictedUpdates(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">State&lt;T&gt;*);</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_forced_events">Declare forced events</a> for more information. </p><dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null. </dd></dl>

</div>
</div>
<a id="af35335637b5cf1c763d5e9112864fe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35335637b5cf1c763d5e9112864fe09">&#9670;&nbsp;</a></span>DeclareImplicitTimeDerivativesResidualSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareImplicitTimeDerivativesResidualSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Overrides the default size for the implicit time derivatives residual. </p>
<p>If no value is set, the default size is n=num_continuous_states().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size of the residual vector output argument of <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2bb4c1e3572a8009863b5a342fcb5c49" title="Evaluates the implicit form of the System equations and returns the residual.">System::CalcImplicitTimeDerivativesResidual()</a>. If n &lt;= 0 restore to the default, num_continuous_states().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>implicit_time_derivatives_residual_size() </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2bb4c1e3572a8009863b5a342fcb5c49" title="Evaluates the implicit form of the System equations and returns the residual.">System::CalcImplicitTimeDerivativesResidual()</a> </dd></dl>

</div>
</div>
<a id="abb77d986d0325c88d592609e35805428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb77d986d0325c88d592609e35805428">&#9670;&nbsp;</a></span>DeclareInequalityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> DeclareInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afb8f89bae1d60315dd16a46224febd21">ContextConstraintCalc</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_constraint_bounds.html">SystemConstraintBounds</a>&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds.upper() by specifying a std::function to use to calculate the (Vector) constraint value with a signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CalcConstraint(<span class="keyword">const</span> Context&lt;T&gt;&amp;, VectorX&lt;T&gt;*);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>should be a human-readable phrase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the constraint.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SystemConstraint&lt;T&gt; for more information about the meaning of these constraints. </dd></dl>

</div>
</div>
<a id="a3bac306621c3f0839324649151c22af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bac306621c3f0839324649151c22af2">&#9670;&nbsp;</a></span>DeclareInequalityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> DeclareInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system_constraint_bounds.html">SystemConstraintBounds</a>&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds.upper() by specifying a member function to use to calculate the (VectorX) constraint value with a signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcConstraint(<span class="keyword">const</span> Context&lt;T&gt;&amp;, VectorX&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>should be a human-readable phrase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the constraint. Template arguments will be deduced and do not need to be specified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SystemConstraint&lt;T&gt; for more information about the meaning of these constraints. </dd></dl>

</div>
</div>
<a id="ab4e7028e25a5d6e402a156a0115019a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7028e25a5d6e402a156a0115019a4">&#9670;&nbsp;</a></span>DeclareInitializationDiscreteUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareInitializationDiscreteUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that a DiscreteUpdate event should occur at initialization and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                               DiscreteValues&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_initialization_events">Declare initialization events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aab3136bba7eb6480a84309d019b28d83" title="Declares that a Publish event should occur at initialization and that it should invoke the given even...">DeclareInitializationPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae04f150e6036b0cbbf9808cc0f71a9a6" title="Declares that an UnrestrictedUpdate event should occur at initialization and that it should invoke th...">DeclareInitializationUnrestrictedUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563" title="(Advanced) Declares that a particular Event object should be dispatched at initialization.">DeclareInitializationEvent()</a> </dd></dl>

</div>
</div>
<a id="a048bf857e2856f50fc08211a18348563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048bf857e2856f50fc08211a18348563">&#9670;&nbsp;</a></span>DeclareInitializationEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareInitializationEvent </td>
          <td>(</td>
          <td class="paramtype">const EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Declares that a particular <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object should be dispatched at initialization. </p>
<p>This is the most general form for declaring initialization events and most users should use one of the other methods in this group instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aab3136bba7eb6480a84309d019b28d83" title="Declares that a Publish event should occur at initialization and that it should invoke the given even...">DeclareInitializationPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab4e7028e25a5d6e402a156a0115019a4" title="Declares that a DiscreteUpdate event should occur at initialization and that it should invoke the giv...">DeclareInitializationDiscreteUpdateEvent()</a> </dd>
<dd>
DeclareInitializationUnrestrictedUpdate()</dd></dl>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_initialization_events">Declare initialization events</a> for more information.</p>
<p>Depending on the type of <code>event</code>, on initialization it will be passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher. If the <code>event</code> object contains a handler function, Drake's default dispatchers will invoke that handler. If not, then no further action is taken. Thus an <code>event</code> with no handler has no effect unless its dispatcher has been overridden. We strongly recommend that you <em>do not</em> override the dispatcher and instead <em>do</em> supply a handler.</p>
<p>The given <code>event</code> object is deep-copied (cloned), and the copy is stored internally so you do not need to keep the object around after this call.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>event</code>'s associated trigger type must be <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a59b7f49353f2a99b6c22d2eaae0fe9e9a25c2dc47991b3df171ed5192bcf70390">TriggerType::kUnknown</a> or already set to <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a59b7f49353f2a99b6c22d2eaae0fe9e9a1800fd44ac807b793ceba2dd9cef1e25" title="This trigger indicates that an associated event is triggered at system initialization.">TriggerType::kInitialization</a>. </dd></dl>

</div>
</div>
<a id="aab3136bba7eb6480a84309d019b28d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3136bba7eb6480a84309d019b28d83">&#9670;&nbsp;</a></span>DeclareInitializationPublishEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareInitializationPublishEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>publish</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that a Publish event should occur at initialization and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyPublish(<span class="keyword">const</span> Context&lt;T&gt;&amp;) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_initialization_events">Declare initialization events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>publish</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab4e7028e25a5d6e402a156a0115019a4" title="Declares that a DiscreteUpdate event should occur at initialization and that it should invoke the giv...">DeclareInitializationDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ae04f150e6036b0cbbf9808cc0f71a9a6" title="Declares that an UnrestrictedUpdate event should occur at initialization and that it should invoke th...">DeclareInitializationUnrestrictedUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563" title="(Advanced) Declares that a particular Event object should be dispatched at initialization.">DeclareInitializationEvent()</a> </dd></dl>

</div>
</div>
<a id="ae04f150e6036b0cbbf9808cc0f71a9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04f150e6036b0cbbf9808cc0f71a9a6">&#9670;&nbsp;</a></span>DeclareInitializationUnrestrictedUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclareInitializationUnrestrictedUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that an UnrestrictedUpdate event should occur at initialization and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                               State&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_initialization_events">Declare initialization events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aab3136bba7eb6480a84309d019b28d83" title="Declares that a Publish event should occur at initialization and that it should invoke the given even...">DeclareInitializationPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ab4e7028e25a5d6e402a156a0115019a4" title="Declares that a DiscreteUpdate event should occur at initialization and that it should invoke the giv...">DeclareInitializationDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563" title="(Advanced) Declares that a particular Event object should be dispatched at initialization.">DeclareInitializationEvent()</a> </dd></dl>

</div>
</div>
<a id="a6516c166d4aedeab3ae31544bbaecbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6516c166d4aedeab3ae31544bbaecbba">&#9670;&nbsp;</a></span>DeclareNumericParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DeclareNumericParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a numeric parameter using the given <code>model_vector</code>. </p>
<p><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>'s default implementation of <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b" title="Default implementation: sets all numeric parameters to the model vector given to DeclareNumericParame...">SetDefaultParameters()</a> will reset parameters to their model vectors. If the <code>model_vector</code> declares any <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html#afcd23700f1c0e51cb736750eb3fafa51" title="Get the bounds for the elements.">VectorBase::GetElementBounds()</a> constraints, they will be re-declared as inequality constraints on this system (see <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3bac306621c3f0839324649151c22af2" title="Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds....">DeclareInequalityConstraint()</a>). Returns the index of the new parameter. </p>

</div>
</div>
<a id="a262f71637a37127840acefca3bda8897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262f71637a37127840acefca3bda8897">&#9670;&nbsp;</a></span>DeclarePeriodicDiscreteUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicDiscreteUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(To be deprecated) Declares a periodic discrete update event that invokes the DiscreteUpdate() dispatcher but does not provide a handler function. </p>
<p>This does guarantee that a Simulator step will end exactly at the update time, but otherwise has no effect unless the DoDiscreteUpdate() dispatcher has been overloaded (not recommended). </p>

</div>
</div>
<a id="a30e4b4a7f8de8106e56bc49e36c07dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e4b4a7f8de8106e56bc49e36c07dec">&#9670;&nbsp;</a></span>DeclarePeriodicDiscreteUpdateEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicDiscreteUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that a DiscreteUpdate event should occur periodically and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                               DiscreteValues&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_periodic_events">Declare periodic events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7786537a2832acd0d4f0d80827c1291" title="Declares that a Publish event should occur periodically and that it should invoke the given event han...">DeclarePeriodicPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7fb4770f2d9a82d9012da69ed102ffe5" title="Declares that an UnrestrictedUpdate event should occur periodically and that it should invoke the giv...">DeclarePeriodicUnrestrictedUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1" title="(Advanced) Declares that a particular Event object should be dispatched periodically.">DeclarePeriodicEvent()</a> </dd></dl>

</div>
</div>
<a id="a5678e6682500a1f0bb71bbd1fd454324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5678e6682500a1f0bb71bbd1fd454324">&#9670;&nbsp;</a></span>DeclarePeriodicDiscreteUpdateEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicDiscreteUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This variant accepts a handler that is assumed to succeed rather than one that returns an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> result. </p>
<p>The handler signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                        DiscreteValues&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> See the other signature for more information. </p>

</div>
</div>
<a id="a50e5397a57ec949d737f0a7aafd361c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e5397a57ec949d737f0a7aafd361c1">&#9670;&nbsp;</a></span>DeclarePeriodicEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Declares that a particular <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object should be dispatched periodically. </p>
<p>This is the most general form for declaring periodic events and most users should use one of the other methods in this group instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7786537a2832acd0d4f0d80827c1291" title="Declares that a Publish event should occur periodically and that it should invoke the given event han...">DeclarePeriodicPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a30e4b4a7f8de8106e56bc49e36c07dec" title="Declares that a DiscreteUpdate event should occur periodically and that it should invoke the given ev...">DeclarePeriodicDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7fb4770f2d9a82d9012da69ed102ffe5" title="Declares that an UnrestrictedUpdate event should occur periodically and that it should invoke the giv...">DeclarePeriodicUnrestrictedUpdateEvent()</a></dd></dl>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_periodic_events">Declare periodic events</a> for more information.</p>
<p>Depending on the type of <code>event</code>, when triggered it will be passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher. If the <code>event</code> object contains a handler function, Drake's default dispatchers will invoke that handler. If not, then no further action is taken. Thus an <code>event</code> with no handler has no effect unless its dispatcher has been overridden. We strongly recommend that you <em>do not</em> override the dispatcher and instead <em>do</em> supply a handler.</p>
<p>The given <code>event</code> object is deep-copied (cloned), and the copy is stored internally so you do not need to keep the object around after this call.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>event</code>'s associated trigger type must be <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a59b7f49353f2a99b6c22d2eaae0fe9e9a25c2dc47991b3df171ed5192bcf70390">TriggerType::kUnknown</a> or already set to <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a59b7f49353f2a99b6c22d2eaae0fe9e9aa4dadcf41a1fb6841557aad7688dc1a4" title="This type indicates that an associated event is triggered by the system proceeding to a time t ∈ {tᵢ ...">TriggerType::kPeriodic</a>. </dd></dl>

</div>
</div>
<a id="a1adf7020dee795fd1b34b023c447eb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf7020dee795fd1b34b023c447eb6f">&#9670;&nbsp;</a></span>DeclarePeriodicPublish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicPublish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(To be deprecated) Declares a periodic publish event that invokes the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01" title="This method is the public entry point for dispatching all publish event handlers.">Publish()</a> dispatcher but does not provide a handler function. </p>
<p>This does guarantee that a Simulator step will end exactly at the publish time, but otherwise has no effect unless the <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ac06b0e87bccd80a2e69a8d84c655840a" title="Derived-class event dispatcher for all simultaneous publish events in events.">DoPublish()</a> dispatcher has been overloaded (not recommended). </p>

</div>
</div>
<a id="ad7786537a2832acd0d4f0d80827c1291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7786537a2832acd0d4f0d80827c1291">&#9670;&nbsp;</a></span>DeclarePeriodicPublishEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicPublishEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>publish</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that a Publish event should occur periodically and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyPublish(<span class="keyword">const</span> Context&lt;T&gt;&amp;) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_periodic_events">Declare periodic events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>publish</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a30e4b4a7f8de8106e56bc49e36c07dec" title="Declares that a DiscreteUpdate event should occur periodically and that it should invoke the given ev...">DeclarePeriodicDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a7fb4770f2d9a82d9012da69ed102ffe5" title="Declares that an UnrestrictedUpdate event should occur periodically and that it should invoke the giv...">DeclarePeriodicUnrestrictedUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1" title="(Advanced) Declares that a particular Event object should be dispatched periodically.">DeclarePeriodicEvent()</a> </dd></dl>

</div>
</div>
<a id="acdd8c9a5a1c5b17e10fdef61456ce228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd8c9a5a1c5b17e10fdef61456ce228">&#9670;&nbsp;</a></span>DeclarePeriodicPublishEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicPublishEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>publish</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This variant accepts a handler that is assumed to succeed rather than one that returns an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> result. </p>
<p>The handler signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::MyPublish(<span class="keyword">const</span> Context&lt;T&gt;&amp;) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> See the other signature for more information. </p>

</div>
</div>
<a id="a17d2dbe47bcb217706226101ed7218bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d2dbe47bcb217706226101ed7218bc">&#9670;&nbsp;</a></span>DeclarePeriodicUnrestrictedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(To be deprecated) Declares a periodic unrestricted update event that invokes the UnrestrictedUpdate() dispatcher but does not provide a handler function. </p>
<p>This does guarantee that a Simulator step will end exactly at the update time, but otherwise has no effect unless the DoUnrestrictedUpdate() dispatcher has been overloaded (not recommended). </p>

</div>
</div>
<a id="a7fb4770f2d9a82d9012da69ed102ffe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb4770f2d9a82d9012da69ed102ffe5">&#9670;&nbsp;</a></span>DeclarePeriodicUnrestrictedUpdateEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicUnrestrictedUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that an UnrestrictedUpdate event should occur periodically and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;, State&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_periodic_events">Declare periodic events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#ad7786537a2832acd0d4f0d80827c1291" title="Declares that a Publish event should occur periodically and that it should invoke the given event han...">DeclarePeriodicPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a30e4b4a7f8de8106e56bc49e36c07dec" title="Declares that a DiscreteUpdate event should occur periodically and that it should invoke the given ev...">DeclarePeriodicDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1" title="(Advanced) Declares that a particular Event object should be dispatched periodically.">DeclarePeriodicEvent()</a> </dd></dl>

</div>
</div>
<a id="a269f10abf498f5b956d9d916f217b0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269f10abf498f5b956d9d916f217b0f3">&#9670;&nbsp;</a></span>DeclarePeriodicUnrestrictedUpdateEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePeriodicUnrestrictedUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>offset_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This variant accepts a handler that is assumed to succeed rather than one that returns an <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> result. </p>
<p>The handler signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;, State&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> See the other signature for more information. </p>

</div>
</div>
<a id="a045f31a25ecb0c57baede1abd70182a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045f31a25ecb0c57baede1abd70182a8">&#9670;&nbsp;</a></span>DeclarePerStepDiscreteUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePerStepDiscreteUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that a DiscreteUpdate event should occur at the start of every trajectory-advancing step and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                               DiscreteValues&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_per-step_events">Declare per-step events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a49a07c6bbccc4464d5d6192889c3d2e6" title="Declares that a Publish event should occur at initialization and at the end of every trajectory-advan...">DeclarePerStepPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0d51151d69bb455091dc4c2f4c42729a" title="Declares that an UnrestrictedUpdate event should occur at the start of every trajectory-advancing ste...">DeclarePerStepUnrestrictedUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700" title="(Advanced) Declares that a particular Event object should be dispatched at every trajectory-advancing...">DeclarePerStepEvent()</a> </dd></dl>

</div>
</div>
<a id="a901aafa8a436a6988c5cd35527392700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901aafa8a436a6988c5cd35527392700">&#9670;&nbsp;</a></span>DeclarePerStepEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePerStepEvent </td>
          <td>(</td>
          <td class="paramtype">const EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Declares that a particular <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object should be dispatched at every trajectory-advancing step. </p>
<p>Publish events are dispatched at the end of initialization and at the end of each step. Discrete- and unrestricted update events are dispatched at the start of each step. This is the most general form for declaring per-step events and most users should use one of the other methods in this group instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a49a07c6bbccc4464d5d6192889c3d2e6" title="Declares that a Publish event should occur at initialization and at the end of every trajectory-advan...">DeclarePerStepPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a045f31a25ecb0c57baede1abd70182a8" title="Declares that a DiscreteUpdate event should occur at the start of every trajectory-advancing step and...">DeclarePerStepDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0d51151d69bb455091dc4c2f4c42729a" title="Declares that an UnrestrictedUpdate event should occur at the start of every trajectory-advancing ste...">DeclarePerStepUnrestrictedUpdateEvent()</a></dd></dl>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_per-step_events">Declare per-step events</a> for more information.</p>
<p>Depending on the type of <code>event</code>, at each step it will be passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher. If the <code>event</code> object contains a handler function, Drake's default dispatchers will invoke that handler. If not, then no further action is taken. Thus an <code>event</code> with no handler has no effect unless its dispatcher has been overridden. We strongly recommend that you <em>do not</em> override the dispatcher and instead <em>do</em> supply a handler.</p>
<p>The given <code>event</code> object is deep-copied (cloned), and the copy is stored internally so you do not need to keep the object around after this call.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>event</code>'s associated trigger type must be <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a59b7f49353f2a99b6c22d2eaae0fe9e9a25c2dc47991b3df171ed5192bcf70390">TriggerType::kUnknown</a> or already set to <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a59b7f49353f2a99b6c22d2eaae0fe9e9a04a6eca450c24af0269212fb90c57d9f" title="This trigger indicates that an associated event is triggered whenever a solver takes a step.">TriggerType::kPerStep</a>. </dd></dl>

</div>
</div>
<a id="a49a07c6bbccc4464d5d6192889c3d2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a07c6bbccc4464d5d6192889c3d2e6">&#9670;&nbsp;</a></span>DeclarePerStepPublishEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePerStepPublishEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>publish</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that a Publish event should occur at initialization and at the end of every trajectory-advancing step and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyPublish(<span class="keyword">const</span> Context&lt;T&gt;&amp;) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<dl class="section warning"><dt>Warning</dt><dd>These per-step publish events are independent of the Simulator's optional "publish every time step" and "publish at initialization" features. Generally if you are declaring per-step publish events yourself you should turn off those Simulation options.</dd></dl>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_per-step_events">Declare per-step events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>publish</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a045f31a25ecb0c57baede1abd70182a8" title="Declares that a DiscreteUpdate event should occur at the start of every trajectory-advancing step and...">DeclarePerStepDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a0d51151d69bb455091dc4c2f4c42729a" title="Declares that an UnrestrictedUpdate event should occur at the start of every trajectory-advancing ste...">DeclarePerStepUnrestrictedUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700" title="(Advanced) Declares that a particular Event object should be dispatched at every trajectory-advancing...">DeclarePerStepEvent()</a> </dd>
<dd>
Simulator::set_publish_at_initialization() </dd>
<dd>
Simulator::set_publish_every_time_step() </dd></dl>

</div>
</div>
<a id="a0d51151d69bb455091dc4c2f4c42729a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d51151d69bb455091dc4c2f4c42729a">&#9670;&nbsp;</a></span>DeclarePerStepUnrestrictedUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeclarePerStepUnrestrictedUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event_status.html">EventStatus</a>(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that an UnrestrictedUpdate event should occur at the start of every trajectory-advancing step and that it should invoke the given event handler method. </p>
<p>The handler should be a class member function (method) with this signature: </p><div class="fragment"><div class="line">EventStatus MySystem::MyUpdate(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                               State&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and the method name is arbitrary.</p>
<p>See <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#declare_per-step_events">Declare per-step events</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> must be dynamic_cast-able to MySystem. </dd>
<dd>
<code>update</code> must not be null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a49a07c6bbccc4464d5d6192889c3d2e6" title="Declares that a Publish event should occur at initialization and at the end of every trajectory-advan...">DeclarePerStepPublishEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a045f31a25ecb0c57baede1abd70182a8" title="Declares that a DiscreteUpdate event should occur at the start of every trajectory-advancing step and...">DeclarePerStepDiscreteUpdateEvent()</a> </dd>
<dd>
<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700" title="(Advanced) Declares that a particular Event object should be dispatched at every trajectory-advancing...">DeclarePerStepEvent()</a> </dd></dl>

</div>
</div>
<a id="adcaf3f126c716c557ba620cb56caca18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaf3f126c716c557ba620cb56caca18">&#9670;&nbsp;</a></span>DeclareStateOutputPort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareStateOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a>&#160;</td>
          <td class="paramname"><em>state_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an abstract-valued output port whose value is the given abstract state of this system. </p>
<p>@pydrake_mkdoc_identifier{abstract} </p>

</div>
</div>
<a id="a4f1ea2f7fdb9121ecc50705bb8ed2fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1ea2f7fdb9121ecc50705bb8ed2fb5">&#9670;&nbsp;</a></span>DeclareStateOutputPort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareStateOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a180dfb39dc60232f4dacf555d1ed2582">ContinuousStateIndex</a>&#160;</td>
          <td class="paramname"><em>state_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued output port whose value is the continuous state of this system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_index</td><td>must be ContinuousStateIndex(0) for now, since <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> only supports a single continuous state group at the moment. @pydrake_mkdoc_identifier{continuous} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93d533da6efa2843071c8d123c6e4800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d533da6efa2843071c8d123c6e4800">&#9670;&nbsp;</a></span>DeclareStateOutputPort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareStateOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td>
          <td class="paramname"><em>state_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued output port whose value is the given discrete state group of this system. </p>
<p>@pydrake_mkdoc_identifier{discrete} </p>

</div>
</div>
<a id="aff6f3ee5d89fd1810639e04056768eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6f3ee5d89fd1810639e04056768eba">&#9670;&nbsp;</a></span>DeclareVectorInputPort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; DeclareVectorInputPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt;&#160;</td>
          <td class="paramname"><em>random_type</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5917e1a570b31a5737aec9b49f4c190a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5917e1a570b31a5737aec9b49f4c190a">&#9670;&nbsp;</a></span>DeclareVectorInputPort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; DeclareVectorInputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt;&#160;</td>
          <td class="paramname"><em>random_type</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued input port using the given <code>model_vector</code>. </p>
<p>This is the best way to declare <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> input ports that require subclasses of <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>. The port's size and type will be the same as model_vector. If the port is intended to model a random noise or disturbance input, <code>random_type</code> can (optionally) be used to label it as such. If the <code>model_vector</code> declares any <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_vector_base.html#afcd23700f1c0e51cb736750eb3fafa51" title="Get the bounds for the elements.">VectorBase::GetElementBounds()</a> constraints, they will be re-declared as inequality constraints on this system (see <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a3bac306621c3f0839324649151c22af2" title="Declares a system constraint of the form bounds.lower() &lt;= calc(context) &lt;= bounds....">DeclareInequalityConstraint()</a>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b57e4cacf2beba4ef87c87f824aba8" title="Adds a port with the specified type and size to the input topology.">System::DeclareInputPort()</a> for more information. @pydrake_mkdoc_identifier{3args_model_vector} </dd></dl>

</div>
</div>
<a id="a4185d2244cddf8fce953f1c7ffbc514a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4185d2244cddf8fce953f1c7ffbc514a">&#9670;&nbsp;</a></span>DeclareVectorInputPort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; DeclareVectorInputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacemaliput_1_1drake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt;&#160;</td>
          <td class="paramname"><em>random_type</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued input port with type <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> and size <code>size</code>. </p>
<p>If the port is intended to model a random noise or disturbance input, <code>random_type</code> can (optionally) be used to label it as such.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#af0b57e4cacf2beba4ef87c87f824aba8" title="Adds a port with the specified type and size to the input topology.">System::DeclareInputPort()</a> for more information. @pydrake_mkdoc_identifier{3args_size} </dd></dl>

</div>
</div>
<a id="aa8555d0744eb060d4c9dc32506539197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8555d0744eb060d4c9dc32506539197">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback&#160;</td>
          <td class="paramname"><em>vector_calc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab80f86f8f54344373ce6597afd8fd55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f86f8f54344373ce6597afd8fd55f">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">const BasicVectorSubtype &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b5d6f493e1a290ab4ae6c12d28905b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5d6f493e1a290ab4ae6c12d28905b1">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt; &amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback&#160;</td>
          <td class="paramname"><em>vector_calc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Declares a vector-valued output port using the given <code>model_vector</code> and a function for calculating the port's value at runtime. </p>
<p>The port's size will be model_vector.size(), and the default allocator for the port will be model_vector.Clone(). Note that this takes the calculator function in its most generic form; if you have a member function available use one of the other signatures. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html#a62d51f59c5dcae13358abd4585fb734d" title="Signature of a function suitable for calculating a value of a particular vector-valued output port,...">LeafOutputPort::CalcVectorCallback</a> @pydrake_mkdoc_identifier{4args_model_vector} </dd></dl>

</div>
</div>
<a id="a11479a5cb19f65f35f1a7f5530fb42a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11479a5cb19f65f35f1a7f5530fb42a0">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasicVectorSubtype &amp;&#160;</td>
          <td class="paramname"><em>model_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype derived from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> and initialized to the correct size and desired initial value, and (2) a calculator function that is a class member function (method) with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcOutputVector(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                                BasicVectorSubtype*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code>. Template arguments will be deduced and do not need to be specified. @exclude_from_pydrake_mkdoc{Not bound in pydrake.} </p>

</div>
</div>
<a id="af3da3722efc85a5f8ab121b8c21664c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3da3722efc85a5f8ab121b8c21664c5">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback&#160;</td>
          <td class="paramname"><em>vector_calc_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Declares a vector-valued output port with type BasicVector&lt;T&gt; and size <code>size</code>, using the maliput::drake::dummy_value&lt;T&gt;, which is NaN when T = double. </p>
<p><code>vector_calc_function</code> is a function for calculating the port's value at runtime. Note that this takes the calculator function in its most generic form; if you have a member function available use one of the other signatures. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html#a62d51f59c5dcae13358abd4585fb734d" title="Signature of a function suitable for calculating a value of a particular vector-valued output port,...">LeafOutputPort::CalcVectorCallback</a> @pydrake_mkdoc_identifier{4args_size} </dd></dl>

</div>
</div>
<a id="ac0e6bf117c89b76c8893cf45f1ba652a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e6bf117c89b76c8893cf45f1ba652a">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued output port with type <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> and size <code>size</code>, using the maliput::drake::dummy_value&lt;T&gt;, which is NaN when T = double. </p>
<p><code>calc</code> is a calculator function that is a class member function (method) with signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcOutputVector(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                                BasicVector&lt;T&gt;*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code>. Template arguments will be deduced and do not need to be specified. @exclude_from_pydrake_mkdoc{Not bound in pydrake.} </p>

</div>
</div>
<a id="a580e15b4d10db0b8c07762b3ac36e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580e15b4d10db0b8c07762b3ac36e632">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structmaliput_1_1drake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a vector-valued output port by specifying <em>only</em> a calculator function that is a class member function (method) with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcOutputVector(<span class="keyword">const</span> Context&lt;T&gt;&amp;,</div>
<div class="line">                                BasicVectorSubtype*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <code>MySystem</code> is a class derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>&lt;T&gt;</code> and <code>BasicVectorSubtype</code> is derived from <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>&lt;T&gt;</code> and has a suitable default constructor that allocates a vector of the expected size. This will use <code>BasicVectorSubtype{}</code> (that is, the default constructor) to produce a model vector for the output port's value. Template arguments will be deduced and do not need to be specified.</p>
<dl class="section note"><dt>Note</dt><dd>The default constructor will be called once immediately, and subsequent allocations will just copy the model value without invoking the constructor again. If you want the constructor invoked again at each allocation (not common), use one of the other signatures to explicitly provide a method for the allocator to call; that method can then invoke the <code>BasicVectorSubtype</code> default constructor. @exclude_from_pydrake_mkdoc{Not bound in pydrake.} </dd></dl>

</div>
</div>
<a id="afae593893666b820d3c725e1570967bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae593893666b820d3c725e1570967bd">&#9670;&nbsp;</a></span>DeclareVectorOutputPort() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt;T&gt;&amp; DeclareVectorOutputPort </td>
          <td>(</td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;&#160;</td>
          <td class="paramname"><em>prerequisites_of_calc</em> = <code>{&#160;all_sources_ticket()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07f172b2dafc6d0530bef143c4574d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f172b2dafc6d0530bef143c4574d6e">&#9670;&nbsp;</a></span>DoAllocateContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context_base.html">ContextBase</a> &gt; DoAllocateContext</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3621fd468e9cfb692cec990a5a22c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3621fd468e9cfb692cec990a5a22c91">&#9670;&nbsp;</a></span>DoCalcDiscreteVariableUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DoCalcDiscreteVariableUpdates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>discrete_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived-class event dispatcher for all simultaneous discrete update events. </p>
<p>Override this in your derived <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> only if you require behavior other than the default dispatch behavior (not common). The default behavior is to traverse events in the arbitrary order they appear in <code>events</code>, and for each event that has a callback function, to invoke the callback with <code>context</code>, that event, and <code>discrete_state</code>. Note that the same (possibly modified) <code>discrete_state</code> is passed to subsequent callbacks.</p>
<p>Do not override this just to handle an event &ndash; instead declare the event and a handler callback for it using one of the <code>Declare...DiscreteUpdateEvent()</code> methods.</p>
<p>This method is called only from the virtual DispatchDiscreteVariableUpdateHandler(), which is only called from the public non-virtual <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdates()</a>, which will already have error-checked the parameters so you don't have to. In particular, implementations may assume that <code>context</code> is valid; that <code>discrete_state</code> is non-null, and that the referenced object has the same constituent structure as was produced by <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a75a46315bf6c86eefd7e4cf0f600c7ae" title="Returns a DiscreteValues of the same dimensions as the discrete_state allocated in CreateDefaultConte...">AllocateDiscreteVariables()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The "before" state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>All the discrete update events that need handling. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">discrete_state</td><td>The current state of the system on input; the desired state of the system on return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c883b4b0aa7a507e29dee582d9ed0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c883b4b0aa7a507e29dee582d9ed0fb">&#9670;&nbsp;</a></span>DoCalcNextUpdateTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DoCalcNextUpdateTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the next update time based on the configured periodic events, for scalar types that are arithmetic, or aborts for scalar types that are not arithmetic. </p>
<p>Subclasses that require aperiodic events should override, but be sure to invoke the parent class implementation at the start of the override if you want periodic events to continue to be handled.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>time</code> is set to a value greater than or equal to <code>context.get_time()</code> on return. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you override this method, think carefully before setting <code>time</code> to <code>context.get_time()</code> on return, which can inadvertently cause simulations of systems derived from LeafSystem to loop interminably. Such a loop will occur if, for example, the event(s) does not modify the state. </dd></dl>

<p>Reimplemented from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a710d1532ace6bf692305d2ebce4a06c4">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a1632ac1a231d02181407dc5ad59041a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1632ac1a231d02181407dc5ad59041a0">&#9670;&nbsp;</a></span>DoCalcUnrestrictedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DoCalcUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived-class event dispatcher for all simultaneous unrestricted update events. </p>
<p>Override this in your derived <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> only if you require behavior other than the default dispatch behavior (not common). The default behavior is to traverse events in the arbitrary order they appear in <code>events</code>, and for each event that has a callback function, to invoke the callback with <code>context</code>, that event, and <code>state</code>. Note that the same (possibly modified) <code>state</code> is passed to subsequent callbacks.</p>
<p>Do not override this just to handle an event &ndash; instead declare the event and a handler callback for it using one of the <code>Declare...UnrestrictedUpdateEvent()</code> methods.</p>
<p>This method is called only from the virtual DispatchUnrestrictedUpdateHandler(), which is only called from the non-virtual public <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a>, which will already have error-checked the parameters so you don't have to. In particular, implementations may assume that the <code>context</code> is valid; that <code>state</code> is non-null, and that the referenced object has the same constituent structure as the state in <code>context</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The "before" state that is to be used to calculate the returned state update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>All the unrestricted update events that need handling. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The current state of the system on input; the desired state of the system on return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f1eff5e4fd7f55d152a1b3b9d4bcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">&#9670;&nbsp;</a></span>DoCalcWitnessValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DoCalcWitnessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>witness_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes will implement this method to evaluate a witness function at the given context. </p>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a9440f6840ccb22a989d50ff8a7e65760">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a15031238be1c5b2985578d1e63bab2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15031238be1c5b2985578d1e63bab2d7">&#9670;&nbsp;</a></span>DoMakeLeafContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &gt; DoMakeLeafContext</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a new instance of the leaf context for this system. </p>
<p>Derived leaf systems with custom derived leaf system contexts should override this to provide a context of the appropriate type. The returned context should be "empty"; invoked by <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af0339d1a60201dd7e42d5e8a80285152" title="Shadows System&lt;T&gt;::AllocateContext to provide a more concrete return type LeafContext&lt;T&gt;.">AllocateContext()</a>, the caller will take the responsibility to initialize the core <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html" title="LeafContext contains all prerequisite data necessary to uniquely determine the results of computation...">LeafContext</a> data. The default implementation provides a default-constructed <code><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html" title="LeafContext contains all prerequisite data necessary to uniquely determine the results of computation...">LeafContext</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a id="ac06b0e87bccd80a2e69a8d84c655840a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06b0e87bccd80a2e69a8d84c655840a">&#9670;&nbsp;</a></span>DoPublish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DoPublish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived-class event dispatcher for all simultaneous publish events in <code>events</code>. </p>
<p>Override this in your derived <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> only if you require behavior other than the default dispatch behavior (not common). The default behavior is to traverse events in the arbitrary order they appear in <code>events</code>, and for each event that has a callback function, to invoke the callback with <code>context</code> and that event.</p>
<p>Do not override this just to handle an event &ndash; instead declare the event and a handler callback for it using one of the <code>Declare...PublishEvent()</code> methods.</p>
<p>This method is called only from the virtual DispatchPublishHandler, which is only called from the public non-virtual <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01" title="This method is the public entry point for dispatching all publish event handlers.">Publish()</a>, which will have already error-checked <code>context</code> so you may assume that it is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Const current context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>All the publish events that need handling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bd6ca8a128bb2663ebaa27d6851c68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd6ca8a128bb2663ebaa27d6851c68d">&#9670;&nbsp;</a></span>DoValidateAllocatedLeafContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoValidateAllocatedLeafContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes that impose restrictions on what resources are permitted should check those restrictions by implementing this. </p>
<p>For example, a derived class might require a single input and single output. Note that the supplied <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> will be complete except that input and output dependencies on peer and parent subcontexts will not yet have been set up, so you may not consider them for validation. The default implementation does nothing. </p>

</div>
</div>
<a id="ae8ef897fdededa85dc5b1cef29009cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ef897fdededa85dc5b1cef29009cf5">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;2021-11-01&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;This overload for <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#af669e17632efa35e1dd28f5af9a96b9b">DeclareAbstractOutputPort</a> is rarely the best choice;&quot; &quot; it is unusual for a boutique allocation to return an abstract type by&quot; &quot; value rather than provide a model_value. If the default constructor&quot; &quot; or a model value cannot be&#160;</td>
          <td class="paramname"><em>used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">use the overload that accepts an&quot; &quot; AllocCallback alloc_function instead.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3594555c30be66710766bb18169da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3594555c30be66710766bb18169da6b">&#9670;&nbsp;</a></span>GetDirectFeedthroughs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt; int, int &gt; GetDirectFeedthroughs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac370e74eb508e94b3eee667977d7185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac370e74eb508e94b3eee667977d7185a">&#9670;&nbsp;</a></span>GetGraphvizFragment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetGraphvizFragment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream *&#160;</td>
          <td class="paramname"><em>dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a graphviz fragment for this <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>Leaf systems are visualized as records. For instance, a leaf system with 2 inputs and 1 output is:</p>
<pre class="fragment">123456 [shape= record, label="name | {&lt;u0&gt; 0 |&lt;y0&gt; 0} | {&lt;u1&gt; 1 | }"];
</pre><p>which looks like:</p>
<pre class="fragment">+------------+----+
| name  | u0 | u1 |
|       | y0 |    |
+-------+----+----+
</pre> 
<p>Reimplemented from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0732c676190d17645ea9103bbfb0ca78">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="acfd6d412aafdf2814ced8e8fe460fc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd6d412aafdf2814ced8e8fe460fc23">&#9670;&nbsp;</a></span>GetGraphvizInputPortToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetGraphvizInputPortToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream *&#160;</td>
          <td class="paramname"><em>dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>. </p>
<p>Does nothing by default. </p>

<p>Reimplemented from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a350ddfa07205d6ae68e8f01c12cfc053">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a37060c889e34319f11652b5ad21cfbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37060c889e34319f11652b5ad21cfbb9">&#9670;&nbsp;</a></span>GetGraphvizOutputPortToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetGraphvizOutputPortToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream *&#160;</td>
          <td class="paramname"><em>dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>. </p>
<p>Does nothing by default. </p>

<p>Reimplemented from <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a1c4224423eafc6245ff15cbe2c270ce0">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ab003f82ede0c6e8e6f1f1862ea54b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab003f82ede0c6e8e6f1f1862ea54b31d">&#9670;&nbsp;</a></span>GetMutableNumericParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U&lt;T&gt;&amp; GetMutableNumericParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the numeric parameters of type U from the <code>context</code> at <code>index</code>. </p>
<p>Asserts if the context is not a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html" title="LeafContext contains all prerequisite data necessary to uniquely determine the results of computation...">LeafContext</a>, or if it does not have a vector-valued parameter of type U at <code>index</code>. </p>

</div>
</div>
<a id="a4e4a60af942a6a568694334837d19931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4a60af942a6a568694334837d19931">&#9670;&nbsp;</a></span>GetNumericParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const U&lt;T&gt;&amp; GetNumericParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the numeric parameters of type U from the <code>context</code> at <code>index</code>. </p>
<p>Asserts if the context is not a <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_context.html" title="LeafContext contains all prerequisite data necessary to uniquely determine the results of computation...">LeafContext</a>, or if it does not have a vector-valued parameter of type U at <code>index</code>. </p>

</div>
</div>
<a id="ab146f195a06073ce0987f6b531fa9ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab146f195a06073ce0987f6b531fa9ea3">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>calc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function; and with no event object. </p>
<dl class="section note"><dt>Note</dt><dd>In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. </dd></dl>

</div>
</div>
<a id="a3134d4dd585005d1dc8687dc619a9e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3134d4dd585005d1dc8687dc619a9e0c">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function, and with an object corresponding to the event that is to be dispatched when this witness function triggers. </p>
<p>Example types of event objects are publish, discrete variable update, unrestricted update events. A clone of the event will be owned by the newly constructed <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html" title="Class that stores a function that is able to help determine the time and state at which a step of the...">WitnessFunction</a>.</p>
<dl class="section note"><dt>Note</dt><dd>In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. </dd></dl>

</div>
</div>
<a id="a8d09351dbeec49917149d6da5b701c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d09351dbeec49917149d6da5b701c12">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt;T&gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>calc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function; and with no event object. </p>
<dl class="section note"><dt>Note</dt><dd>Constructing a witness function with no corresponding event forces Simulator's integration of an ODE to end a step at the witness isolation time. For example, isolating a function's minimum or maximum values can be realized with a witness that triggers on a sign change of the function's time derivative, ensuring that the actual extreme value is present in the discretized trajectory.</dd>
<dd>
In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. @exclude_from_pydrake_mkdoc{Only the std::function versions are bound.} </dd></dl>

</div>
</div>
<a id="a650d4bdc065de71ea29a608f9e5a1261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650d4bdc065de71ea29a608f9e5a1261">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt;T&gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function, and with an object corresponding to the event that is to be dispatched when this witness function triggers. </p>
<p>Example types of event objects are publish, discrete variable update, unrestricted update events. A clone of the event will be owned by the newly constructed <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html" title="Class that stores a function that is able to help determine the time and state at which a step of the...">WitnessFunction</a>.</p>
<dl class="section note"><dt>Note</dt><dd>In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. @exclude_from_pydrake_mkdoc{Only the std::function versions are bound.} </dd></dl>

</div>
</div>
<a id="ad78860f078c81981b9acc498186d5d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78860f078c81981b9acc498186d5d94">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt;T&gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>du_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and discrete update event callback function for when this triggers. </p>
<dl class="section note"><dt>Note</dt><dd>In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. @exclude_from_pydrake_mkdoc{Only the std::function versions are bound.} </dd></dl>

</div>
</div>
<a id="a6a1b41173a1b0149226c9d5b7c3601ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1b41173a1b0149226c9d5b7c3601ce">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt;T&gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>publish_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and publish event callback function for when this triggers. </p>
<dl class="section note"><dt>Note</dt><dd>In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. @exclude_from_pydrake_mkdoc{Only the std::function versions are bound.} </dd></dl>

</div>
</div>
<a id="a521a1bd4eee88561b0e1a3b06b7fe1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521a1bd4eee88561b0e1a3b06b7fe1b7">&#9670;&nbsp;</a></span>MakeWitnessFunction() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmaliput_1_1drake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt;T&gt; &gt; MakeWitnessFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>calc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem::*)(const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &amp;, <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const&#160;</td>
          <td class="paramname"><em>uu_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and unrestricted update event callback function for when this triggers. </p>
<dl class="section note"><dt>Note</dt><dd>In order for the witness function to be used, you MUST overload <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a0b9d6f71af96840edfe44f5d242156a8" title="Derived classes can override this method to provide witness functions active for the given state.">System::DoGetWitnessFunctions()</a>. @exclude_from_pydrake_mkdoc{Only the std::function versions are bound.} </dd></dl>

</div>
</div>
<a id="afaa4456210daa5f5db91308fcd1a59b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa4456210daa5f5db91308fcd1a59b4">&#9670;&nbsp;</a></span>MALIPUT_DRAKE_DEMAND()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MALIPUT_DRAKE_DEMAND </td>
          <td>(</td>
          <td class="paramtype">this_ptr !&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48a5a76172d2c18e3ac495b44c866c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a5a76172d2c18e3ac495b44c866c1b">&#9670;&nbsp;</a></span>SetDefaultParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation: sets all numeric parameters to the model vector given to DeclareNumericParameter, or else if no model was provided sets the numeric parameter to one. </p>
<p>It sets all abstract parameters to the model value given to DeclareAbstractParameter. Overrides must not change the number of parameters. </p>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#abb9c4edaf95ef26f1ec419f32446e042">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ac920e22e905b83dbc0abaaa57d2c0251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac920e22e905b83dbc0abaaa57d2c0251">&#9670;&nbsp;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation: sets all continuous state to the model vector given in DeclareContinuousState (or zero if no model vector was given) and discrete states to zero. </p>
<p>Overrides must not change the number of state variables. </p>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1systems_1_1_system.html#a909935648b14e55b07263264616ace3c">System&lt; T &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaa3ede112d18c271986b415c5bef53e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3ede112d18c271986b415c5bef53e1">&#9670;&nbsp;</a></span>allocate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_value_producer.html#a4df060317da95358cd76822bd802de72">ValueProducer::AllocateCallback</a> allocate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [this_ptr, make]() {</div>
<div class="line">      <span class="keywordflow">return</span> AbstractValue::Make&lt;OutputType&gt;((this_ptr-&gt;*make)());</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71f36e6a47a3d2af2fd2f848771edf7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f36e6a47a3d2af2fd2f848771edf7d">&#9670;&nbsp;</a></span>port <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; port</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= CreateAbstractLeafOutputPort(NextOutputPortName(std::move(name)),</div>
<div class="line">                                              ValueProducer(this_ptr, std::move(<a class="code" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aaa3ede112d18c271986b415c5bef53e1">allocate</a>), calc),</div>
<div class="line">                                              std::move(prerequisites_of_calc))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae59f61b7b6e4f7c1ecac7d8f47e6616f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59f61b7b6e4f7c1ecac7d8f47e6616f">&#9670;&nbsp;</a></span>port <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return port</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="leaf__system_8h.html">leaf_system.h</a></li>
<li><a class="el" href="leaf__system_8cc.html">leaf_system.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassmaliput_1_1drake_1_1systems_1_1_system_html_a2789768c5d75378c081683a8016f0784"><div class="ttname"><a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a2789768c5d75378c081683a8016f0784">maliput::drake::systems::System::all_state_ticket</a></div><div class="ttdeci">static DependencyTicket all_state_ticket()</div><div class="ttdoc">Returns a ticket indicating dependence on all state variables x in this system, including continuous ...</div><div class="ttdef"><b>Definition:</b> system_base.h:554</div></div>
<div class="ttc" id="aclassmaliput_1_1drake_1_1systems_1_1_leaf_system_html_aaa3ede112d18c271986b415c5bef53e1"><div class="ttname"><a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#aaa3ede112d18c271986b415c5bef53e1">maliput::drake::systems::LeafSystem::allocate</a></div><div class="ttdeci">ValueProducer::AllocateCallback allocate</div><div class="ttdef"><b>Definition:</b> leaf_system.h:1435</div></div>
<div class="ttc" id="anamespacemaliput_1_1drake_1_1systems_html_aa53feaf560f7ff6cfa4add8dc6ff0db0"><div class="ttname"><a href="namespacemaliput_1_1drake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">maliput::drake::systems::InputPortIndex</a></div><div class="ttdeci">TypeSafeIndex&lt; class InputPortTag &gt; InputPortIndex</div><div class="ttdoc">Serves as the local index for the input ports of a given System.</div><div class="ttdef"><b>Definition:</b> framework_common.h:48</div></div>
<div class="ttc" id="aclassmaliput_1_1drake_1_1systems_1_1_system_html_a191b7cb5dcbfee51a62fa042ec14561f"><div class="ttname"><a href="classmaliput_1_1drake_1_1systems_1_1_system.html#a191b7cb5dcbfee51a62fa042ec14561f">maliput::drake::systems::System::input_port_ticket</a></div><div class="ttdeci">DependencyTicket input_port_ticket(InputPortIndex index) const</div><div class="ttdoc">Returns a ticket indicating dependence on input port uᵢ indicated by index.</div><div class="ttdef"><b>Definition:</b> system_base.h:589</div></div>
<div class="ttc" id="aclassmaliput_1_1drake_1_1systems_1_1_leaf_system_html_a11479a5cb19f65f35f1a7f5530fb42a0"><div class="ttname"><a href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html#a11479a5cb19f65f35f1a7f5530fb42a0">maliput::drake::systems::LeafSystem::DeclareVectorOutputPort</a></div><div class="ttdeci">LeafOutputPort&lt; T &gt; &amp; DeclareVectorOutputPort(std::variant&lt; std::string, UseDefaultName &gt; name, const BasicVectorSubtype &amp;model_vector, void(MySystem::*calc)(const Context&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; DependencyTicket &gt; prerequisites_of_calc={ all_sources_ticket()})</div><div class="ttdoc">Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype deri...</div><div class="ttdef"><b>Definition:</b> leaf_system.h:1248</div></div>
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemaliput.html">maliput</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1drake.html">drake</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1drake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classmaliput_1_1drake_1_1systems_1_1_leaf_system.html">LeafSystem</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>

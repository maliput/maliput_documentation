<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>maliput: PiecewisePolynomial&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">maliput
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PiecewisePolynomial&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class maliput::drake::trajectories::PiecewisePolynomial&lt; T &gt;</h3>

<p>A scalar multi-variate piecewise polynomial. </p>
<p>PiecewisePolynomial represents a list of contiguous segments in a scalar independent variable (typically corresponding to time) with Polynomials defined at each segment. We call the output from evaluating the PiecewisePolynomial at the scalar independent variable "the output", and that output can be either a Eigen MatrixX&lt;T&gt; (if evaluated using <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>) or a scalar (if evaluated using scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in time, where a different polynomial is defined for each segment. For a specific example, consider the absolute value function over the interval [-1, 1]. We can define a PiecewisePolynomial over this interval using breaks at t = { -1.0, 0.0, 1.0 }, and "samples" of abs(t).</p>
<div class="fragment"><div class="line"><span class="comment">// Construct the PiecewisePolynomial.</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { -1.0, 0.0, 1.0 };</div>
<div class="line">std::vector&lt;Eigen::MatrixXd&gt; samples(3);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; static_cast&lt;int&gt;(<a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>.size()); ++i) {</div>
<div class="line">  samples[i].resize(1, 1);</div>
<div class="line">  samples[i](0, 0) = std::abs(<a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[i]);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pp =</div>
<div class="line">     <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a7ced7dd68c8859113c25ddb246c0731d">PiecewisePolynomial&lt;double&gt;::FirstOrderHold</a>(<a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, samples);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> row = 0, col = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the PiecewisePolynomial at some values.</span></div>
<div class="line">std::cout &lt;&lt; pp.value(-.5)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 0.5.</span></div>
<div class="line">std::cout &lt;&lt; pp.value(0.0)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 0.0;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Show how we can evaluate the first derivative (outputs -1.0).</span></div>
<div class="line">std::cout &lt;&lt; pp.derivative(1).value(-.5)(row, col) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>A note on terminology. For piecewise-polynomial interpolation, we use <code>breaks</code> to indicate the scalar (e.g. times) which form the boundary of each segment. We use <code>samples</code> to indicate the function value at the <code>breaks</code>, e.g. <code>p(breaks[i]) = samples[i]</code>. The term <code>knot</code> should be reserved for the "(x,y)" coordinate, here <code>knot[i] = (breaks[i], samples[i])</code>, though it is used inconsistently in the interpolation literature (sometimes for <code>breaks</code>, sometimes for <code>samples</code>), so we try to mostly avoid it here.</p>
<p><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> objects can be added, subtracted, and multiplied. They cannot be divided because Polynomials are not closed under division.</p>
<dl class="section warning"><dt>Warning</dt><dd>PiecewisePolynomial silently clips input evaluations outside of the range defined by the breaks. So <code>pp.value(-2.0, row, col)</code> in the example above would evaluate to -1.0. See <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>.</dd></dl>
<p>@tparam_default_scalars </p>
</div>
<p><code>#include &lt;src/maliput/drake/common/trajectories/piecewise_polynomial.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PiecewisePolynomial&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial__inherit__graph.svg" width="210" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c5cbf1ba95055937fdb8283769df797"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a></td></tr>
<tr class="separator:a9c5cbf1ba95055937fdb8283769df797"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> ()=default</td></tr>
<tr class="memdesc:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty piecewise polynomial.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a6a44781cbe3dd6c55234638a1b63d4ef">More...</a><br /></td></tr>
<tr class="separator:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838cb1725eb9ba7896158fa9032ecdcc"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a838cb1725eb9ba7896158fa9032ecdcc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a838cb1725eb9ba7896158fa9032ecdcc">PiecewisePolynomial</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;constant_value)</td></tr>
<tr class="memdesc:a838cb1725eb9ba7896158fa9032ecdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single segment, constant value constructor over the interval [-∞, ∞].  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a838cb1725eb9ba7896158fa9032ecdcc">More...</a><br /></td></tr>
<tr class="separator:a838cb1725eb9ba7896158fa9032ecdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial-based construction methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="polynomial_construction_methods"></a> Various methods for constructing a PiecewisePolynomial using vectors of matrices of polynomials, one for each output dimension. Unlike the coefficient-based methods, the number of polynomials must equal the number of segments, which will be one fewer than the number of breaks.</p>
<p>The following shows how such a PiecewisePolynomial might be constructed and used: </p><div class="fragment"><div class="line"><span class="comment">// Construct the PiecewisePolynomial.</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { -1.0, 0.0, 1.0 };</div>
<div class="line"><a class="code" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">std::vector&lt;Polynomiald&gt; polynomials = { -(t*t), (t*t) };</div>
<div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the PiecewisePolynomial at some values.</span></div>
<div class="line">std::cout &lt;&lt; pp.scalar_value(-1.0) &lt;&lt; std::endl;    <span class="comment">// Outputs -1.0</span></div>
<div class="line">std::cout &lt;&lt; pp.scalar_value(1.0) &lt;&lt; std::endl;     <span class="comment">// Outputs 1.0</span></div>
</div><!-- fragment --><p><a class="anchor" id="polynomial_warning"></a><b>WARNING:</b> For robust floating point arithmetic, the polynomial for a segment will be evaluated (using <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>) by first subtracting the break time from the evaluation time. In other words, when t lies in the half-open interval <code>[breaks[i], breaks[i+1])</code> then: </p><div class="fragment"><div class="line"><a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8">value</a>(t) == polynomials[i].eval(t - <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[i])</div>
</div><!-- fragment --><p> meaning that constructing the polynomial like: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { 0.0, 1.0, 2.0 };</div>
<div class="line"><a class="code" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">std::vector&lt;Polynomiald&gt; polynomials = { (t*t), (t*t) };</div>
<div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>);</div>
</div><!-- fragment --><p> would give the following result: </p><div class="fragment"><div class="line"><span class="comment">// Evaluate the PiecewisePolynomial on both sides of a break.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> row = 0, col = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.5 * std::numeric_limits&lt;double&gt;::epsilon();</div>
<div class="line">std::cout &lt;&lt; pp.value(1.0-eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div>
<div class="line">std::cout &lt;&lt; pp.value(1.0+eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1e-32</span></div>
</div><!-- fragment --><p> because the second polynomial will be evaluated at 1.0+eps minus the break time for that polynomial (1.0), i.e., t=eps. The intended result for the above example can be obtained by shifting the piecewise polynomial like so: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { 0.0, 1.0, 2.0 };</div>
<div class="line"><a class="code" href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">std::vector&lt;Polynomiald&gt; polynomials = { (t*t),</div>
<div class="line">    ((t+<a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[1])*(t+<a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[1])) };</div>
<div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the PiecewisePolynomial on both sides of a break.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.5 * std::numeric_limits&lt;double&gt;::epsilon();</div>
<div class="line">std::cout &lt;&lt; pp.value(1.0-eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div>
<div class="line">std::cout &lt;&lt; pp.value(1.0+eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a9145f61319cb888cb71fc58cebc8fe38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9145f61319cb888cb71fc58cebc8fe38">PiecewisePolynomial</a> (const std::vector&lt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &gt; &amp;polynomials_matrix, const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>)</td></tr>
<tr class="memdesc:a9145f61319cb888cb71fc58cebc8fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PiecewisePolynomial using matrix-output Polynomials defined over each segment.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9145f61319cb888cb71fc58cebc8fe38">More...</a><br /></td></tr>
<tr class="separator:a9145f61319cb888cb71fc58cebc8fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481736a225b93bd2343445f02c8eafec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a481736a225b93bd2343445f02c8eafec">PiecewisePolynomial</a> (const std::vector&lt; <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&gt; &amp;polynomials, const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>)</td></tr>
<tr class="memdesc:a481736a225b93bd2343445f02c8eafec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PiecewisePolynomial using scalar-output Polynomials defined over each segment.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a481736a225b93bd2343445f02c8eafec">More...</a><br /></td></tr>
<tr class="separator:a481736a225b93bd2343445f02c8eafec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc4d107b331f4e33f2893826c44be27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a5dc4d107b331f4e33f2893826c44be27">~PiecewisePolynomial</a> () override=default</td></tr>
<tr class="separator:a5dc4d107b331f4e33f2893826c44be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed3c4da7fb13c79983a5be307338583"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a0ed3c4da7fb13c79983a5be307338583">Clone</a> () const override</td></tr>
<tr class="separator:a0ed3c4da7fb13c79983a5be307338583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a80ed62d7a0f2d3eee401cdd29e47d534 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a80ed62d7a0f2d3eee401cdd29e47d534">~PiecewiseTrajectory</a> () override=default</td></tr>
<tr class="separator:a80ed62d7a0f2d3eee401cdd29e47d534 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5241db765b5a4de7c88bb996d39a8 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a4ff5241db765b5a4de7c88bb996d39a8">get_number_of_segments</a> () const</td></tr>
<tr class="separator:a4ff5241db765b5a4de7c88bb996d39a8 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1019f41dcfe440c98c91029f4b0b0bc0 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time</a> (int segment_number) const</td></tr>
<tr class="separator:a1019f41dcfe440c98c91029f4b0b0bc0 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1604e170d921c073e4fba715622507 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time</a> (int segment_number) const</td></tr>
<tr class="separator:a4c1604e170d921c073e4fba715622507 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88c3d4b35f53401069500f721083309 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#af88c3d4b35f53401069500f721083309">duration</a> (int segment_number) const</td></tr>
<tr class="separator:af88c3d4b35f53401069500f721083309 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09cf8e8ad481f69f3cc1969ef491d60 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ae09cf8e8ad481f69f3cc1969ef491d60">start_time</a> () const override</td></tr>
<tr class="separator:ae09cf8e8ad481f69f3cc1969ef491d60 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641bfb18296d6976a000cf31c213dfdf inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a641bfb18296d6976a000cf31c213dfdf">end_time</a> () const override</td></tr>
<tr class="separator:a641bfb18296d6976a000cf31c213dfdf inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae435d14c7da7e732884c43b125040a inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#acae435d14c7da7e732884c43b125040a">is_time_in_range</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:acae435d14c7da7e732884c43b125040a inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <code>t &gt;= getStartTime() &amp;&amp; t &lt;= getEndTime()</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#acae435d14c7da7e732884c43b125040a">More...</a><br /></td></tr>
<tr class="separator:acae435d14c7da7e732884c43b125040a inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ae949f44158da731ef777bba601ec inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a326ae949f44158da731ef777bba601ec">get_segment_index</a> (const T &amp;t) const</td></tr>
<tr class="separator:a326ae949f44158da731ef777bba601ec inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b1a0b2d9113c656018bcace89985b4 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times</a> () const</td></tr>
<tr class="separator:ab5b1a0b2d9113c656018bcace89985b4 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ac30a258a47b6ea610f16f4accece inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">segment_number_range_check</a> (int segment_number) const</td></tr>
<tr class="separator:a0a4ac30a258a47b6ea610f16f4accece inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html">Trajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:aec58a75947d06ba435adda6fd990678e inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#aec58a75947d06ba435adda6fd990678e">~Trajectory</a> ()=default</td></tr>
<tr class="separator:aec58a75947d06ba435adda6fd990678e inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a9474931d162dd67c7b3261479e39c inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#ad3a9474931d162dd67c7b3261479e39c">vector_values</a> (const std::vector&lt; T &gt; &amp;t) const</td></tr>
<tr class="memdesc:ad3a9474931d162dd67c7b3261479e39c inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a0e99f338d336c4da23d6d773f4463a52">cols()</a>==1, then evaluates the trajectory at each time <code>t</code>, and returns the results as a Matrix with the ith column corresponding to the ith time.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#ad3a9474931d162dd67c7b3261479e39c">More...</a><br /></td></tr>
<tr class="separator:ad3a9474931d162dd67c7b3261479e39c inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a9507f1cc6b538dc632d20e3d681bbaba">has_derivative</a> () const</td></tr>
<tr class="memdesc:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a> provides and implementation for <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a> and <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#ad0a2e28df96d5c3f7a7d94c47208d65a" title="Takes the derivative of this Trajectory.">MakeDerivative()</a>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a9507f1cc6b538dc632d20e3d681bbaba">More...</a><br /></td></tr>
<tr class="separator:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2912689d33fd58c54d119cab8f4140 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140">EvalDerivative</a> (const T &amp;t, int derivative_order=1) const</td></tr>
<tr class="memdesc:abf2912689d33fd58c54d119cab8f4140 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative of <code>this</code> at the given time <code>t</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140">More...</a><br /></td></tr>
<tr class="separator:abf2912689d33fd58c54d119cab8f4140 inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a2e28df96d5c3f7a7d94c47208d65a inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#ad0a2e28df96d5c3f7a7d94c47208d65a">MakeDerivative</a> (int derivative_order=1) const</td></tr>
<tr class="memdesc:ad0a2e28df96d5c3f7a7d94c47208d65a inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the derivative of this <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#ad0a2e28df96d5c3f7a7d94c47208d65a">More...</a><br /></td></tr>
<tr class="separator:ad0a2e28df96d5c3f7a7d94c47208d65a inherit pub_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Coefficient-based construction methods.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd9e64fdfba24919dfd7aa5ad7ab4a749"></a><a class="anchor" id="coefficient_construction_methods"></a> Various methods for constructing a PiecewisePolynomial using samples of coefficient matrices. Under the hood, PiecewisePolynomial constructs interpolating <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> objects that pass through the sample points. These methods differ by the continuity constraints that they enforce at break points and whether each sample represents a full matrix (versions taking <code>const std::vector&lt;MatrixX&lt;T&gt;&gt;&amp;</code>) or a column vector (versions taking <code>const Eigen::Ref&lt;const MatrixX&lt;T&gt;&gt;&amp;</code>).</p>
<p>These methods will throw <code>std::exception</code> if:</p><ul>
<li>the breaks and samples have different length,</li>
<li>the breaks are not strictly increasing,</li>
<li>the samples have inconsistent dimensions (i.e., the matrices do not all have identical dimensions),</li>
<li>the breaks vector has length smaller than 2. </li>
</ul>
</td></tr>
<tr class="memitem:a405f92e0e677a316b9a8ed8ec841befd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a405f92e0e677a316b9a8ed8ec841befd">derivative</a> (int derivative_order=1) const</td></tr>
<tr class="memdesc:a405f92e0e677a316b9a8ed8ec841befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding segment in <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a405f92e0e677a316b9a8ed8ec841befd">More...</a><br /></td></tr>
<tr class="separator:a405f92e0e677a316b9a8ed8ec841befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaceab81f8d6fd7e3af6d32b076fea0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aeaceab81f8d6fd7e3af6d32b076fea0a">integral</a> (const T &amp;value_at_start_time=0.0) const</td></tr>
<tr class="memdesc:aeaceab81f8d6fd7e3af6d32b076fea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial that is the indefinite integral of this one.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aeaceab81f8d6fd7e3af6d32b076fea0a">More...</a><br /></td></tr>
<tr class="separator:aeaceab81f8d6fd7e3af6d32b076fea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b78f80cc7c6bffcf1ba8a79416544c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a5b78f80cc7c6bffcf1ba8a79416544c9">integral</a> (const Eigen::Ref&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;value_at_start_time) const</td></tr>
<tr class="memdesc:a5b78f80cc7c6bffcf1ba8a79416544c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial that is the indefinite integral of this one.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a5b78f80cc7c6bffcf1ba8a79416544c9">More...</a><br /></td></tr>
<tr class="separator:a5b78f80cc7c6bffcf1ba8a79416544c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this trajectory has no breaks/samples/polynomials.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc">More...</a><br /></td></tr>
<tr class="separator:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16274d0c316c76ded4b85111b38ece15"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a16274d0c316c76ded4b85111b38ece15">scalarValue</a> (const T &amp;t, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:a16274d0c316c76ded4b85111b38ece15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the trajectory at the given time without returning the entire matrix.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a16274d0c316c76ded4b85111b38ece15">More...</a><br /></td></tr>
<tr class="separator:a16274d0c316c76ded4b85111b38ece15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b632df0f98f9aaf224e534fac69ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8">value</a> (const T &amp;t) const override</td></tr>
<tr class="memdesc:a19b632df0f98f9aaf224e534fac69ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the PiecewisePolynomial at the given time t.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8">More...</a><br /></td></tr>
<tr class="separator:a19b632df0f98f9aaf224e534fac69ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda577405638cba7837a16bce8362e08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#acda577405638cba7837a16bce8362e08">getPolynomialMatrix</a> (int segment_index) const</td></tr>
<tr class="memdesc:acda577405638cba7837a16bce8362e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the matrix of Polynomials corresponding to the given segment index.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#acda577405638cba7837a16bce8362e08">More...</a><br /></td></tr>
<tr class="separator:acda577405638cba7837a16bce8362e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc499221b2ff0630d2b79d1fc9ec61d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#acc499221b2ff0630d2b79d1fc9ec61d4">getPolynomial</a> (int segment_index, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:acc499221b2ff0630d2b79d1fc9ec61d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#acc499221b2ff0630d2b79d1fc9ec61d4">More...</a><br /></td></tr>
<tr class="separator:acc499221b2ff0630d2b79d1fc9ec61d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a111a1944f16bb21873433d4b7b31d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aa5a111a1944f16bb21873433d4b7b31d">getSegmentPolynomialDegree</a> (int segment_index, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:aa5a111a1944f16bb21873433d4b7b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the degree of the <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aa5a111a1944f16bb21873433d4b7b31d">More...</a><br /></td></tr>
<tr class="separator:aa5a111a1944f16bb21873433d4b7b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa1f1cfff6dcb352d5fbb15a80ee1a9"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">rows</a> () const override</td></tr>
<tr class="memdesc:a9aa1f1cfff6dcb352d5fbb15a80ee1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the row count of the output matrices.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">More...</a><br /></td></tr>
<tr class="separator:a9aa1f1cfff6dcb352d5fbb15a80ee1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca8eca2ee324f57170dedfb4b06160b"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b">cols</a> () const override</td></tr>
<tr class="memdesc:adca8eca2ee324f57170dedfb4b06160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column count of the output matrices.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b">More...</a><br /></td></tr>
<tr class="separator:adca8eca2ee324f57170dedfb4b06160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39001029f6f2e13a8890f233254c4709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a39001029f6f2e13a8890f233254c4709">Reshape</a> (int <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">rows</a>, int <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b">cols</a>)</td></tr>
<tr class="memdesc:a39001029f6f2e13a8890f233254c4709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>, <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a>, etc.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a39001029f6f2e13a8890f233254c4709">More...</a><br /></td></tr>
<tr class="separator:a39001029f6f2e13a8890f233254c4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadcaf3333fa82c22d1835f0b151522c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#abadcaf3333fa82c22d1835f0b151522c">Block</a> (int start_row, int start_col, int block_rows, int block_cols) const</td></tr>
<tr class="memdesc:abadcaf3333fa82c22d1835f0b151522c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a trajectory representing a block of size (block_rows, block_cols) starting at (start_row, start_col) from the <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#abadcaf3333fa82c22d1835f0b151522c">More...</a><br /></td></tr>
<tr class="separator:abadcaf3333fa82c22d1835f0b151522c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a69e3135eab274fe0e1eefd64397c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ae44a69e3135eab274fe0e1eefd64397c">operator+=</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:ae44a69e3135eab274fe0e1eefd64397c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ae44a69e3135eab274fe0e1eefd64397c">More...</a><br /></td></tr>
<tr class="separator:ae44a69e3135eab274fe0e1eefd64397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a78122bd02f0a481d15f004538fe3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a7a78122bd02f0a481d15f004538fe3cc">operator-=</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a7a78122bd02f0a481d15f004538fe3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a7a78122bd02f0a481d15f004538fe3cc">More...</a><br /></td></tr>
<tr class="separator:a7a78122bd02f0a481d15f004538fe3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bed7e633dcce69577d997599ffceeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#af3bed7e633dcce69577d997599ffceeb">operator*=</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:af3bed7e633dcce69577d997599ffceeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication), storing the result in <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#af3bed7e633dcce69577d997599ffceeb">More...</a><br /></td></tr>
<tr class="separator:af3bed7e633dcce69577d997599ffceeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8719499effc43742b2551756aa5f0ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a8719499effc43742b2551756aa5f0ca3">operator+=</a> (const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff)</td></tr>
<tr class="separator:a8719499effc43742b2551756aa5f0ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa886143234d257349d3b4c3074b2b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afa886143234d257349d3b4c3074b2b46">operator-=</a> (const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff)</td></tr>
<tr class="separator:afa886143234d257349d3b4c3074b2b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c6238655481e93cd87e12125e5cb4b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad9c6238655481e93cd87e12125e5cb4b">operator+</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:ad9c6238655481e93cd87e12125e5cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad9c6238655481e93cd87e12125e5cb4b">More...</a><br /></td></tr>
<tr class="separator:ad9c6238655481e93cd87e12125e5cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036be284513923ec17cc591add07dced"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a036be284513923ec17cc591add07dced">operator-</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:a036be284513923ec17cc591add07dced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a036be284513923ec17cc591add07dced">More...</a><br /></td></tr>
<tr class="separator:a036be284513923ec17cc591add07dced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b25aa337e3ee75f62173d9694f5e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afd3b25aa337e3ee75f62173d9694f5e6">operator-</a> () const</td></tr>
<tr class="memdesc:afd3b25aa337e3ee75f62173d9694f5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements unary minus operator.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afd3b25aa337e3ee75f62173d9694f5e6">More...</a><br /></td></tr>
<tr class="separator:afd3b25aa337e3ee75f62173d9694f5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516c09907a0d8f3f50ee68cea561358f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a516c09907a0d8f3f50ee68cea561358f">operator*</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:a516c09907a0d8f3f50ee68cea561358f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication).  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a516c09907a0d8f3f50ee68cea561358f">More...</a><br /></td></tr>
<tr class="separator:a516c09907a0d8f3f50ee68cea561358f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cf66c84fa13d64a6313a3b28f8ba52"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a02cf66c84fa13d64a6313a3b28f8ba52">operator+</a> (const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff) const</td></tr>
<tr class="separator:a02cf66c84fa13d64a6313a3b28f8ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11188ab9da7d28178b479fb982e7584c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a11188ab9da7d28178b479fb982e7584c">operator-</a> (const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff) const</td></tr>
<tr class="separator:a11188ab9da7d28178b479fb982e7584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7edaa991443e887ca36e0fd20b96c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a5d7edaa991443e887ca36e0fd20b96c7">isApprox</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other, <a class="el" href="classdouble.html">double</a> tol, const <a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;tol_type=<a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">ToleranceType::kRelative</a>) const</td></tr>
<tr class="memdesc:a5d7edaa991443e887ca36e0fd20b96c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a PiecewisePolynomial is approximately equal to this one by calling <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html#ad96f76c37313cb0d62582faccf358345" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a> on every element of every segment.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a5d7edaa991443e887ca36e0fd20b96c7">More...</a><br /></td></tr>
<tr class="separator:a5d7edaa991443e887ca36e0fd20b96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a75d7ffe2f4e1a808aaeb76a871f772e2">ConcatenateInTime</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <code>other</code> to the end of <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a75d7ffe2f4e1a808aaeb76a871f772e2">More...</a><br /></td></tr>
<tr class="separator:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93013774f250920857c17c083350b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ac93013774f250920857c17c083350b57">AppendCubicHermiteSegment</a> (const T &amp;time, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;sample, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;sample_dot)</td></tr>
<tr class="memdesc:ac93013774f250920857c17c083350b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CubicHermite spline construction has a nice property of being incremental (each segment can be solved independently).  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ac93013774f250920857c17c083350b57">More...</a><br /></td></tr>
<tr class="separator:ac93013774f250920857c17c083350b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603a4e747fb099305c01f8762e8cff23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a603a4e747fb099305c01f8762e8cff23">AppendFirstOrderSegment</a> (const T &amp;time, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;sample)</td></tr>
<tr class="memdesc:a603a4e747fb099305c01f8762e8cff23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a new sample, this method adds one segment to the end of <code>this</code> using a first-order hold, where the start sample is taken as the value at the final break of <code>this</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a603a4e747fb099305c01f8762e8cff23">More...</a><br /></td></tr>
<tr class="separator:a603a4e747fb099305c01f8762e8cff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a88e900c12b23dd1cb0bccb6d0357db5f">RemoveFinalSegment</a> ()</td></tr>
<tr class="memdesc:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the final segment from the trajectory, reducing the number of segments by 1.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a88e900c12b23dd1cb0bccb6d0357db5f">More...</a><br /></td></tr>
<tr class="separator:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca7568bb098808d681cb14d7fa09f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99">ReverseTime</a> ()</td></tr>
<tr class="memdesc:afca7568bb098808d681cb14d7fa09f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the trajectory so that pp_after(t) = pp_before(-t).  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99">More...</a><br /></td></tr>
<tr class="separator:afca7568bb098808d681cb14d7fa09f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a923a4ac5ef6f85f444519188d9dbd3e1">ScaleTime</a> (const T &amp;scale)</td></tr>
<tr class="memdesc:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the time of the trajectory by non-negative <code>scale</code> (use <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99" title="Modifies the trajectory so that pp_after(t) = pp_before(-t).">ReverseTime()</a> if you want to also negate time).  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a923a4ac5ef6f85f444519188d9dbd3e1">More...</a><br /></td></tr>
<tr class="separator:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728995759fa06a8d1a2b967d313b6d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a728995759fa06a8d1a2b967d313b6d6b">shiftRight</a> (const T &amp;offset)</td></tr>
<tr class="memdesc:a728995759fa06a8d1a2b967d313b6d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>offset</code> to all of the breaks.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a728995759fa06a8d1a2b967d313b6d6b">More...</a><br /></td></tr>
<tr class="separator:a728995759fa06a8d1a2b967d313b6d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7863e6bf8a3ccb5335563370305add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9a7863e6bf8a3ccb5335563370305add">setPolynomialMatrixBlock</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;replacement, int segment_index, Eigen::Index row_start=0, Eigen::Index col_start=0)</td></tr>
<tr class="memdesc:a9a7863e6bf8a3ccb5335563370305add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the specified block of the PolynomialMatrix at the given segment index.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9a7863e6bf8a3ccb5335563370305add">More...</a><br /></td></tr>
<tr class="separator:a9a7863e6bf8a3ccb5335563370305add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa36391c5f1fc46089a7b4c9e0953a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aaa36391c5f1fc46089a7b4c9e0953a0e">slice</a> (int start_segment_index, int num_segments) const</td></tr>
<tr class="memdesc:aaa36391c5f1fc46089a7b4c9e0953a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PiecewisePolynomial comprising the <code>num_segments</code> segments starting at the specified <code>start_segment_index</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aaa36391c5f1fc46089a7b4c9e0953a0e">More...</a><br /></td></tr>
<tr class="separator:aaa36391c5f1fc46089a7b4c9e0953a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695f2e7cbbe881ea10b500cb77da61fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a695f2e7cbbe881ea10b500cb77da61fb">ZeroOrderHold</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a695f2e7cbbe881ea10b500cb77da61fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a piecewise constant PiecewisePolynomial using matrix samples.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a695f2e7cbbe881ea10b500cb77da61fb">More...</a><br /></td></tr>
<tr class="separator:a695f2e7cbbe881ea10b500cb77da61fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b98ea8f2257d622472c8007150df254"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9b98ea8f2257d622472c8007150df254">ZeroOrderHold</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a9b98ea8f2257d622472c8007150df254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of ZeroOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd/MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9b98ea8f2257d622472c8007150df254">More...</a><br /></td></tr>
<tr class="separator:a9b98ea8f2257d622472c8007150df254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ced7dd68c8859113c25ddb246c0731d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a7ced7dd68c8859113c25ddb246c0731d">FirstOrderHold</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a7ced7dd68c8859113c25ddb246c0731d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a piecewise linear PiecewisePolynomial using matrix samples.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a7ced7dd68c8859113c25ddb246c0731d">More...</a><br /></td></tr>
<tr class="separator:a7ced7dd68c8859113c25ddb246c0731d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d0be81b234de76119137d20f22944f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad7d0be81b234de76119137d20f22944f">FirstOrderHold</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:ad7d0be81b234de76119137d20f22944f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of FirstOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad7d0be81b234de76119137d20f22944f">More...</a><br /></td></tr>
<tr class="separator:ad7d0be81b234de76119137d20f22944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b48f9ba20cdd5c5cd6b2e734aeebd4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a63b48f9ba20cdd5c5cd6b2e734aeebd4">CubicShapePreserving</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool zero_end_point_derivatives=false)</td></tr>
<tr class="memdesc:a63b48f9ba20cdd5c5cd6b2e734aeebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using vector samples, where each column of <code>samples</code> represents a sample point.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a63b48f9ba20cdd5c5cd6b2e734aeebd4">More...</a><br /></td></tr>
<tr class="separator:a63b48f9ba20cdd5c5cd6b2e734aeebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bb43b4e72ae2a372e558b0bdb08933"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ab7bb43b4e72ae2a372e558b0bdb08933">CubicShapePreserving</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool zero_end_point_derivatives=false)</td></tr>
<tr class="memdesc:ab7bb43b4e72ae2a372e558b0bdb08933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicShapePreserving(breaks, samples, zero_end_point_derivatives) that uses vector samples and Eigen VectorXd and MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ab7bb43b4e72ae2a372e558b0bdb08933">More...</a><br /></td></tr>
<tr class="separator:ab7bb43b4e72ae2a372e558b0bdb08933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cae6fa5770ea8da991ede4ae30a693"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad8cae6fa5770ea8da991ede4ae30a693">CubicWithContinuousSecondDerivatives</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;sample_dot_at_start, const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;sample_dot_at_end)</td></tr>
<tr class="memdesc:ad8cae6fa5770ea8da991ede4ae30a693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad8cae6fa5770ea8da991ede4ae30a693">More...</a><br /></td></tr>
<tr class="separator:ad8cae6fa5770ea8da991ede4ae30a693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be5045e91910c89639178ec98cfd720"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a1be5045e91910c89639178ec98cfd720">CubicWithContinuousSecondDerivatives</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;sample_dot_at_start, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;sample_dot_at_end)</td></tr>
<tr class="memdesc:a1be5045e91910c89639178ec98cfd720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad8cae6fa5770ea8da991ede4ae30a693" title="Constructs a third order PiecewisePolynomial using matrix samples.">CubicWithContinuousSecondDerivatives()</a> that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a1be5045e91910c89639178ec98cfd720">More...</a><br /></td></tr>
<tr class="separator:a1be5045e91910c89639178ec98cfd720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae84462532164ec6fb3f9b181546242e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aae84462532164ec6fb3f9b181546242e">CubicHermite</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples_dot)</td></tr>
<tr class="memdesc:aae84462532164ec6fb3f9b181546242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples and derivatives of samples (<code>samples_dot</code>); each matrix element of <code>samples_dot</code> represents the derivative with respect to the independent variable (e.g., the time derivative) of the corresponding entry in <code>samples</code>.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#aae84462532164ec6fb3f9b181546242e">More...</a><br /></td></tr>
<tr class="separator:aae84462532164ec6fb3f9b181546242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ee5e424405c47c2a7f62e14564d095"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a94ee5e424405c47c2a7f62e14564d095">CubicHermite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples_dot)</td></tr>
<tr class="memdesc:a94ee5e424405c47c2a7f62e14564d095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicHermite(breaks, samples, samples_dot) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a94ee5e424405c47c2a7f62e14564d095">More...</a><br /></td></tr>
<tr class="separator:a94ee5e424405c47c2a7f62e14564d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c3fa44ee4e93658163ad2234ec7270"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a03c3fa44ee4e93658163ad2234ec7270">CubicWithContinuousSecondDerivatives</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="memdesc:a03c3fa44ee4e93658163ad2234ec7270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a03c3fa44ee4e93658163ad2234ec7270">More...</a><br /></td></tr>
<tr class="separator:a03c3fa44ee4e93658163ad2234ec7270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084e9ea134495967cf3c17f9d522a3d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a084e9ea134495967cf3c17f9d522a3d9">CubicWithContinuousSecondDerivatives</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="memdesc:a084e9ea134495967cf3c17f9d522a3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicWithContinuousSecondDerivatives(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a084e9ea134495967cf3c17f9d522a3d9">More...</a><br /></td></tr>
<tr class="separator:a084e9ea134495967cf3c17f9d522a3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5076a155bf5d04598cd9bf7ec40b0ddf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a5076a155bf5d04598cd9bf7ec40b0ddf">Cubic</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="separator:a5076a155bf5d04598cd9bf7ec40b0ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101bb74dd8b817701560fc1ff1ce79c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a101bb74dd8b817701560fc1ff1ce79c1">LagrangeInterpolatingPolynomial</a> (const std::vector&lt; T &gt; &amp;times, const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a101bb74dd8b817701560fc1ff1ce79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polynomial with a <em>single segment</em> of the lowest possible degree that passes through all of the sample points.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a101bb74dd8b817701560fc1ff1ce79c1">More...</a><br /></td></tr>
<tr class="separator:a101bb74dd8b817701560fc1ff1ce79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3d7a00651b75409a8db12c098aae4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a4c3d7a00651b75409a8db12c098aae4d">LagrangeInterpolatingPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;times, const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a4c3d7a00651b75409a8db12c098aae4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of LagrangeInterpolatingPolynomial(times, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a4c3d7a00651b75409a8db12c098aae4d">More...</a><br /></td></tr>
<tr class="separator:a4c3d7a00651b75409a8db12c098aae4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:aad4001fcda1c36c46e6589a1c3c94e7b inherit pub_static_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aad4001fcda1c36c46e6589a1c3c94e7b">RandomSegmentTimes</a> (int num_segments, std::default_random_engine &amp;generator)</td></tr>
<tr class="separator:aad4001fcda1c36c46e6589a1c3c94e7b inherit pub_static_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">kEpsilonTime</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::epsilon()</td></tr>
<tr class="memdesc:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum delta quantity used for comparing time.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">More...</a><br /></td></tr>
<tr class="separator:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a293c775020a0b5f25770dd398ea14f1d inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a293c775020a0b5f25770dd398ea14f1d">PiecewiseTrajectory</a> ()=default</td></tr>
<tr class="separator:a293c775020a0b5f25770dd398ea14f1d inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a205b86a6552919d515ba544c185c04c3">PiecewiseTrajectory</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>)</td></tr>
<tr class="memdesc:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>breaks</code> increments must be greater or equal to kEpsilonTime.  <a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a205b86a6552919d515ba544c185c04c3">More...</a><br /></td></tr>
<tr class="separator:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1bc48c32072f8a84aa295528a66440 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0f1bc48c32072f8a84aa295528a66440">SegmentTimesEqual</a> (const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;b, <a class="el" href="classdouble.html">double</a> tol=<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">kEpsilonTime</a>) const</td></tr>
<tr class="separator:a0f1bc48c32072f8a84aa295528a66440 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a71ddfb9ab85211d522ad0e948c426 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> () const</td></tr>
<tr class="separator:aa1a71ddfb9ab85211d522ad0e948c426 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeabb3c1dcb114550eee132dcebb3a6e inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aaeabb3c1dcb114550eee132dcebb3a6e">get_mutable_breaks</a> ()</td></tr>
<tr class="separator:aaeabb3c1dcb114550eee132dcebb3a6e inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html">Trajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a0d2a23aec55910c9e1102de7ab8c3249 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a0d2a23aec55910c9e1102de7ab8c3249">Trajectory</a> ()=default</td></tr>
<tr class="separator:a0d2a23aec55910c9e1102de7ab8c3249 inherit pro_methods_classmaliput_1_1drake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9c5cbf1ba95055937fdb8283769df797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5cbf1ba95055937fdb8283769df797">&#9670;&nbsp;</a></span>PolynomialMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt;T&gt; &gt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a44781cbe3dd6c55234638a1b63d4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a44781cbe3dd6c55234638a1b63d4ef">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty piecewise polynomial. </p>

</div>
</div>
<a id="a838cb1725eb9ba7896158fa9032ecdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838cb1725eb9ba7896158fa9032ecdcc">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single segment, constant value constructor over the interval [-∞, ∞]. </p>
<p>The constructed PiecewisePolynomial will return <code>constant_value</code> at every evaluated point (i.e., <code>value(t) = constant_value</code> ∀t ∈ [-∞, ∞]). </p>

</div>
</div>
<a id="a9145f61319cb888cb71fc58cebc8fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145f61319cb888cb71fc58cebc8fe38">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomials_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PiecewisePolynomial using matrix-output Polynomials defined over each segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>polynomials.size() == breaks.size() - 1</code> </dd></dl>

</div>
</div>
<a id="a481736a225b93bd2343445f02c8eafec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481736a225b93bd2343445f02c8eafec">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PiecewisePolynomial using scalar-output Polynomials defined over each segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>polynomials.size() == breaks.size() - 1</code> </dd></dl>

</div>
</div>
<a id="a5dc4d107b331f4e33f2893826c44be27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc4d107b331f4e33f2893826c44be27">&#9670;&nbsp;</a></span>~PiecewisePolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac93013774f250920857c17c083350b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93013774f250920857c17c083350b57">&#9670;&nbsp;</a></span>AppendCubicHermiteSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AppendCubicHermiteSegment </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CubicHermite spline construction has a nice property of being incremental (each segment can be solved independently). </p>
<p>Given a new sample and it's derivative, this method adds one segment to the end of <code>this</code> where the start sample and derivative are taken as the value and derivative at the final break of <code>this</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> is not <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a> </dd>
<dd>
<code>time</code> &gt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> </dd>
<dd>
<code>sample</code> and <code>sample_dot</code> must have size <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9" title="Returns the row count of the output matrices.">rows()</a> x <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b" title="Returns the column count of the output matrices.">cols()</a>. </dd></dl>

</div>
</div>
<a id="a603a4e747fb099305c01f8762e8cff23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603a4e747fb099305c01f8762e8cff23">&#9670;&nbsp;</a></span>AppendFirstOrderSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AppendFirstOrderSegment </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a new sample, this method adds one segment to the end of <code>this</code> using a first-order hold, where the start sample is taken as the value at the final break of <code>this</code>. </p>

</div>
</div>
<a id="abadcaf3333fa82c22d1835f0b151522c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadcaf3333fa82c22d1835f0b151522c">&#9670;&nbsp;</a></span>Block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; Block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a trajectory representing a block of size (block_rows, block_cols) starting at (start_row, start_col) from the <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> such that ret.value(t) = this.value(t).block(i,j,p,q); </dd></dl>

</div>
</div>
<a id="a0ed3c4da7fb13c79983a5be307338583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed3c4da7fb13c79983a5be307338583">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; T &gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A deep copy of this <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a>. </dd></dl>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a5921e7a9f7532c682fd111d829f0258e">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="adca8eca2ee324f57170dedfb4b06160b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca8eca2ee324f57170dedfb4b06160b">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column count of the output matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a0e99f338d336c4da23d6d773f4463a52">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a75d7ffe2f4e1a808aaeb76a871f772e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d7ffe2f4e1a808aaeb76a871f772e2">&#9670;&nbsp;</a></span>ConcatenateInTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConcatenateInTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <code>other</code> to the end of <code>this</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The resulting PiecewisePolynomial will only be continuous to the degree that the first <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of <code>other</code> is continuous with the last <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of <code>this</code>. See warning about evaluating discontinuous derivatives at breaks in <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a405f92e0e677a316b9a8ed8ec841befd" title="Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding seg...">derivative()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>PiecewisePolynomial instance to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if trajectories' dimensions do not match each other (either <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9" title="Returns the row count of the output matrices.">rows()</a> or <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b" title="Returns the column count of the output matrices.">cols()</a> does not match between this and <code>other</code>). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a></code> and <code>other-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a></code> are not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory&lt;T&gt;::kEpsilonTime</a> from each other. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5076a155bf5d04598cd9bf7ec40b0ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5076a155bf5d04598cd9bf7ec40b0ddf">&#9670;&nbsp;</a></span>Cubic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; Cubic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic_end_condition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94ee5e424405c47c2a7f62e14564d095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ee5e424405c47c2a7f62e14564d095">&#9670;&nbsp;</a></span>CubicHermite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicHermite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Corresponding columns of <code>samples</code> and <code>samples_dot</code> are used as the sample point and independent variable derivative, respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == samples_dot.cols() == breaks.size()</code>. @pydrake_mkdoc_identifier{vector} </dd></dl>

</div>
</div>
<a id="aae84462532164ec6fb3f9b181546242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae84462532164ec6fb3f9b181546242e">&#9670;&nbsp;</a></span>CubicHermite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicHermite </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples and derivatives of samples (<code>samples_dot</code>); each matrix element of <code>samples_dot</code> represents the derivative with respect to the independent variable (e.g., the time derivative) of the corresponding entry in <code>samples</code>. </p>
<p>Each segment is fully specified by <code>samples</code> and <code>sample_dot</code> at both ends. Second derivatives are not continuous.</p>
<p>@pydrake_mkdoc_identifier{matrix} </p>

</div>
</div>
<a id="ab7bb43b4e72ae2a372e558b0bdb08933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bb43b4e72ae2a372e558b0bdb08933">&#9670;&nbsp;</a></span>CubicShapePreserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicShapePreserving </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero_end_point_derivatives</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicShapePreserving(breaks, samples, zero_end_point_derivatives) that uses vector samples and Eigen VectorXd and MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{vector} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63b48f9ba20cdd5c5cd6b2e734aeebd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b48f9ba20cdd5c5cd6b2e734aeebd4">&#9670;&nbsp;</a></span>CubicShapePreserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicShapePreserving </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero_end_point_derivatives</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using vector samples, where each column of <code>samples</code> represents a sample point. </p>
<p>First derivatives are chosen to be "shape preserving", i.e. if <code>samples</code> is monotonic within some interval, the interpolated data will also be monotonic. The second derivative is not guaranteed to be smooth across the entire spline.</p>
<p>MATLAB calls this method "pchip" (short for "Piecewise Cubic Hermite
Interpolating Polynomial"), and provides a nice description in their documentation. <a href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a good reference.</p>
<p>If <code>zero_end_point_derivatives</code> is <code>false</code>, the first and last first derivative is chosen using a non-centered, shape-preserving three-point formulae. See equation (2.10) in the following reference for more details. <a href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If <code>zero_end_point_derivatives</code> is <code>true</code>, they are set to zeros.</p>
<p>If <code>zero_end_point_derivatives</code> is <code>false</code>, <code>breaks</code> and <code>samples</code> must have at least 3 elements for the algorithm to determine the first derivatives.</p>
<p>If <code>zero_end_point_derivatives</code> is <code>true</code>, <code>breaks</code> and <code>samples</code> may have 2 or more elements. For the 2 elements case, the result is equivalent to computing a cubic polynomial whose values are given by <code>samples</code>, and derivatives set to zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if:<ul>
<li><code>breaks</code> has length smaller than 3 and <code>zero_end_point_derivatives</code> is <code>false</code>,</li>
<li><code>breaks</code> has length smaller than 2 and <code>zero_end_point_derivatives</code> is true.</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{matrix} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a084e9ea134495967cf3c17f9d522a3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084e9ea134495967cf3c17f9d522a3d9">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic_end_condition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code>. @pydrake_mkdoc_identifier{3args_vector} </dd></dl>

</div>
</div>
<a id="a1be5045e91910c89639178ec98cfd720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be5045e91910c89639178ec98cfd720">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#ad8cae6fa5770ea8da991ede4ae30a693" title="Constructs a third order PiecewisePolynomial using matrix samples.">CubicWithContinuousSecondDerivatives()</a> that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{4args_vector} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03c3fa44ee4e93658163ad2234ec7270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c3fa44ee4e93658163ad2234ec7270">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic_end_condition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples. </p>
<p>The PiecewisePolynomial is constructed such that the interior segments have the same value, first and second derivatives at <code>breaks</code>. If <code>periodic_end_condition</code> is <code>false</code> (default), then the "Not-a-sample" end condition is used here, which means the third derivatives are continuous for the first two and last two segments. If <code>periodic_end_condition</code> is <code>true</code>, then the first and second derivatives between the end of the last segment and the beginning of the first segment will be continuous. Note that the periodic end condition does not require the first and last sample to be collocated, nor does it add an additional sample to connect the first and last segments. Only first and second derivative continuity is enforced. See <a href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and <a href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about cubic splines and their end conditions. The MATLAB docs for methods "spline" and "csape" are also good references.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>breaks</code> and <code>samples</code> must have at least 3 elements. If <code>periodic_end_condition</code> is <code>true</code>, then for two samples, it would produce a straight line (use <code>FirstOrderHold</code> for this instead), and if <code>periodic_end_condition</code> is <code>false</code> the problem is ill-defined. @pydrake_mkdoc_identifier{3args_matrix} </dd></dl>

</div>
</div>
<a id="ad8cae6fa5770ea8da991ede4ae30a693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cae6fa5770ea8da991ede4ae30a693">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples. </p>
<p>The PiecewisePolynomial is constructed such that the interior segments have the same value, first and second derivatives at <code>breaks</code>. <code>sample_dot_at_start</code> and <code>sample_dot_at_end</code> are used for the first and last first derivatives.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>sample_dot_at_start</code> or <code>sample_dot_at_end</code> and <code>samples</code> have inconsistent dimensions. </td></tr>
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{4args_matrix} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405f92e0e677a316b9a8ed8ec841befd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f92e0e677a316b9a8ed8ec841befd">&#9670;&nbsp;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; derivative </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>derivative_order</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding segment in <code>this</code>. </p>
<p>Any rules or limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at the left hand side of the interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">derivative_order</td><td>The order of the derivative, namely, if <code>derivative_order</code> = n, the n'th derivative of the polynomial will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>In the event of discontinuous derivatives evaluated at breaks, it is not defined which polynomial (i.e., to the left or right of the break) will be the one that is evaluated at the break. </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this trajectory has no breaks/samples/polynomials. </p>

</div>
</div>
<a id="ad7d0be81b234de76119137d20f22944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d0be81b234de76119137d20f22944f">&#9670;&nbsp;</a></span>FirstOrderHold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; FirstOrderHold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of FirstOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{vector} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ced7dd68c8859113c25ddb246c0731d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ced7dd68c8859113c25ddb246c0731d">&#9670;&nbsp;</a></span>FirstOrderHold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; FirstOrderHold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a piecewise linear PiecewisePolynomial using matrix samples. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{matrix} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc499221b2ff0630d2b79d1fc9ec61d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc499221b2ff0630d2b79d1fc9ec61d4">&#9670;&nbsp;</a></span>getPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp; getPolynomial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index. </p>
<p>Equivalent to <code>getPolynomialMatrix(segment_index)(row, col)</code>. </p><dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <code>segment_index</code>. </dd></dl>

</div>
</div>
<a id="acda577405638cba7837a16bce8362e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda577405638cba7837a16bce8362e08">&#9670;&nbsp;</a></span>getPolynomialMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;::<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp; getPolynomialMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the matrix of Polynomials corresponding to the given segment index. </p>
<dl class="section warning"><dt>Warning</dt><dd><code>segment_index</code> is not checked for validity. </dd></dl>

</div>
</div>
<a id="aa5a111a1944f16bb21873433d4b7b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a111a1944f16bb21873433d4b7b31d">&#9670;&nbsp;</a></span>getSegmentPolynomialDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSegmentPolynomialDegree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the degree of the <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index. </p>
<p>Equivalent to <code>getPolynomial(segment_index, row, col).GetDegree()</code>. </p>

</div>
</div>
<a id="a5b78f80cc7c6bffcf1ba8a79416544c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b78f80cc7c6bffcf1ba8a79416544c9">&#9670;&nbsp;</a></span>integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; integral </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value_at_start_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial that is the indefinite integral of this one. </p>
<p>Any rules or limitations of Polynomial::integral() also apply to this function.</p>
<p>If <code>value_at_start_time</code> is given, it does the following only for the first segment: adds <code>value_at_start_time(row,col)</code> as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="aeaceab81f8d6fd7e3af6d32b076fea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaceab81f8d6fd7e3af6d32b076fea0a">&#9670;&nbsp;</a></span>integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; integral </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value_at_start_time</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial that is the indefinite integral of this one. </p>
<p>Any rules or limitations of Polynomial::integral() also apply to this function.</p>
<p>If <code>value_at_start_time</code> is given, it does the following only for the first segment: adds that constant as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a5d7edaa991443e887ca36e0fd20b96c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7edaa991443e887ca36e0fd20b96c7">&#9670;&nbsp;</a></span>isApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isApprox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;&#160;</td>
          <td class="paramname"><em>tol_type</em> = <code><a class="el" href="namespacemaliput_1_1drake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">ToleranceType::kRelative</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a PiecewisePolynomial is approximately equal to this one by calling <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html#ad96f76c37313cb0d62582faccf358345" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a> on every element of every segment. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmaliput_1_1drake_1_1_polynomial.html#ad96f76c37313cb0d62582faccf358345" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a>. </dd></dl>

</div>
</div>
<a id="a4c3d7a00651b75409a8db12c098aae4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3d7a00651b75409a8db12c098aae4d">&#9670;&nbsp;</a></span>LagrangeInterpolatingPolynomial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; LagrangeInterpolatingPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == times.size()</code>. @pydrake_mkdoc_identifier{vector} </dd></dl>

</div>
</div>
<a id="a101bb74dd8b817701560fc1ff1ce79c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101bb74dd8b817701560fc1ff1ce79c1">&#9670;&nbsp;</a></span>LagrangeInterpolatingPolynomial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; LagrangeInterpolatingPolynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible degree that passes through all of the sample points. </p>
<p>See "polynomial
interpolation" and/or "Lagrange polynomial" on Wikipedia for more information. </p><dl class="section pre"><dt>Precondition</dt><dd><code>times</code> must be monotonically increasing. </dd>
<dd>
<code>samples.size() == times.size()</code>. @pydrake_mkdoc_identifier{matrix} </dd></dl>

</div>
</div>
<a id="a516c09907a0d8f3f50ee68cea561358f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516c09907a0d8f3f50ee68cea561358f">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication). </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this *= other</code> will correspond to t⁵. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a>1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3bed7e633dcce69577d997599ffceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bed7e633dcce69577d997599ffceeb">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication), storing the result in <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this *= other</code> will correspond to t⁵. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02cf66c84fa13d64a6313a3b28f8ba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cf66c84fa13d64a6313a3b28f8ba52">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9c6238655481e93cd87e12125e5cb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c6238655481e93cd87e12125e5cb4b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this + other</code> will correspond to t³ + t². </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8719499effc43742b2551756aa5f0ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8719499effc43742b2551756aa5f0ca3">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae44a69e3135eab274fe0e1eefd64397c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44a69e3135eab274fe0e1eefd64397c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this += other</code> will correspond to t³ + t². </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd3b25aa337e3ee75f62173d9694f5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3b25aa337e3ee75f62173d9694f5e6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; operator-</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements unary minus operator. </p>
<p>Multiplies each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in <code>this</code> by -1. </p>

</div>
</div>
<a id="a11188ab9da7d28178b479fb982e7584c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11188ab9da7d28178b479fb982e7584c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a036be284513923ec17cc591add07dced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036be284513923ec17cc591add07dced">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this - other</code> will correspond to t² - t³. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa886143234d257349d3b4c3074b2b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa886143234d257349d3b4c3074b2b46">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a78122bd02f0a481d15f004538fe3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a78122bd02f0a481d15f004538fe3cc">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts each <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classmaliput_1_1drake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this -= other</code> will correspond to t² - t³. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#ab5b1a0b2d9113c656018bcace89985b4">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88e900c12b23dd1cb0bccb6d0357db5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e900c12b23dd1cb0bccb6d0357db5f">&#9670;&nbsp;</a></span>RemoveFinalSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveFinalSegment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the final segment from the trajectory, reducing the number of segments by 1. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> is not <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a> </dd></dl>

</div>
</div>
<a id="a39001029f6f2e13a8890f233254c4709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39001029f6f2e13a8890f233254c4709">&#9670;&nbsp;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>, <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#abf2912689d33fd58c54d119cab8f4140" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a>, etc. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>rows</code> x <code>cols</code> must equal this.rows() * this.cols(). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Eigen::PlainObjectBase::resize(). </dd></dl>

</div>
</div>
<a id="afca7568bb098808d681cb14d7fa09f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7568bb098808d681cb14d7fa09f99">&#9670;&nbsp;</a></span>ReverseTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReverseTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the trajectory so that pp_after(t) = pp_before(-t). </p>
<dl class="section note"><dt>Note</dt><dd>The new trajectory will evaluate differently at precisely the break points if the original trajectory was discontinuous at the break points. This is because the segments are defined on the half-open intervals [breaks(i), breaks(i+1)), and the order of the breaks have been reversed. </dd></dl>

</div>
</div>
<a id="a9aa1f1cfff6dcb352d5fbb15a80ee1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the row count of the output matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a857db071d9bf847d026ba7046aa9744e">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a16274d0c316c76ded4b85111b38ece15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16274d0c316c76ded4b85111b38ece15">&#9670;&nbsp;</a></span>scalarValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T scalarValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the trajectory at the given time without returning the entire matrix. </p>
<p>Equivalent to value(t)(row, col). </p><dl class="section warning"><dt>Warning</dt><dd>See warnings in <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>. </dd></dl>

</div>
</div>
<a id="a923a4ac5ef6f85f444519188d9dbd3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a4ac5ef6f85f444519188d9dbd3e1">&#9670;&nbsp;</a></span>ScaleTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScaleTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the time of the trajectory by non-negative <code>scale</code> (use <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99" title="Modifies the trajectory so that pp_after(t) = pp_before(-t).">ReverseTime()</a> if you want to also negate time). </p>
<p>The resulting polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <code>scale</code>=2 will result in a trajectory that is twice as long (<a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a> and <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> have both doubled). </p>

</div>
</div>
<a id="a9a7863e6bf8a3ccb5335563370305add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7863e6bf8a3ccb5335563370305add">&#9670;&nbsp;</a></span>setPolynomialMatrixBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPolynomialMatrixBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col_start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the specified block of the PolynomialMatrix at the given segment index. </p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <code>segment_index</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This code relies upon Eigen to verify that the replacement block is not too large. </dd></dl>

</div>
</div>
<a id="a728995759fa06a8d1a2b967d313b6d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728995759fa06a8d1a2b967d313b6d6b">&#9670;&nbsp;</a></span>shiftRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shiftRight </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <code>offset</code> to all of the breaks. </p>
<p><code>offset</code> need not be a non-negative number. The resulting polynomial will evaluate to pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <code>offset</code>=2 will result in the <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a> and <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> being 2 seconds later. </p>

</div>
</div>
<a id="aaa36391c5f1fc46089a7b4c9e0953a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa36391c5f1fc46089a7b4c9e0953a0e">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PiecewisePolynomial comprising the <code>num_segments</code> segments starting at the specified <code>start_segment_index</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <code>segment_index</code>. </dd></dl>

</div>
</div>
<a id="a19b632df0f98f9aaf224e534fac69ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b632df0f98f9aaf224e534fac69ec8">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;T&gt; value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the PiecewisePolynomial at the given time t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The time at which to evaluate the PiecewisePolynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix of evaluated values. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If T == symbolic::Expression, <code>t.is_constant()</code> must be true.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If t does not lie in the range that the polynomial is defined over, the polynomial will silently be evaluated at the closest point to t. For example, <code>value(-1)</code> will return <code>value(0)</code> for a polynomial defined over [0, 1]. </dd>
<dd>
See warning in the <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#polynomial_warning">constructor overview</a> above. </dd></dl>

<p>Implements <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_trajectory.html#a50929a6273d23c3db2a0ba8d431fa9d9">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a9b98ea8f2257d622472c8007150df254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b98ea8f2257d622472c8007150df254">&#9670;&nbsp;</a></span>ZeroOrderHold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; ZeroOrderHold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd/MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{vector} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a695f2e7cbbe881ea10b500cb77da61fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695f2e7cbbe881ea10b500cb77da61fb">&#9670;&nbsp;</a></span>ZeroOrderHold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; ZeroOrderHold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemaliput_1_1drake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a piecewise constant PiecewisePolynomial using matrix samples. </p>
<p>Note that constructing a PiecewisePolynomial requires at least two sample points, although in this case, the second sample point's value is ignored, and only its break time is used.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. @pydrake_mkdoc_identifier{matrix} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="piecewise__polynomial_8h.html">piecewise_polynomial.h</a></li>
<li><a class="el" href="piecewise__polynomial_8cc.html">piecewise_polynomial.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial_html_a7ced7dd68c8859113c25ddb246c0731d"><div class="ttname"><a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a7ced7dd68c8859113c25ddb246c0731d">maliput::drake::trajectories::PiecewisePolynomial::FirstOrderHold</a></div><div class="ttdeci">static PiecewisePolynomial&lt; T &gt; FirstOrderHold(const std::vector&lt; T &gt; &amp;breaks, const std::vector&lt; MatrixX&lt; T &gt;&gt; &amp;samples)</div><div class="ttdoc">Constructs a piecewise linear PiecewisePolynomial using matrix samples.</div><div class="ttdef"><b>Definition:</b> piecewise_polynomial.cc:542</div></div>
<div class="ttc" id="aclassmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial_html_a19b632df0f98f9aaf224e534fac69ec8"><div class="ttname"><a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8">maliput::drake::trajectories::PiecewisePolynomial::value</a></div><div class="ttdeci">MatrixX&lt; T &gt; value(const T &amp;t) const override</div><div class="ttdoc">Evaluates the PiecewisePolynomial at the given time t.</div><div class="ttdef"><b>Definition:</b> piecewise_polynomial.h:505</div></div>
<div class="ttc" id="aclassmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory_html_aa1a71ddfb9ab85211d522ad0e948c426"><div class="ttname"><a href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">maliput::drake::trajectories::PiecewiseTrajectory::breaks</a></div><div class="ttdeci">const std::vector&lt; T &gt; &amp; breaks() const</div><div class="ttdef"><b>Definition:</b> piecewise_trajectory.h:67</div></div>
<div class="ttc" id="anamespacemaliput_1_1drake_html_ab0a2621977171e1d2d5b64c55141b9b2"><div class="ttname"><a href="namespacemaliput_1_1drake.html#ab0a2621977171e1d2d5b64c55141b9b2">maliput::drake::Polynomiald</a></div><div class="ttdeci">Polynomial&lt; double &gt; Polynomiald</div><div class="ttdef"><b>Definition:</b> polynomial.h:480</div></div>
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemaliput.html">maliput</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1drake.html">drake</a></li><li class="navelem"><a class="el" href="namespacemaliput_1_1drake_1_1trajectories.html">trajectories</a></li><li class="navelem"><a class="el" href="classmaliput_1_1drake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
